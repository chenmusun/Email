; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	e:\newGGDevelop\Client\GGJsonCPP\json_reader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4length_error@std@@6B@			; std::length_error::`RTTI Complete Object Locator'
PUBLIC	??_R3length_error@std@@8			; std::length_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2length_error@std@@8			; std::length_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@length_error@std@@8		; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4logic_error@std@@6B@			; std::logic_error::`RTTI Complete Object Locator'
PUBLIC	??_R3logic_error@std@@8				; std::logic_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2logic_error@std@@8				; std::logic_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@logic_error@std@@8		; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_alloc@std@@6B@				; std::bad_alloc::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_alloc@std@@8				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_alloc@std@@8				; std::bad_alloc::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_alloc@std@@8			; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_C@_0P@GHFPNOJB@bad?5allocation?$AA@		; `string'
PUBLIC	??$?0VPathArgument@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::PathArgument>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >
PUBLIC	??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
PUBLIC	??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
PUBLIC	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
PUBLIC	?_Checked_iterator_base@?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEPBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >
PUBLIC	??$_Ptr_cat@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@AAPAVPathArgument@Json@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *>
PUBLIC	??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument const *,Json::PathArgument *,std::allocator<Json::PathArgument> >
PUBLIC	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@V?$allocator@VPathArgument@Json@@@2@@stdext@@YAPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@0PAV12@AAV?$allocator@VPathArgument@Json@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *,std::allocator<Json::PathArgument> >
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@0PAV23@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >
PUBLIC	??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::~_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >
PUBLIC	??1?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::~_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
PUBLIC	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
PUBLIC	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
PUBLIC	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
PUBLIC	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
PUBLIC	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VPathArgument@Json@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ ; std::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>
PUBLIC	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	?_Make_iter@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Make_iter
PUBLIC	??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==
PUBLIC	??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
PUBLIC	?erase@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::erase
PUBLIC	?clear@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::clear
PUBLIC	??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ; std::_Allocate<Json::PathArgument>
PUBLIC	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate
PUBLIC	?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument>::max_size
PUBLIC	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
PUBLIC	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
PUBLIC	?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
PUBLIC	??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::PathArgument> >
PUBLIC	??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::PathArgument> >
PUBLIC	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
PUBLIC	??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$_Copy_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$unchecked_copy@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ; stdext::unchecked_copy<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::PathArgument *>
PUBLIC	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
PUBLIC	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
PUBLIC	??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ; std::_Construct<Json::PathArgument,Json::PathArgument>
PUBLIC	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
PUBLIC	??_GPathArgument@Json@@QAEPAXI@Z		; Json::PathArgument::`scalar deleting destructor'
PUBLIC	??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ; std::_Destroy<Json::PathArgument>
PUBLIC	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
PUBLIC	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
PUBLIC	??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
PUBLIC	??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>
PUBLIC	??4?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::operator=
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
PUBLIC	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
PUBLIC	??F?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--
PUBLIC	??F?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$copy_backward@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$_Iter_random@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$_Ptr_cat@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$copy@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase
PUBLIC	?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
PUBLIC	??H?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+
PUBLIC	??$_Iter_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
PUBLIC	?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
PUBLIC	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
PUBLIC	??A?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator[]
PUBLIC	??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ; std::swap<Json::Value *>
PUBLIC	??$_Swap_adl@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ; std::_Swap_adl<Json::Value *>
PUBLIC	?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse
PUBLIC	??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator++
PUBLIC	??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
PUBLIC	??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator==
PUBLIC	??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator!=
PUBLIC	??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	?_Checked_iterator_base@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$_Iter_random@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Iter_random<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$_Ptr_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+
PUBLIC	??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-
PUBLIC	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>
PUBLIC	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>
PUBLIC	?_Checked_iterator_base@?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator==
PUBLIC	??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator!=
PUBLIC	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
PUBLIC	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
PUBLIC	??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
PUBLIC	??E?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
PUBLIC	??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??$copy@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
PUBLIC	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
PUBLIC	??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
PUBLIC	??H?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
PUBLIC	??$_Iter_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::swap<Json::Reader::ErrorInfo>
PUBLIC	??$_Swap_adl@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::_Swap_adl<Json::Reader::ErrorInfo>
PUBLIC	?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse
PUBLIC	??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	?_Checked_iterator_base@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Iter_random@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Iter_random<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Ptr_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$copy@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ	; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	??$?0PAVValue@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Value *>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
PUBLIC	??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::~_Container_base_aux_alloc_real<std::allocator<Json::Value *> >
PUBLIC	??1?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::~_Deque_map<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::~_Deque_val<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate
PUBLIC	??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value * *>
PUBLIC	?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value * *>::destroy
PUBLIC	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
PUBLIC	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
PUBLIC	??0_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::_Container_base_aux
PUBLIC	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
PUBLIC	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Reader::ErrorInfo>
PUBLIC	??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
PUBLIC	??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??1_Container_base_aux@std@@QAE@XZ		; std::_Container_base_aux::~_Container_base_aux
PUBLIC	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate
PUBLIC	??1?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::~_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??1?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
PUBLIC	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate
PUBLIC	??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo *>
PUBLIC	?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo *>::destroy
PUBLIC	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
PUBLIC	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
PUBLIC	??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
PUBLIC	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
PUBLIC	??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z ; std::_Construct<Json::Value *,Json::Value *>
PUBLIC	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ; std::allocator<Json::Value *>::construct
PUBLIC	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
PUBLIC	??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
PUBLIC	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
PUBLIC	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size
PUBLIC	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
PUBLIC	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z ; std::_Iter_cat<Json::Value * * *>
PUBLIC	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::Value * * *>
PUBLIC	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z ; std::_Checked_base<Json::Value * * *>
PUBLIC	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	??$unchecked_fill_n@PAPAPAVValue@Json@@IPAPAV12@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; stdext::unchecked_fill_n<Json::Value * * *,unsigned int,Json::Value * *>
PUBLIC	??$_Uninit_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * * *,Json::Value * * *>
PUBLIC	??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::Value * *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Value * *> >
PUBLIC	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
PUBLIC	??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value *>
PUBLIC	?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy
PUBLIC	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
PUBLIC	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
PUBLIC	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
PUBLIC	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
PUBLIC	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
PUBLIC	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
PUBLIC	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
PUBLIC	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
PUBLIC	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct
PUBLIC	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
PUBLIC	??0bad_alloc@std@@QAE@PBD@Z			; std::bad_alloc::bad_alloc
PUBLIC	??1bad_alloc@std@@UAE@XZ			; std::bad_alloc::~bad_alloc
PUBLIC	??_Gbad_alloc@std@@UAEPAXI@Z			; std::bad_alloc::`scalar deleting destructor'
PUBLIC	??0bad_alloc@std@@QAE@ABV01@@Z			; std::bad_alloc::bad_alloc
PUBLIC	??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
PUBLIC	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
PUBLIC	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size
PUBLIC	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
PUBLIC	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
PUBLIC	??0logic_error@std@@QAE@ABV01@@Z		; std::logic_error::logic_error
PUBLIC	?what@logic_error@std@@UBEPBDXZ			; std::logic_error::what
PUBLIC	??_Glogic_error@std@@UAEPAXI@Z			; std::logic_error::`scalar deleting destructor'
PUBLIC	??1logic_error@std@@UAE@XZ			; std::logic_error::~logic_error
PUBLIC	??1length_error@std@@UAE@XZ			; std::length_error::~length_error
PUBLIC	??_Glength_error@std@@UAEPAXI@Z			; std::length_error::`scalar deleting destructor'
PUBLIC	??0length_error@std@@QAE@ABV01@@Z		; std::length_error::length_error
PUBLIC	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
PUBLIC	??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z ; std::_Iter_cat<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
PUBLIC	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$unchecked_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; stdext::unchecked_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
PUBLIC	??$_Uninit_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
PUBLIC	??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
PUBLIC	??1ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::~ErrorInfo
PUBLIC	??_GErrorInfo@Reader@Json@@QAEPAXI@Z		; Json::Reader::ErrorInfo::`scalar deleting destructor'
PUBLIC	??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo>
PUBLIC	?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy
PUBLIC	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
PUBLIC	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
PUBLIC	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
PUBLIC	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
PUBLIC	??Z?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-=
PUBLIC	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
PUBLIC	??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
PUBLIC	??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$copy_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Iter_random@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
PUBLIC	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
PUBLIC	??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??$copy@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
PUBLIC	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
PUBLIC	?_Checked_iterator_base@?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base
PUBLIC	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>
PUBLIC	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
PUBLIC	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z	; Json::Reader::ErrorInfo::operator=
PUBLIC	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator==
PUBLIC	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=
PUBLIC	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
PUBLIC	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
PUBLIC	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
PUBLIC	??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
PUBLIC	??$_Fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0ABVErrorInfo@Reader@Json@@@Z ; std::_Fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,Json::Reader::ErrorInfo>
PUBLIC	??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>
PUBLIC	?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n
PUBLIC	??Y?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
PUBLIC	??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
PUBLIC	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVValue@Json@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::Value *,int,Json::Value * const *,Json::Value * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::Value *,int,Json::Value * const *,Json::Value * const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@PAVValue@Json@@HPBQAV12@ABQAV12@@std@@QAE@XZ ; std::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>
PUBLIC	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>
PUBLIC	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
PUBLIC	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
PUBLIC	??Y?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
PUBLIC	??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
PUBLIC	??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-=
PUBLIC	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
PUBLIC	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
PUBLIC	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container
PUBLIC	??0_Iterator_base_aux@std@@QAE@XZ		; std::_Iterator_base_aux::_Iterator_base_aux
PUBLIC	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VErrorInfo@Reader@Json@@HPBV345@ABV345@V_Iterator_base_aux@2@@std@@QAE@XZ ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &,std::_Iterator_base_aux>
PUBLIC	??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ ; std::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>
PUBLIC	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
PUBLIC	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
PUBLIC	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
PUBLIC	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator++
PUBLIC	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
PUBLIC	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ	; std::_Iterator_base_aux::_Has_container
PUBLIC	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator==
PUBLIC	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator!=
PUBLIC	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	?what@runtime_error@std@@UBEPBDXZ		; std::runtime_error::what
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_R0?AVlogic_error@std@@@8			; std::logic_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ ; `string'
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@ ; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ ; `string'
PUBLIC	??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_0BG@PKNPKJIB@Error?5from?5reader?3?5?$CFs?$AA@ ; `string'
PUBLIC	??_C@_0N@KACHDPPK@reader?5error?$AA@		; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVlength_error@std@@@8			; std::length_error `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
PUBLIC	__CTA3?AVlength_error@std@@
PUBLIC	__TI3?AVlength_error@std@@
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_R0?AVbad_alloc@std@@@8			; std::bad_alloc `RTTI Type Descriptor'
PUBLIC	__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVbad_alloc@std@@
PUBLIC	__TI2?AVbad_alloc@std@@
PUBLIC	??_7bad_alloc@std@@6B@				; std::bad_alloc::`vftable'
PUBLIC	??_7logic_error@std@@6B@			; std::logic_error::`vftable'
PUBLIC	??_7length_error@std@@6B@			; std::length_error::`vftable'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
EXTRN	?what@exception@std@@UBEPBDXZ:PROC		; std::exception::what
EXTRN	??0exception@std@@QAE@ABV01@@Z:PROC		; std::exception::exception
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
EXTRN	__imp_??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z:PROC
EXTRN	__imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ:PROC
EXTRN	__imp__sscanf:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z:PROC
EXTRN	__imp_?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z:PROC
EXTRN	__imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z:PROC
EXTRN	__imp_?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	__imp_??0exception@std@@QAE@ABQBD@Z:PROC
EXTRN	__imp_?what@exception@std@@UBEPBDXZ:PROC
EXTRN	??_Ebad_alloc@std@@UAEPAXI@Z:PROC		; std::bad_alloc::`vector deleting destructor'
EXTRN	??_Elogic_error@std@@UAEPAXI@Z:PROC		; std::logic_error::`vector deleting destructor'
EXTRN	??_Elength_error@std@@UAEPAXI@Z:PROC		; std::length_error::`vector deleting destructor'
EXTRN	__imp__memmove_s:PROC
EXTRN	__imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp__sprintf_s:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	__imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:PROC
EXTRN	__imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z:PROC
EXTRN	__imp___invalid_parameter_noinfo:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z:PROC
EXTRN	__imp_??0exception@std@@QAE@XZ:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z:PROC
EXTRN	__imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ:PROC
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp_??1exception@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ:PROC
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	__imp_??0exception@std@@QAE@ABV01@@Z:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@runtime_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7length_error@std@@6B@
CONST	SEGMENT
??_7length_error@std@@6B@ DD FLAT:??_R4length_error@std@@6B@ ; std::length_error::`vftable'
	DD	FLAT:??_Elength_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4length_error@std@@6B@
rdata$r	SEGMENT
??_R4length_error@std@@6B@ DD 00H			; std::length_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3length_error@std@@8
rdata$r	SEGMENT
??_R3length_error@std@@8 DD 00H				; std::length_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2length_error@std@@8
rdata$r	SEGMENT
??_R2length_error@std@@8 DD FLAT:??_R1A@?0A@EA@length_error@std@@8 ; std::length_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@logic_error@std@@8
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@length_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@length_error@std@@8 DD FLAT:??_R0?AVlength_error@std@@@8 ; std::length_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3length_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7logic_error@std@@6B@
CONST	SEGMENT
??_7logic_error@std@@6B@ DD FLAT:??_R4logic_error@std@@6B@ ; std::logic_error::`vftable'
	DD	FLAT:??_Elogic_error@std@@UAEPAXI@Z
	DD	FLAT:?what@logic_error@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4logic_error@std@@6B@
rdata$r	SEGMENT
??_R4logic_error@std@@6B@ DD 00H			; std::logic_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R3logic_error@std@@8
rdata$r	SEGMENT
??_R3logic_error@std@@8 DD 00H				; std::logic_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2logic_error@std@@8
rdata$r	SEGMENT
??_R2logic_error@std@@8 DD FLAT:??_R1A@?0A@EA@logic_error@std@@8 ; std::logic_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@logic_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@logic_error@std@@8 DD FLAT:??_R0?AVlogic_error@std@@@8 ; std::logic_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3logic_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_alloc@std@@6B@
CONST	SEGMENT
??_7bad_alloc@std@@6B@ DD FLAT:??_R4bad_alloc@std@@6B@	; std::bad_alloc::`vftable'
	DD	FLAT:??_Ebad_alloc@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R4bad_alloc@std@@6B@
rdata$r	SEGMENT
??_R4bad_alloc@std@@6B@ DD 00H				; std::bad_alloc::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R3bad_alloc@std@@8
rdata$r	SEGMENT
??_R3bad_alloc@std@@8 DD 00H				; std::bad_alloc::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_alloc@std@@8
rdata$r	SEGMENT
??_R2bad_alloc@std@@8 DD FLAT:??_R1A@?0A@EA@bad_alloc@std@@8 ; std::bad_alloc::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_alloc@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_alloc@std@@8 DD FLAT:??_R0?AVbad_alloc@std@@@8 ; std::bad_alloc::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3bad_alloc@std@@8
rdata$r	ENDS
;	COMDAT __TI2?AVbad_alloc@std@@
xdata$x	SEGMENT
__TI2?AVbad_alloc@std@@ DD 00H
	DD	FLAT:??1bad_alloc@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVbad_alloc@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVbad_alloc@std@@
xdata$x	SEGMENT
__CTA2?AVbad_alloc@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVbad_alloc@std@@@8??0bad_alloc@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVbad_alloc@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0bad_alloc@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_alloc@std@@@8
_DATA	SEGMENT
??_R0?AVbad_alloc@std@@@8 DD FLAT:??_7type_info@@6B@	; std::bad_alloc `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVbad_alloc@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT __TI3?AVlength_error@std@@
xdata$x	SEGMENT
__TI3?AVlength_error@std@@ DD 00H
	DD	FLAT:??1length_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA3?AVlength_error@std@@
xdata$x	ENDS
;	COMDAT __CTA3?AVlength_error@std@@
xdata$x	SEGMENT
__CTA3?AVlength_error@std@@ DD 03H
	DD	FLAT:__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlength_error@std@@@8??0length_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlength_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0length_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlength_error@std@@@8
_DATA	SEGMENT
??_R0?AVlength_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::length_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlength_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KACHDPPK@reader?5error?$AA@
CONST	SEGMENT
??_C@_0N@KACHDPPK@reader?5error?$AA@ DB 'reader error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@PKNPKJIB@Error?5from?5reader?3?5?$CFs?$AA@
CONST	SEGMENT
??_C@_0BG@PKNPKJIB@Error?5from?5reader?3?5?$CFs?$AA@ DB 'Error from reade'
	DB	'r: %s', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
CONST	SEGMENT
??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ DB 'expecting '
	DB	'another \u token to begin the second half of a unicode surrog'
	DB	'ate pair', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
CONST	SEGMENT
??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ DB 'additional si'
	DB	'x characters expected to parse unicode surrogate pair.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@
CONST	SEGMENT
??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@ DB 'Unable to pa'
	DB	'rse token length', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
CONST	SEGMENT
??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ DB 'A valid JS'
	DB	'ON document must be either an array or an object value.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT __CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVlogic_error@std@@@8??0logic_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVlogic_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0logic_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVlogic_error@std@@@8
_DATA	SEGMENT
??_R0?AVlogic_error@std@@@8 DD FLAT:??_7type_info@@6B@	; std::logic_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVlogic_error@std@@', 00H
_DATA	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z40 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
_DATA	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
_DATA	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
_DATA	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
_DATA	ENDS
;	COMDAT ??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
CONST	SEGMENT
??_C@_0P@GHFPNOJB@bad?5allocation?$AA@ DB 'bad allocation', 00H ; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@2
$LN2@Fill_n@2:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@2:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@2

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@2
$LN4@Fill_n@2:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT

; 3196 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp

; 3197 : 	for (; 0 < _Count; --_Count, ++_First)

	jmp	SHORT $LN3@Fill_n@3
$LN2@Fill_n@3:
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 4
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Fill_n@3:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@Fill_n@3

; 3198 : 		*_First = _Val;

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@Fill_n@3
$LN4@Fill_n@3:

; 3199 : 	}

	pop	ebp
	ret	0
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEPBVPathArgument@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Checked_iterator_base@?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEPBVPathArgument@Json@@XZ PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 46   : 	{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 47   : 		return _Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 48   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Checked_iterator_base@?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEPBVPathArgument@Json@@XZ ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Checked_iterator_base
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z
_TEXT	SEGMENT
__Tmp$64843 = -4					; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z PROC ; std::swap<Json::Value *>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	ecx

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap@3

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR __Tmp$64843[ebp], edx

; 21   : 
; 22   : 		_Left = _Right;

	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 23   : 		_Right = _Tmp;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Tmp$64843[ebp]
	mov	DWORD PTR [eax], ecx
$LN2@swap@3:

; 24   : 		}
; 25   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ENDP ; std::swap<Json::Value *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z PROC ; std::_Iter_cat<Json::Value * * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z ENDP ; std::_Iter_cat<Json::Value * * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Iter_cat<Json::Reader::ErrorInfo * *>, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Iter_cat<Json::Reader::ErrorInfo * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEPBVPathArgument@Json@@XZ ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Checked_iterator_base

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Swap_adl@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z PROC ; std::_Swap_adl<Json::Value *>, COMDAT

; 30   : 	{	// exchange values stored at _Left and _Right, using ADL

	push	ebp
	mov	ebp, esp

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$swap@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ; std::swap<Json::Value *>
	add	esp, 8

; 32   : 	}

	pop	ebp
	ret	0
??$_Swap_adl@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ENDP ; std::_Swap_adl<Json::Value *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Json::Value * * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Json::Value * * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Json::Reader::ErrorInfo * *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Json::Reader::ErrorInfo * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
__It$ = 8						; size = 4
___formal$ = 12						; size = 1
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<Json::PathArgument *>, COMDAT

; 1146 : 	{

	push	ebp
	mov	ebp, esp

; 1147 : 		return _It;

	mov	eax, DWORD PTR __It$[ebp]
	mov	eax, DWORD PTR [eax]

; 1148 : 	}

	pop	ebp
	ret	0
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@AAPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@AAPAVPathArgument@Json@@@Z PROC ; std::_Ptr_cat<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@AAPAVPathArgument@Json@@@Z ENDP ; std::_Ptr_cat<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@@Z PROC ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,std::_Different_checked_iterator_base_type_tag>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ENDP ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z PROC	; Json::Reader::ErrorInfo::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Reader::ErrorInfo::operator=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Value * *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Value * *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@2

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@2:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z PROC ; std::_Ptr_cat<Json::Value * * *,Json::Value * * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Value * * *,Json::Value * * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z PROC ; std::_Checked_base<Json::Value * * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::Value * * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z ENDP ; std::_Checked_base<Json::Value * * *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 241  : 	{	// destroy [_First, _Last), scalar type (do nothing)

	push	ebp
	mov	ebp, esp

; 242  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Result$ = -8						; size = 4
__Count$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 145  : 	{	// copy [_First, _Last) to raw _Dest, scalar type

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 146  : 	_DEBUG_RANGE(_First, _Last);
; 147  : 	_DEBUG_POINTER(_Dest);
; 148  : 	size_t _Count = (size_t)(_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	sar	eax, 2
	mov	DWORD PTR __Count$[ebp], eax

; 149  : 	_FwdIt _Result = _Dest + _Count;

	mov	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR __Dest$[ebp]
	lea	eax, DWORD PTR [edx+ecx*4]
	mov	DWORD PTR __Result$[ebp], eax

; 150  : 	if (_Count > 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN1@Uninit_cop@3

; 151  : 		_CRT_SECURE_MEMMOVE(&*_Dest, _Count * sizeof (*_First), &*_First, _Count * sizeof (*_First));	// NB: non-overlapping move

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	shl	eax, 2
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	DWORD PTR __imp__memmove_s
	add	esp, 16					; 00000010H
$LN1@Uninit_cop@3:

; 152  : 	return (_Result);

	mov	eax, DWORD PTR __Result$[ebp]

; 153  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Ptr_cat<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_cat<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z PROC ; std::_Checked_base<Json::Reader::ErrorInfo * *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z ENDP ; std::_Checked_base<Json::Reader::ErrorInfo * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z PROC ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ENDP ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z PROC ; std::_Iter_random<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ENDP ; std::_Iter_random<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z PROC ; std::_Ptr_cat<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ENDP ; std::_Ptr_cat<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z PROC ; std::_Iter_random<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ENDP ; std::_Iter_random<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z PROC ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ENDP ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z PROC ; std::_Iter_random<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ENDP ; std::_Iter_random<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z PROC ; std::_Iter_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ENDP ; std::_Iter_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z PROC ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ENDP ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z PROC ; std::_Iter_random<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ENDP ; std::_Iter_random<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??$_Iter_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z PROC ; std::_Iter_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 952  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 953  : 	typename iterator_traits<_Iter>::iterator_category _Cat;
; 954  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 955  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ENDP ; std::_Iter_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
__Cat$ = -1						; size = 1
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z PROC ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 1509 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1510 : 	typename _Ptr_cat_helper<_T1, _T2>::_Ptr_cat _Cat;
; 1511 : 	return (_Cat);

	mov	al, BYTE PTR __Cat$[ebp]

; 1512 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ENDP ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z PROC ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 993  : 	{	// return category from iterator argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 994  : 	typename _Iter_random_helper<
; 995  : 		iterator_traits<_Iter1>::iterator_category, 
; 996  : 		iterator_traits<_Iter2>::iterator_category>::_Iter_random_cat _Cat;
; 997  : 	return (_Cat);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 998  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z ENDP ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
__It$ = 8						; size = 4
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z PROC ; std::_Checked_base<Json::PathArgument *>, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@U_Unchanged_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 8

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ENDP ; std::_Checked_base<Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0bad_alloc@std@@QAE@ABV01@@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@ABV01@@Z ENDP			; std::bad_alloc::bad_alloc
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0VErrorInfo@Reader@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVValue@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Value *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVValue@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Value *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Destroy<Json::Reader::ErrorInfo *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Destroy<Json::Reader::ErrorInfo *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z PROC ; std::_Destroy<Json::Value * *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ENDP ; std::_Destroy<Json::Value * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z PROC ; std::_Destroy<Json::Value *>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);
; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ENDP ; std::_Destroy<Json::Value *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z
_TEXT	SEGMENT
$T75614 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Value * *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * * *,Json::Value * * *>
	add	esp, 8
	mov	BYTE PTR $T75614[ebp], al
	movzx	edx, BYTE PTR $T75614[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Value * *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z
_TEXT	SEGMENT
$T75618 = -2						; size = 1
$T75617 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T75617[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * * *,Json::Value * * *>
	add	esp, 8
	mov	BYTE PTR $T75618[ebp], al
	movzx	eax, BYTE PTR $T75617[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T75618[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z ; std::_Checked_base<Json::Value * * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z ; std::_Checked_base<Json::Value * * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$?0VPathArgument@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??$?0VPathArgument@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z PROC ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::PathArgument>, COMDAT
; _this$ = ecx

; 128  : 		allocator(const allocator<_Other>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 129  : 		{	// construct from a related allocator (do nothing)
; 130  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0VPathArgument@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z ENDP ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::PathArgument>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z
_TEXT	SEGMENT
$T75623 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
	add	esp, 8
	mov	BYTE PTR $T75623[ebp], al
	movzx	edx, BYTE PTR $T75623[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z
_TEXT	SEGMENT
$T75627 = -2						; size = 1
$T75626 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T75626[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
	add	esp, 8
	mov	BYTE PTR $T75627[ebp], al
	movzx	eax, BYTE PTR $T75626[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T75627[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ PROC	; std::allocator<Json::Value *>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 1073741823	; 3fffffffH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@4
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@4
$LN3@max_size@4:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@4:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ENDP	; std::allocator<Json::Value *>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::Reader::ErrorInfo>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 97612893	; 05d1745dH

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@5
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@5
$LN3@max_size@5:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@5:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::max_size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size, COMDAT
; _this$ = ecx

; 728  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 729  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size

; 730  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
tv65 = -12						; size = 4
_this$ = -8						; size = 4
__Count$ = -4						; size = 4
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::PathArgument>::max_size, COMDAT
; _this$ = ecx

; 164  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 165  : 		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);

	mov	DWORD PTR __Count$[ebp], 119304647	; 071c71c7H

; 166  : 		return (0 < _Count ? _Count : 1);

	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN3@max_size@6
	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv65[ebp], eax
	jmp	SHORT $LN4@max_size@6
$LN3@max_size@6:
	mov	DWORD PTR tv65[ebp], 1
$LN4@max_size@6:
	mov	eax, DWORD PTR tv65[ebp]

; 167  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::PathArgument>::max_size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z PROC		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 12					; 0000000cH
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax+40]
	mov	DWORD PTR [edx+40], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::deallocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty, COMDAT
; _this$ = ecx

; 733  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 734  : 		return (_Mysize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+28], 0
	sete	cl
	mov	al, cl

; 735  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$ = ecx

; 728  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 729  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size

; 730  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value * *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value * *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value * *>::destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@PAVValue@Json@@@std@@YAXPAPAVValue@Json@@@Z ; std::_Destroy<Json::Value *>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ PROC		; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ENDP		; std::allocator<Json::Value *>::allocator<Json::Value *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size, COMDAT
; _this$ = ecx

; 730  : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 		return (this->_Alval.max_size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?max_size@?$allocator@VPathArgument@Json@@@std@@QBEIXZ ; std::allocator<Json::PathArgument>::max_size

; 732  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 119  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 120  : 		{	// construct default allocator (do nothing)
; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Json::Value *>::allocator<Json::Value *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty, COMDAT
; _this$ = ecx

; 733  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 734  : 		return (_Mysize == 0);

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+28], 0
	sete	cl
	mov	al, cl

; 735  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
___formal$ = 12						; size = 4
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument>::deallocate, COMDAT
; _this$ = ecx

; 139  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 140  : 		::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 141  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::deallocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>, COMDAT
; _this$ = ecx

; 123  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 124  : 		{	// construct by copying (do nothing)
; 125  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size, COMDAT
; _this$ = ecx

; 725  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 726  : 		return (_Mylast - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+16]
	sub	eax, DWORD PTR [ecx+12]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx

; 727  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
tv70 = -8						; size = 4
_this$ = -4						; size = 4
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity, COMDAT
; _this$ = ecx

; 634  : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 635  : 		return (_Myfirst == 0 ? 0 : _Myend - _Myfirst);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	jne	SHORT $LN3@capacity@3
	mov	DWORD PTR tv70[ebp], 0
	jmp	SHORT $LN4@capacity@3
$LN3@capacity@3:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	mov	DWORD PTR tv70[ebp], eax
$LN4@capacity@3:
	mov	eax, DWORD PTR tv70[ebp]

; 636  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size, COMDAT
; _this$ = ecx

; 723  : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 724  : 		return (_Mysize);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+28]

; 725  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stack
_TEXT	ENDS
;	COMDAT ?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty, COMDAT
; _this$ = ecx

; 37   : 		{	// test if stack is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 38   : 		return (c.empty());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty

; 39   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
_TEXT	ENDS
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn
; Function compile flags: /Odtp
; File e:\newggdevelop\client\ggjsoncpp\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_c$56816 = -9						; size = 1
_lastLineStart$ = -8					; size = 4
_current$ = -4						; size = 4
_location$ = 8						; size = 4
_line$ = 12						; size = 4
_column$ = 16						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 842  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 843  :    Location current = begin_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR _current$[ebp], ecx

; 844  :    Location lastLineStart = current;

	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR _lastLineStart$[ebp], edx

; 845  :    line = 0;

	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax], 0
$LN6@getLocatio:

; 846  :    while ( current < location  &&  current != end_ )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _location$[ebp]
	jae	SHORT $LN5@getLocatio
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _current$[ebp]
	cmp	eax, DWORD PTR [edx+96]
	je	SHORT $LN5@getLocatio

; 847  :    {
; 848  :       Char c = *current++;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$56816[ebp], dl
	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax

; 849  :       if ( c == '\r' )

	movsx	ecx, BYTE PTR _c$56816[ebp]
	cmp	ecx, 13					; 0000000dH
	jne	SHORT $LN4@getLocatio

; 850  :       {
; 851  :          if ( *current == '\n' )

	mov	edx, DWORD PTR _current$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@getLocatio

; 852  :             ++current;

	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx
$LN3@getLocatio:

; 853  :          lastLineStart = current;

	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR _lastLineStart$[ebp], edx

; 854  :          ++line;

	mov	eax, DWORD PTR _line$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	mov	edx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	SHORT $LN2@getLocatio
$LN4@getLocatio:

; 855  :       }
; 856  :       else if ( c == '\n' )

	movsx	eax, BYTE PTR _c$56816[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN2@getLocatio

; 857  :       {
; 858  :          lastLineStart = current;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR _lastLineStart$[ebp], ecx

; 859  :          ++line;

	mov	edx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _line$[ebp]
	mov	DWORD PTR [ecx], eax
$LN2@getLocatio:

; 860  :       }
; 861  :    }

	jmp	SHORT $LN6@getLocatio
$LN5@getLocatio:

; 862  :    // column & line start at 1
; 863  :    column = int(location - lastLineStart) + 1;

	mov	edx, DWORD PTR _location$[ebp]
	sub	edx, DWORD PTR _lastLineStart$[ebp]
	add	edx, 1
	mov	eax, DWORD PTR _column$[ebp]
	mov	DWORD PTR [eax], edx

; 864  :    ++line;

	mov	ecx, DWORD PTR _line$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	eax, DWORD PTR _line$[ebp]
	mov	DWORD PTR [eax], edx

; 865  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
PUBLIC	?getNextChar@Reader@Json@@AAEDXZ		; Json::Reader::getNextChar
; Function compile flags: /Odtp
;	COMDAT ?getNextChar@Reader@Json@@AAEDXZ
_TEXT	SEGMENT
tv72 = -5						; size = 1
_this$ = -4						; size = 4
?getNextChar@Reader@Json@@AAEDXZ PROC			; Json::Reader::getNextChar, COMDAT
; _this$ = ecx

; 831  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 832  :    if ( current_ == end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	cmp	edx, DWORD PTR [ecx+96]
	jne	SHORT $LN1@getNextCha

; 833  :       return 0;

	xor	al, al
	jmp	SHORT $LN2@getNextCha
$LN1@getNextCha:

; 834  :    return *current_++;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR tv72[ebp], dl
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], ecx
	mov	al, BYTE PTR tv72[ebp]
$LN2@getNextCha:

; 835  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?getNextChar@Reader@Json@@AAEDXZ ENDP			; Json::Reader::getNextChar
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::~ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::~ErrorInfo
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
PUBLIC	?readString@Reader@Json@@AAE_NXZ		; Json::Reader::readString
; Function compile flags: /Odtp
;	COMDAT ?readString@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$ = -1						; size = 1
?readString@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readString, COMDAT
; _this$ = ecx

; 456  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 457  :    Char c = 0;

	mov	BYTE PTR _c$[ebp], 0
$LN5@readString:

; 458  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	cmp	edx, DWORD PTR [ecx+96]
	je	SHORT $LN4@readString

; 459  :    {
; 460  :       c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$[ebp], al

; 461  :       if ( c == '\\' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN3@readString

; 462  :          getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	jmp	SHORT $LN2@readString
$LN3@readString:

; 463  :       else if ( c == '"' )

	movsx	ecx, BYTE PTR _c$[ebp]
	cmp	ecx, 34					; 00000022H
	jne	SHORT $LN2@readString

; 464  :          break;

	jmp	SHORT $LN4@readString
$LN2@readString:

; 465  :    }

	jmp	SHORT $LN5@readString
$LN4@readString:

; 466  :    return c == '"';

	movsx	edx, BYTE PTR _c$[ebp]
	xor	eax, eax
	cmp	edx, 34					; 00000022H
	sete	al

; 467  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readString@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readString
_TEXT	ENDS
PUBLIC	?readCppStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCppStyleComment
; Function compile flags: /Odtp
;	COMDAT ?readCppStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$56520 = -1						; size = 1
?readCppStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCppStyleComment, COMDAT
; _this$ = ecx

; 431  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$LN4@readCppSty:

; 432  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	cmp	edx, DWORD PTR [ecx+96]
	je	SHORT $LN3@readCppSty

; 433  :    {
; 434  :       Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$56520[ebp], al

; 435  :       if (  c == '\r'  ||  c == '\n' )

	movsx	eax, BYTE PTR _c$56520[ebp]
	cmp	eax, 13					; 0000000dH
	je	SHORT $LN1@readCppSty
	movsx	ecx, BYTE PTR _c$56520[ebp]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN2@readCppSty
$LN1@readCppSty:

; 436  :          break;

	jmp	SHORT $LN3@readCppSty
$LN2@readCppSty:

; 437  :    }

	jmp	SHORT $LN4@readCppSty
$LN3@readCppSty:

; 438  :    return true;

	mov	al, 1

; 439  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readCppStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCppStyleComment
_TEXT	ENDS
PUBLIC	?readCStyleComment@Reader@Json@@AAE_NXZ		; Json::Reader::readCStyleComment
; Function compile flags: /Odtp
;	COMDAT ?readCStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$56512 = -1						; size = 1
?readCStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCStyleComment, COMDAT
; _this$ = ecx

; 418  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$LN3@readCStyle:

; 419  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	cmp	edx, DWORD PTR [ecx+96]
	je	SHORT $LN2@readCStyle

; 420  :    {
; 421  :       Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$56512[ebp], al

; 422  :       if ( c == '*'  &&  *current_ == '/' )

	movsx	eax, BYTE PTR _c$56512[ebp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN1@readCStyle
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN1@readCStyle

; 423  :          break;

	jmp	SHORT $LN2@readCStyle
$LN1@readCStyle:

; 424  :    }

	jmp	SHORT $LN3@readCStyle
$LN2@readCStyle:

; 425  :    return getNextChar() == '/';

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	movsx	ecx, al
	xor	eax, eax
	cmp	ecx, 47					; 0000002fH
	sete	al

; 426  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readCStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCStyleComment
_TEXT	ENDS
PUBLIC	?match@Reader@Json@@AAE_NPBDH@Z			; Json::Reader::match
; Function compile flags: /Odtp
;	COMDAT ?match@Reader@Json@@AAE_NPBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_index$ = -4						; size = 4
_pattern$ = 8						; size = 4
_patternLength$ = 12					; size = 4
?match@Reader@Json@@AAE_NPBDH@Z PROC			; Json::Reader::match, COMDAT
; _this$ = ecx

; 356  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 357  :    if ( end_ - current_ < patternLength )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+96]
	sub	edx, DWORD PTR [ecx+100]
	cmp	edx, DWORD PTR _patternLength$[ebp]
	jge	SHORT $LN4@match

; 358  :       return false;

	xor	al, al
	jmp	SHORT $LN5@match
$LN4@match:

; 359  :    int index = patternLength;

	mov	eax, DWORD PTR _patternLength$[ebp]
	mov	DWORD PTR _index$[ebp], eax
$LN3@match:

; 360  :    while ( index-- )

	mov	ecx, DWORD PTR _index$[ebp]
	mov	edx, DWORD PTR _index$[ebp]
	sub	edx, 1
	mov	DWORD PTR _index$[ebp], edx
	test	ecx, ecx
	je	SHORT $LN2@match

; 361  :       if ( current_[index] != pattern[index] )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	edx, DWORD PTR _index$[ebp]
	movsx	eax, BYTE PTR [ecx+edx]
	mov	ecx, DWORD PTR _pattern$[ebp]
	add	ecx, DWORD PTR _index$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	eax, edx
	je	SHORT $LN1@match

; 362  :          return false;

	xor	al, al
	jmp	SHORT $LN5@match
$LN1@match:

; 363  :    current_ += patternLength;

	jmp	SHORT $LN3@match
$LN2@match:
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	add	ecx, DWORD PTR _patternLength$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], ecx

; 364  :    return true;

	mov	al, 1
$LN5@match:

; 365  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?match@Reader@Json@@AAE_NPBDH@Z ENDP			; Json::Reader::match
_TEXT	ENDS
PUBLIC	?skipSpaces@Reader@Json@@AAEXXZ			; Json::Reader::skipSpaces
; Function compile flags: /Odtp
;	COMDAT ?skipSpaces@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_c$56368 = -1						; size = 1
?skipSpaces@Reader@Json@@AAEXXZ PROC			; Json::Reader::skipSpaces, COMDAT
; _this$ = ecx

; 341  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$LN5@skipSpaces:

; 342  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	cmp	edx, DWORD PTR [ecx+96]
	je	SHORT $LN6@skipSpaces

; 343  :    {
; 344  :       Char c = *current_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$56368[ebp], dl

; 345  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	movsx	eax, BYTE PTR _c$56368[ebp]
	cmp	eax, 32					; 00000020H
	je	SHORT $LN2@skipSpaces
	movsx	ecx, BYTE PTR _c$56368[ebp]
	cmp	ecx, 9
	je	SHORT $LN2@skipSpaces
	movsx	edx, BYTE PTR _c$56368[ebp]
	cmp	edx, 13					; 0000000dH
	je	SHORT $LN2@skipSpaces
	movsx	eax, BYTE PTR _c$56368[ebp]
	cmp	eax, 10					; 0000000aH
	jne	SHORT $LN3@skipSpaces
$LN2@skipSpaces:

; 346  :          ++current_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], edx

; 347  :       else

	jmp	SHORT $LN1@skipSpaces
$LN3@skipSpaces:

; 348  :          break;

	jmp	SHORT $LN6@skipSpaces
$LN1@skipSpaces:

; 349  :    }

	jmp	SHORT $LN5@skipSpaces
$LN6@skipSpaces:

; 350  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?skipSpaces@Reader@Json@@AAEXXZ ENDP			; Json::Reader::skipSpaces
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?containsNewLine@Json@@YA_NPBD0@Z
_TEXT	SEGMENT
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
?containsNewLine@Json@@YA_NPBD0@Z PROC			; Json::containsNewLine, COMDAT

; 71   : {

	push	ebp
	mov	ebp, esp

; 72   :    for ( ;begin < end; ++begin )

	jmp	SHORT $LN5@containsNe
$LN4@containsNe:
	mov	eax, DWORD PTR _begin$[ebp]
	add	eax, 1
	mov	DWORD PTR _begin$[ebp], eax
$LN5@containsNe:
	mov	ecx, DWORD PTR _begin$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jae	SHORT $LN3@containsNe

; 73   :       if ( *begin == '\n'  ||  *begin == '\r' )

	mov	edx, DWORD PTR _begin$[ebp]
	movsx	eax, BYTE PTR [edx]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN1@containsNe
	mov	ecx, DWORD PTR _begin$[ebp]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN2@containsNe
$LN1@containsNe:

; 74   :          return true;

	mov	al, 1
	jmp	SHORT $LN6@containsNe
$LN2@containsNe:

; 75   :    return false;

	jmp	SHORT $LN4@containsNe
$LN3@containsNe:
	xor	al, al
$LN6@containsNe:

; 76   : }

	pop	ebp
	ret	0
?containsNewLine@Json@@YA_NPBD0@Z ENDP			; Json::containsNewLine
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDDD@Z
_TEXT	SEGMENT
tv79 = -4						; size = 4
_c$ = 8							; size = 1
_c1$ = 12						; size = 1
_c2$ = 16						; size = 1
_c3$ = 20						; size = 1
_c4$ = 24						; size = 1
_c5$ = 28						; size = 1
?in@Json@@YA_NDDDDDD@Z PROC				; Json::in, COMDAT

; 63   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 64   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c1$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in
	movsx	edx, BYTE PTR _c$[ebp]
	movsx	eax, BYTE PTR _c2$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@in
	movsx	ecx, BYTE PTR _c$[ebp]
	movsx	edx, BYTE PTR _c3$[ebp]
	cmp	ecx, edx
	je	SHORT $LN3@in
	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c4$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in
	movsx	edx, BYTE PTR _c$[ebp]
	movsx	eax, BYTE PTR _c5$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@in
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN4@in
$LN3@in:
	mov	DWORD PTR tv79[ebp], 1
$LN4@in:
	mov	al, BYTE PTR tv79[ebp]

; 65   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?in@Json@@YA_NDDDDDD@Z ENDP				; Json::in
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?in@Json@@YA_NDDDDD@Z
_TEXT	SEGMENT
tv76 = -4						; size = 4
_c$ = 8							; size = 1
_c1$ = 12						; size = 1
_c2$ = 16						; size = 1
_c3$ = 20						; size = 1
_c4$ = 24						; size = 1
?in@Json@@YA_NDDDDD@Z PROC				; Json::in, COMDAT

; 57   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 58   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c1$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in@2
	movsx	edx, BYTE PTR _c$[ebp]
	movsx	eax, BYTE PTR _c2$[ebp]
	cmp	edx, eax
	je	SHORT $LN3@in@2
	movsx	ecx, BYTE PTR _c$[ebp]
	movsx	edx, BYTE PTR _c3$[ebp]
	cmp	ecx, edx
	je	SHORT $LN3@in@2
	movsx	eax, BYTE PTR _c$[ebp]
	movsx	ecx, BYTE PTR _c4$[ebp]
	cmp	eax, ecx
	je	SHORT $LN3@in@2
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@in@2
$LN3@in@2:
	mov	DWORD PTR tv76[ebp], 1
$LN4@in@2:
	mov	al, BYTE PTR tv76[ebp]

; 59   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?in@Json@@YA_NDDDDD@Z ENDP				; Json::in
_TEXT	ENDS
PUBLIC	??0Features@Json@@QAE@XZ			; Json::Features::Features
; Function compile flags: /Odtp
;	COMDAT ??0Features@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0Features@Json@@QAE@XZ PROC				; Json::Features::Features, COMDAT
; _this$ = ecx

; 31   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax], 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+1], 0

; 32   : }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0Features@Json@@QAE@XZ ENDP				; Json::Features::Features
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File e:\newggdevelop\client\ggjsoncpp\json_tool.h
xdata$x	SEGMENT
__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0
__ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T75728 = -48						; size = 4
_result$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_cp$ = 12						; size = 4
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::codePointToUTF8, COMDAT

; 20   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T75728[ebp], 0

; 21   :    std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 22   :    
; 23   :    // based on description from http://en.wikipedia.org/wiki/UTF-8
; 24   : 
; 25   :    if (cp <= 0x7f) 

	cmp	DWORD PTR _cp$[ebp], 127		; 0000007fH
	ja	SHORT $LN7@codePointT

; 26   :    {
; 27   :       result.resize(1);

	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 28   :       result[0] = static_cast<char>(cp);

	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	cl, BYTE PTR _cp$[ebp]
	mov	BYTE PTR [eax], cl
	jmp	$LN6@codePointT
$LN7@codePointT:

; 29   :    } 
; 30   :    else if (cp <= 0x7FF) 

	cmp	DWORD PTR _cp$[ebp], 2047		; 000007ffH
	ja	SHORT $LN5@codePointT

; 31   :    {
; 32   :       result.resize(2);

	push	2
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 33   :       result[1] = static_cast<char>(0x80 | (0x3f & cp));

	mov	ebx, DWORD PTR _cp$[ebp]
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl

; 34   :       result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 6
	and	ebx, 31					; 0000001fH
	or	ebx, 192				; 000000c0H
	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl
	jmp	$LN6@codePointT
$LN5@codePointT:

; 35   :    } 
; 36   :    else if (cp <= 0xFFFF) 

	cmp	DWORD PTR _cp$[ebp], 65535		; 0000ffffH
	ja	SHORT $LN3@codePointT

; 37   :    {
; 38   :       result.resize(3);

	push	3
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 39   :       result[2] = static_cast<char>(0x80 | (0x3f & cp));

	mov	ebx, DWORD PTR _cp$[ebp]
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	2
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl

; 40   :       result[1] = 0x80 | static_cast<char>((0x3f & (cp >> 6)));

	mov	edx, DWORD PTR _cp$[ebp]
	shr	edx, 6
	and	edx, 63					; 0000003fH
	movsx	ebx, dl
	or	ebx, 128				; 00000080H
	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl

; 41   :       result[0] = 0xE0 | static_cast<char>((0xf & (cp >> 12)));

	mov	eax, DWORD PTR _cp$[ebp]
	shr	eax, 12					; 0000000cH
	and	eax, 15					; 0000000fH
	movsx	ebx, al
	or	ebx, 224				; 000000e0H
	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl
	jmp	$LN6@codePointT
$LN3@codePointT:

; 42   :    }
; 43   :    else if (cp <= 0x10FFFF) 

	cmp	DWORD PTR _cp$[ebp], 1114111		; 0010ffffH
	ja	SHORT $LN6@codePointT

; 44   :    {
; 45   :       result.resize(4);

	push	4
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 46   :       result[3] = static_cast<char>(0x80 | (0x3f & cp));

	mov	ebx, DWORD PTR _cp$[ebp]
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	3
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl

; 47   :       result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 6
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	2
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl

; 48   :       result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 12					; 0000000cH
	and	ebx, 63					; 0000003fH
	or	ebx, 128				; 00000080H
	push	1
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl

; 49   :       result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));

	mov	ebx, DWORD PTR _cp$[ebp]
	shr	ebx, 18					; 00000012H
	and	ebx, 7
	or	ebx, 240				; 000000f0H
	push	0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	BYTE PTR [eax], bl
$LN6@codePointT:

; 50   :    }
; 51   : 
; 52   :    return result;

	lea	ecx, DWORD PTR _result$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T75728[ebp]
	or	edx, 1
	mov	DWORD PTR $T75728[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 53   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$1:
	mov	eax, DWORD PTR $T75728[ebp]
	and	eax, 1
	je	$LN12@codePointT
	and	DWORD PTR $T75728[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN12@codePointT:
	ret	0
__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::codePointToUTF8
PUBLIC	??4ValueConstIterator@Json@@QAEAAV01@ABV01@@Z	; Json::ValueConstIterator::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ValueConstIterator@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ValueConstIterator@Json@@QAEAAV01@ABV01@@Z PROC	; Json::ValueConstIterator::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ValueConstIterator@Json@@QAEAAV01@ABV01@@Z ENDP	; Json::ValueConstIterator::operator=
_TEXT	ENDS
PUBLIC	??4ValueIteratorBase@Json@@QAEAAV01@ABV01@@Z	; Json::ValueIteratorBase::operator=
; Function compile flags: /Odtp
;	COMDAT ??4ValueIteratorBase@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4ValueIteratorBase@Json@@QAEAAV01@ABV01@@Z PROC	; Json::ValueIteratorBase::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR [ecx+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4ValueIteratorBase@Json@@QAEAAV01@ABV01@@Z ENDP	; Json::ValueIteratorBase::operator=
_TEXT	ENDS
PUBLIC	??4PathArgument@Json@@QAEAAV01@ABV01@@Z		; Json::PathArgument::operator=
; Function compile flags: /Odtp
;	COMDAT ??4PathArgument@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4PathArgument@Json@@QAEAAV01@ABV01@@Z PROC		; Json::PathArgument::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4PathArgument@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::PathArgument::operator=
_TEXT	ENDS
PUBLIC	??0PathArgument@Json@@QAE@ABV01@@Z		; Json::PathArgument::PathArgument
; Function compile flags: /Odtp
;	COMDAT ??0PathArgument@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0PathArgument@Json@@QAE@ABV01@@Z PROC			; Json::PathArgument::PathArgument, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+28]
	mov	DWORD PTR [ecx+28], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0PathArgument@Json@@QAE@ABV01@@Z ENDP			; Json::PathArgument::PathArgument
_TEXT	ENDS
PUBLIC	??1PathArgument@Json@@QAE@XZ			; Json::PathArgument::~PathArgument
; Function compile flags: /Odtp
;	COMDAT ??1PathArgument@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1PathArgument@Json@@QAE@XZ PROC			; Json::PathArgument::~PathArgument, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1PathArgument@Json@@QAE@XZ ENDP			; Json::PathArgument::~PathArgument
_TEXT	ENDS
PUBLIC	??4StaticString@Json@@QAEAAV01@ABV01@@Z		; Json::StaticString::operator=
; Function compile flags: /Odtp
;	COMDAT ??4StaticString@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4StaticString@Json@@QAEAAV01@ABV01@@Z PROC		; Json::StaticString::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4StaticString@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::StaticString::operator=
_TEXT	ENDS
PUBLIC	?c_str@StaticString@Json@@QBEPBDXZ		; Json::StaticString::c_str
; Function compile flags: /Odtp
; File e:\newggdevelop\client\include\json\value.h
;	COMDAT ?c_str@StaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?c_str@StaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::c_str, COMDAT
; _this$ = ecx

; 90   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 91   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 92   :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?c_str@StaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::c_str
_TEXT	ENDS
PUBLIC	??BStaticString@Json@@QBEPBDXZ			; Json::StaticString::operator char const *
; Function compile flags: /Odtp
;	COMDAT ??BStaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??BStaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::operator char const *, COMDAT
; _this$ = ecx

; 85   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 86   :          return str_;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 87   :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??BStaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::operator char const *
_TEXT	ENDS
PUBLIC	??0StaticString@Json@@QAE@PBD@Z			; Json::StaticString::StaticString
; Function compile flags: /Odtp
;	COMDAT ??0StaticString@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_czstring$ = 8						; size = 4
??0StaticString@Json@@QAE@PBD@Z PROC			; Json::StaticString::StaticString, COMDAT
; _this$ = ecx

; 81   :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _czstring$[ebp]
	mov	DWORD PTR [eax], ecx

; 82   :       }

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0StaticString@Json@@QAE@PBD@Z ENDP			; Json::StaticString::StaticString
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0logic_error@std@@QAE@ABV01@@Z PROC			; std::logic_error::logic_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7logic_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV01@@Z ENDP			; std::logic_error::logic_error
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7runtime_error@std@@6B@
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0runtime_error@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
;	COMDAT ?what@runtime_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@runtime_error@std@@UBEPBDXZ PROC			; std::runtime_error::what, COMDAT
; _this$ = ecx

; 161  : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 162  : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 163  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@runtime_error@std@@UBEPBDXZ ENDP			; std::runtime_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 157  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@

; 158  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx

; 153  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7runtime_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 154  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
; Function compile flags: /Odtp
;	COMDAT ?what@logic_error@std@@UBEPBDXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?what@logic_error@std@@UBEPBDXZ PROC			; std::logic_error::what, COMDAT
; _this$ = ecx

; 34   : 		{	// return pointer to message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 35   : 		return (_Str.c_str());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ

; 36   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?what@logic_error@std@@UBEPBDXZ ENDP			; std::logic_error::what
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1logic_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1logic_error@std@@UAE@XZ PROC				; std::logic_error::~logic_error, COMDAT
; _this$ = ecx

; 30   : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@

; 31   : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1logic_error@std@@UAE@XZ ENDP				; std::logic_error::~logic_error
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0
__ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Message$ = 8						; size = 4
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::logic_error::logic_error, COMDAT
; _this$ = ecx

; 26   : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7logic_error@std@@6B@
	mov	ecx, DWORD PTR __Message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z

; 27   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1exception@std@@UAE@XZ
__ehhandler$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::logic_error::logic_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ?_Has_container@_Iterator_base_aux@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ PROC	; std::_Iterator_base_aux::_Has_container, COMDAT
; _this$ = ecx

; 467  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 468  : 		return _Myaux != 0;

	mov	eax, DWORD PTR _this$[ebp]
	xor	ecx, ecx
	cmp	DWORD PTR [eax], 0
	setne	cl
	mov	al, cl

; 469  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ENDP	; std::_Iterator_base_aux::_Has_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Other$ = 8						; size = 4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z PROC ; std::_Iterator_base_aux::_Same_container, COMDAT
; _this$ = ecx

; 462  : 		{	// Accelerate the comparison by not going through the aux object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 463  : 		return _Myaux == _Other._Myaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Other$[ebp]
	mov	edx, DWORD PTR [eax]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx]
	sete	al

; 464  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ENDP ; std::_Iterator_base_aux::_Same_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z PROC ; std::_Iterator_base_aux::_Set_container, COMDAT
; _this$ = ecx

; 452  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 453  : 		_Myaux = _Pcont->_Myownedaux;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx

; 454  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ENDP ; std::_Iterator_base_aux::_Set_container
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Iterator_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Iterator_base_aux@std@@QAE@XZ PROC			; std::_Iterator_base_aux::_Iterator_base_aux, COMDAT
; _this$ = ecx

; 448  : 	_Iterator_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base_aux@std@@QAE@XZ ENDP			; std::_Iterator_base_aux::_Iterator_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::~_Container_base_aux, COMDAT
; _this$ = ecx

; 402  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 403  : 		// Do nothing: ~_Container_base_aux_alloc_real() previously destroyed the aux object.
; 404  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::~_Container_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Container_base_aux@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0_Container_base_aux@std@@QAE@XZ PROC			; std::_Container_base_aux::_Container_base_aux, COMDAT
; _this$ = ecx

; 379  : 	_Container_base_aux()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 380  : 		{
; 381  : 		// Do nothing: _Container_base_aux_alloc_real() will construct the aux object.
; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base_aux@std@@QAE@XZ ENDP			; std::_Container_base_aux::_Container_base_aux
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Aux_cont::_Getcont, COMDAT
; _this$ = ecx

; 368  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 369  : 		return _Mycontainer;

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax]

; 370  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Aux_cont::_Getcont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pcont$ = 8						; size = 4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z PROC	; std::_Aux_cont::_Aux_cont, COMDAT
; _this$ = ecx

; 364  : 	explicit _Aux_cont(const _Container_base_aux * const _Pcont)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Pcont$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ENDP	; std::_Aux_cont::_Aux_cont
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\new
_TEXT	ENDS
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??3@YAXPAX0@Z PROC					; operator delete, COMDAT

; 63   : 	{	// delete if placement new fails

	push	ebp
	mov	ebp, esp

; 64   : 	}

	pop	ebp
	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 58   : 	{	// construct array with placement at _Where

	push	ebp
	mov	ebp, esp

; 59   : 	return (_Where);

	mov	eax, DWORD PTR __Where$[ebp]

; 60   : 	}

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\exception
_TEXT	ENDS
;	COMDAT ??1bad_alloc@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1bad_alloc@std@@UAE@XZ PROC				; std::bad_alloc::~bad_alloc, COMDAT
; _this$ = ecx

; 380  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7bad_alloc@std@@6B@

; 381  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??1exception@std@@UAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1bad_alloc@std@@UAE@XZ ENDP				; std::bad_alloc::~bad_alloc
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0bad_alloc@std@@QAE@PBD@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0bad_alloc@std@@QAE@PBD@Z PROC			; std::bad_alloc::bad_alloc, COMDAT
; _this$ = ecx

; 371  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	DWORD PTR __imp_??0exception@std@@QAE@ABQBD@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7bad_alloc@std@@6B@

; 372  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0bad_alloc@std@@QAE@PBD@Z ENDP			; std::bad_alloc::bad_alloc
_TEXT	ENDS
PUBLIC	??4Features@Json@@QAEAAV01@ABV01@@Z		; Json::Features::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Features@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Features@Json@@QAEAAV01@ABV01@@Z PROC		; Json::Features::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	mov	cx, WORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	WORD PTR [edx], cx
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Features@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::Features::operator=
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
xdata$x	SEGMENT
__unwindtable$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z$0
__ehfuncinfo$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T76450 = -24						; size = 4
$T76449 = -20						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z PROC ; std::_Construct<Json::PathArgument,Json::PathArgument>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	36					; 00000024H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T76450[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T76450[ebp], 0
	je	SHORT $LN3@Construct@3
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T76450[ebp]
	call	??0PathArgument@Json@@QAE@ABV01@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Construct@3
$LN3@Construct@3:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Construct@3:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T76449[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T76450[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ENDP ; std::_Construct<Json::PathArgument,Json::PathArgument>
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
xdata$x	SEGMENT
__unwindtable$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$0
__ehfuncinfo$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Tmp$64846 = -60					; size = 44
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z PROC ; std::swap<Json::Reader::ErrorInfo>, COMDAT

; 17   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 18   : 	if (&_Left != &_Right)

	mov	eax, DWORD PTR __Left$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	SHORT $LN2@swap@4

; 19   : 		{	// different, worth swapping
; 20   : 		_Ty _Tmp = _Left;

	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Tmp$64846[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 21   : 
; 22   : 		_Left = _Right;

	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Left$[ebp]
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z

; 23   : 		_Right = _Tmp;

	lea	eax, DWORD PTR __Tmp$64846[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z

; 24   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Tmp$64846[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
$LN2@swap@4:

; 25   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$0:
	lea	ecx, DWORD PTR __Tmp$64846[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ENDP ; std::swap<Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T76472 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T76472[ebp], al
	movzx	ecx, BYTE PTR $T76472[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAPAV12@@Z ; std::_Checked_base<Json::Value * * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T76475 = -5						; size = 1
__Last$ = -4						; size = 4
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT

; 3250 : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 3251 : 		// if _OutIt is checked, this will ensure we have enough space
; 3252 : 		_OutIt _Last = _First + _Count; (_Last);

	mov	eax, DWORD PTR __Count$[ebp]
	mov	ecx, DWORD PTR __First$[ebp]
	lea	edx, DWORD PTR [ecx+eax*4]
	mov	DWORD PTR __Last$[ebp], edx

; 3253 : 		_Fill_n(_CHECKED_BASE(_First), _Count, _Val,
; 3254 : 			_Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T76475[ebp], al
	movzx	ecx, BYTE PTR $T76475[ebp]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Checked_base@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@@Z ; std::_Checked_base<Json::Reader::ErrorInfo * *>
	add	esp, 4
	push	eax
	call	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
	add	esp, 16					; 00000010H

; 3255 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator==, COMDAT
; _this$ = ecx

; 243  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 
; 245  :  #if _HAS_ITERATOR_DEBUGGING
; 246  : 		_Compat(_Right);
; 247  : 		return (_Myoff == _Right._Myoff);
; 248  : 		}
; 249  : 
; 250  :  #elif _SECURE_SCL
; 251  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	xor	eax, eax
	je	SHORT $LN3@operator@13
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@13
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@13
$LN1@operator@13:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@13:

; 252  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator!=, COMDAT
; _this$ = ecx

; 261  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 263  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator!=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z PROC ; std::allocator<Json::PathArgument>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@VPathArgument@Json@@V12@@std@@YAXPAVPathArgument@Json@@ABV12@@Z ; std::_Construct<Json::PathArgument,Json::PathArgument>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ENDP ; std::allocator<Json::PathArgument>::construct
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GPathArgument@Json@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GPathArgument@Json@@QAEPAXI@Z PROC			; Json::PathArgument::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1PathArgument@Json@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@5
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@5:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GPathArgument@Json@@QAEPAXI@Z ENDP			; Json::PathArgument::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\utility
_TEXT	ENDS
;	COMDAT ??$_Swap_adl@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Swap_adl@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Swap_adl<Json::Reader::ErrorInfo>, COMDAT

; 30   : 	{	// exchange values stored at _Left and _Right, using ADL

	push	ebp
	mov	ebp, esp

; 31   : 	swap(_Left, _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Left$[ebp]
	push	ecx
	call	??$swap@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::swap<Json::Reader::ErrorInfo>
	add	esp, 8

; 32   : 	}

	pop	ebp
	ret	0
??$_Swap_adl@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Swap_adl<Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z PROC ; std::_Destroy<Json::PathArgument>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_GPathArgument@Json@@QAEPAXI@Z

; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ENDP ; std::_Destroy<Json::PathArgument>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAPAVValue@Json@@IPAPAV12@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z
_TEXT	SEGMENT
$T76491 = -2						; size = 1
$T76490 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAPAVValue@Json@@IPAPAV12@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z PROC ; stdext::unchecked_fill_n<Json::Value * * *,unsigned int,Json::Value * *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T76490[ebp], al
	movzx	ecx, BYTE PTR $T76490[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T76491[ebp]
	push	eax
	call	??$_Iter_cat@PAPAPAVValue@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAPAVValue@Json@@@Z ; std::_Iter_cat<Json::Value * * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAPAVValue@Json@@IPAPAV12@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Value * * *,unsigned int,Json::Value * *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAPAVValue@Json@@IPAPAV12@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ENDP ; stdext::unchecked_fill_n<Json::Value * * *,unsigned int,Json::Value * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z
_TEXT	SEGMENT
$T76495 = -2						; size = 1
$T76494 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
??$unchecked_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z PROC ; stdext::unchecked_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>, COMDAT

; 3720 : 	{	// copy _Val _Count times through [_First, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3721 : 		_STD _Fill_n(_First, _Count, _Val, _STD _Iter_cat(_First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T76494[ebp], al
	movzx	ecx, BYTE PTR $T76494[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	lea	eax, DWORD PTR $T76495[ebp]
	push	eax
	call	??$_Iter_cat@PAPAVErrorInfo@Reader@Json@@@std@@YA?AUrandom_access_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@@Z ; std::_Iter_cat<Json::Reader::ErrorInfo * *>
	add	esp, 8
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@Urandom_access_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
	add	esp, 20					; 00000014H

; 3722 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ENDP ; stdext::unchecked_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@2
$LN2@Copy_opt@2:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Copy_opt@2:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN1@Copy_opt@2

; 2472 : 		*_Dest = *_First;

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	call	??4PathArgument@Json@@QAEAAV01@ABV01@@Z
	jmp	SHORT $LN2@Copy_opt@2
$LN1@Copy_opt@2:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator==, COMDAT
; _this$ = ecx

; 243  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 
; 245  :  #if _HAS_ITERATOR_DEBUGGING
; 246  : 		_Compat(_Right);
; 247  : 		return (_Myoff == _Right._Myoff);
; 248  : 		}
; 249  : 
; 250  :  #elif _SECURE_SCL
; 251  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	xor	eax, eax
	je	SHORT $LN3@operator@14
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@14
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@14
$LN1@operator@14:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@14:

; 252  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=, COMDAT
; _this$ = ecx

; 261  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 263  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv128 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-, COMDAT
; _this$ = ecx

; 225  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 
; 227  :  #if _HAS_ITERATOR_DEBUGGING
; 228  : 		_Compat(_Right);
; 229  :  #else
; 230  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	xor	eax, eax
	je	SHORT $LN3@operator@15
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@15
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@15
$LN1@operator@15:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@15:

; 231  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 232  : 
; 233  : 		return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
; 234  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	ja	SHORT $LN6@operator@15
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN7@operator@15
$LN6@operator@15:
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	neg	eax
	mov	DWORD PTR tv128[ebp], eax
$LN7@operator@15:
	mov	eax, DWORD PTR tv128[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv128 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-, COMDAT
; _this$ = ecx

; 225  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 
; 227  :  #if _HAS_ITERATOR_DEBUGGING
; 228  : 		_Compat(_Right);
; 229  :  #else
; 230  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	xor	eax, eax
	je	SHORT $LN3@operator@16
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@16
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@16
$LN1@operator@16:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@16:

; 231  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 232  : 
; 233  : 		return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
; 234  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	ja	SHORT $LN6@operator@16
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN7@operator@16
$LN6@operator@16:
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	neg	eax
	mov	DWORD PTR tv128[ebp], eax
$LN7@operator@16:
	mov	eax, DWORD PTR tv128[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator==, COMDAT
; _this$ = ecx

; 243  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 
; 245  :  #if _HAS_ITERATOR_DEBUGGING
; 246  : 		_Compat(_Right);
; 247  : 		return (_Myoff == _Right._Myoff);
; 248  : 		}
; 249  : 
; 250  :  #elif _SECURE_SCL
; 251  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@operator@17
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@17
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@17
$LN1@operator@17:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@17:

; 252  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator==
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z PROC ; std::allocator<Json::PathArgument>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@VPathArgument@Json@@@std@@YAXPAVPathArgument@Json@@@Z ; std::_Destroy<Json::PathArgument>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ENDP ; std::allocator<Json::PathArgument>::destroy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAPAVValue@Json@@IPAPAV12@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@@Z ; stdext::unchecked_fill_n<Json::Value * * *,unsigned int,Json::Value * *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Uninit_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 418  : 	{	// copy _Count *_Val to raw _First, using _Al, scalar type

	push	ebp
	mov	ebp, esp

; 419  : 		_STDEXT unchecked_fill_n(_First, _Count, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@@Z ; stdext::unchecked_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *>
	add	esp, 12					; 0000000cH

; 420  : 	}

	pop	ebp
	ret	0
??$_Uninit_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::PathArgument> >, COMDAT

; 232  : 	{	// destroy [_First, _Last), arbitrary type

	push	ebp
	mov	ebp, esp

; 233  : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Destroy_ra@2
$LN2@Destroy_ra@2:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], eax
$LN3@Destroy_ra@2:
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Destroy_ra@2

; 234  : 		_Al.destroy(_First);

	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
	jmp	SHORT $LN2@Destroy_ra@2
$LN4@Destroy_ra@2:

; 235  : 	}

	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T76524 = -7						; size = 1
$T76523 = -6						; size = 1
$T76522 = -5						; size = 1
__Result$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Copy_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, DWORD PTR __First$[ebp]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	imul	eax, 36					; 00000024H
	add	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Result$[ebp], eax

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T76522[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T76523[ebp], al
	movzx	ecx, BYTE PTR $T76522[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T76523[ebp]
	push	edx
	movzx	eax, BYTE PTR $T76524[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Copy_opt@PAVPathArgument@Json@@PAV12@Uforward_iterator_tag@std@@@std@@YAPAVPathArgument@Json@@PAV12@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *,std::forward_iterator_tag>
	add	esp, 24					; 00000018H

; 2486 : 	return _Result;

	mov	eax, DWORD PTR __Result$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z PROC		; Json::Reader::ErrorInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@6
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@6:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z ENDP		; Json::Reader::ErrorInfo::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Destroy<Json::Reader::ErrorInfo>, COMDAT

; 58   : 	{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp

; 59   : 	_DESTRUCTOR(_Ty, _Ptr);

	push	0
	mov	ecx, DWORD PTR __Ptr$[ebp]
	call	??_GErrorInfo@Reader@Json@@QAEPAXI@Z

; 60   : 	}

	pop	ebp
	ret	0
??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Destroy<Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z
_TEXT	SEGMENT
$T76531 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z PROC ; std::_Allocate<Json::Value * *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@4

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@4
$LN3@Allocate@4:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@4

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T76531[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T76531[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@4:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@4:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ENDP ; std::_Allocate<Json::Value * *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z
_TEXT	SEGMENT
$T76534 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z PROC ; std::_Allocate<std::_Aux_cont>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@5

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@5
$LN3@Allocate@5:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@5

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T76534[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T76534[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@5:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@5:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ENDP ; std::_Allocate<std::_Aux_cont>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z
_TEXT	SEGMENT
$T76537 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@6

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@6
$LN3@Allocate@6:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@6

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T76537[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T76537[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@6:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@6:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z
_TEXT	SEGMENT
tv68 = -12						; size = 4
$T76540 = -8						; size = 4
__Vptr$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z PROC ; std::_Construct<Json::Value *,Json::Value *>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T76540[ebp], eax
	cmp	DWORD PTR $T76540[ebp], 0
	je	SHORT $LN3@Construct@4
	mov	edx, DWORD PTR $T76540[ebp]
	mov	eax, DWORD PTR __Val$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [edx], ecx
	mov	edx, DWORD PTR $T76540[ebp]
	mov	DWORD PTR tv68[ebp], edx
	jmp	SHORT $LN1@Construct@4
$LN3@Construct@4:
	mov	DWORD PTR tv68[ebp], 0
$LN1@Construct@4:

; 53   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z ENDP ; std::_Construct<Json::Value *,Json::Value *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z
_TEXT	SEGMENT
$T76545 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z PROC ; std::_Allocate<Json::Value *>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@7

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@7
$LN3@Allocate@7:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 4
	jae	SHORT $LN2@Allocate@7

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T76545[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T76545[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@7:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	shl	ecx, 2
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@7:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ENDP ; std::_Allocate<Json::Value *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z
_TEXT	SEGMENT
$T76549 = -2						; size = 1
$T76548 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T76548[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAPAVValue@Json@@PAPAPAV12@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAPAVValue@Json@@0@Z ; std::_Ptr_cat<Json::Value * * *,Json::Value * * *>
	add	esp, 8
	mov	BYTE PTR $T76549[ebp], al
	movzx	eax, BYTE PTR $T76548[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T76549[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z
_TEXT	SEGMENT
$T76552 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z PROC ; std::_Allocate<Json::PathArgument>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@8

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@8
$LN3@Allocate@8:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 36					; 00000024H
	jae	SHORT $LN2@Allocate@8

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T76552[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T76552[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@8:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 36					; 00000024H
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@8:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ENDP ; std::_Allocate<Json::PathArgument>
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z$0
__ehfuncinfo$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT
tv74 = -28						; size = 4
$T76556 = -24						; size = 4
$T76555 = -20						; size = 4
__Vptr$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z PROC ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>, COMDAT

; 50   : 	{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 51   : 	void _FARQ *_Vptr = _Ptr;

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Vptr$[ebp], eax

; 52   : 	::new (_Vptr) _T1(_Val);

	mov	ecx, DWORD PTR __Vptr$[ebp]
	push	ecx
	push	44					; 0000002cH
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T76556[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	cmp	DWORD PTR $T76556[ebp], 0
	je	SHORT $LN3@Construct@5
	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T76556[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR tv74[ebp], eax
	jmp	SHORT $LN4@Construct@5
$LN3@Construct@5:
	mov	DWORD PTR tv74[ebp], 0
$LN4@Construct@5:
	mov	eax, DWORD PTR tv74[ebp]
	mov	DWORD PTR $T76555[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1

; 53   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z$0:
	mov	eax, DWORD PTR __Vptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR $T76556[ebp]
	push	ecx
	call	??3@YAXPAX0@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ENDP ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
;	COMDAT ??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z
_TEXT	SEGMENT
$T76568 = -12						; size = 12
__Count$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z PROC ; std::_Allocate<Json::Reader::ErrorInfo>, COMDAT

; 36   : 	{	// check for integer overflow

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH

; 37   : 	if (_Count <= 0)

	cmp	DWORD PTR __Count$[ebp], 0
	ja	SHORT $LN3@Allocate@9

; 38   : 		_Count = 0;

	mov	DWORD PTR __Count$[ebp], 0
	jmp	SHORT $LN2@Allocate@9
$LN3@Allocate@9:

; 39   : 	else if (((_SIZT)(-1) / _Count) < sizeof (_Ty))

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Count$[ebp]
	cmp	eax, 44					; 0000002cH
	jae	SHORT $LN2@Allocate@9

; 40   : 		_THROW_NCEE(std::bad_alloc, NULL);

	push	0
	lea	ecx, DWORD PTR $T76568[ebp]
	call	??0bad_alloc@std@@QAE@PBD@Z		; std::bad_alloc::bad_alloc
	push	OFFSET __TI2?AVbad_alloc@std@@
	lea	eax, DWORD PTR $T76568[ebp]
	push	eax
	call	__CxxThrowException@8
$LN2@Allocate@9:

; 41   : 
; 42   : 		// allocate storage for _Count elements of type _Ty
; 43   : 	return ((_Ty _FARQ *)::operator new(_Count * sizeof (_Ty)));

	mov	ecx, DWORD PTR __Count$[ebp]
	imul	ecx, 44					; 0000002cH
	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
$LN5@Allocate@9:

; 44   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ENDP ; std::_Allocate<Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z
_TEXT	SEGMENT
$T76572 = -2						; size = 1
$T76571 = -1						; size = 1
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Val$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT

; 940  : 	{	// copy _Count *_Val to raw _First, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 941  : 	_STD _Uninit_fill_n(_First, _Count, _Val, _Al,
; 942  : 		_STD _Ptr_cat(_First, _First), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T76571[ebp], al
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YA?AU_Scalar_ptr_iterator_tag@0@AAPAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_cat<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
	add	esp, 8
	mov	BYTE PTR $T76572[ebp], al
	movzx	eax, BYTE PTR $T76571[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T76572[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninit_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@U_Scalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 24					; 00000018H

; 943  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z
_TEXT	SEGMENT
$T76575 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::PathArgument> >, COMDAT

; 224  : 	{	// destroy [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 225  : 	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T76575[ebp], al
	movzx	edx, BYTE PTR $T76575[ebp]
	push	edx
	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@@Z ; std::_Destroy_range<std::allocator<Json::PathArgument> >
	add	esp, 16					; 00000010H

; 226  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$unchecked_copy@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z
_TEXT	SEGMENT
$T76580 = -3						; size = 1
$T76579 = -2						; size = 1
$T76578 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$unchecked_copy@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z PROC ; stdext::unchecked_copy<Json::PathArgument *,Json::PathArgument *>, COMDAT

; 3604 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx

; 3605 : 		return (_STD _Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 3606 : 			_STD _Iter_random(_First, _Dest), _STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T76578[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T76579[ebp], al
	movzx	eax, BYTE PTR $T76578[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T76579[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76580[ebp]
	push	ecx
	call	??$_Iter_random@PAVPathArgument@Json@@PAV12@@std@@YA?AUrandom_access_iterator_tag@0@ABQAVPathArgument@Json@@0@Z ; std::_Iter_random<Json::PathArgument *,Json::PathArgument *>
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	call	??$_Copy_opt@PAVPathArgument@Json@@PAV12@@std@@YAPAVPathArgument@Json@@PAV12@00Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<Json::PathArgument *,Json::PathArgument *>
	add	esp, 24					; 00000018H

; 3607 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_copy@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ENDP ; stdext::unchecked_copy<Json::PathArgument *,Json::PathArgument *>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==, COMDAT
; _this$ = ecx

; 203  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 204  : 
; 205  :  #if _HAS_ITERATOR_DEBUGGING
; 206  : 		_Compat(_Right);
; 207  :  #else
; 208  : 		_SCL_SECURE_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@operator@18
	mov	ecx, DWORD PTR __Right$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@operator@18
$LN1@operator@18:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@18:

; 209  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 210  : 
; 211  : 		return (_Myptr == _Right._Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	xor	eax, eax
	cmp	edx, DWORD PTR [ecx+4]
	sete	al

; 212  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv128 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-, COMDAT
; _this$ = ecx

; 225  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 
; 227  :  #if _HAS_ITERATOR_DEBUGGING
; 228  : 		_Compat(_Right);
; 229  :  #else
; 230  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@operator@19
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@19
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@19
$LN1@operator@19:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@19:

; 231  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 232  : 
; 233  : 		return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
; 234  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	ja	SHORT $LN6@operator@19
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN7@operator@19
$LN6@operator@19:
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	neg	eax
	mov	DWORD PTR tv128[ebp], eax
$LN7@operator@19:
	mov	eax, DWORD PTR tv128[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=, COMDAT
; _this$ = ecx

; 215  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 216  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 217  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z
_TEXT	SEGMENT
tv128 = -8						; size = 4
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-, COMDAT
; _this$ = ecx

; 225  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 226  : 
; 227  :  #if _HAS_ITERATOR_DEBUGGING
; 228  : 		_Compat(_Right);
; 229  :  #else
; 230  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@operator@20
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@20
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@20
$LN1@operator@20:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@20:

; 231  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 232  : 
; 233  : 		return (_Right._Myoff <= _Myoff ? _Myoff - _Right._Myoff
; 234  : 			: -(difference_type)(_Right._Myoff - _Myoff));

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	ja	SHORT $LN6@operator@20
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv128[ebp], eax
	jmp	SHORT $LN7@operator@20
$LN6@operator@20:
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [edx+4]
	neg	eax
	mov	DWORD PTR tv128[ebp], eax
$LN7@operator@20:
	mov	eax, DWORD PTR tv128[ebp]

; 235  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy, COMDAT
; _this$ = ecx

; 159  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 160  : 		_Destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??$_Destroy@VErrorInfo@Reader@Json@@@std@@YAXPAVErrorInfo@Reader@Json@@@Z ; std::_Destroy<Json::Reader::ErrorInfo>
	add	esp, 4

; 161  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@IPAPAPAV12@@Z ; std::_Allocate<Json::Value * *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z PROC ; std::allocator<std::_Aux_cont>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@V_Aux_cont@std@@@std@@YAPAV_Aux_cont@0@IPAV10@@Z ; std::_Allocate<std::_Aux_cont>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ENDP ; std::allocator<std::_Aux_cont>::allocate
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVValue@Json@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVValue@Json@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::Value *,int,Json::Value * const *,Json::Value * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::Value *,int,Json::Value * const *,Json::Value * const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVValue@Json@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::Value *,int,Json::Value * const *,Json::Value * const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::Value *,int,Json::Value * const *,Json::Value * const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VPathArgument@Json@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VPathArgument@Json@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VPathArgument@Json@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@PAVValue@Json@@HPBQAV12@ABQAV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@PAVValue@Json@@HPBQAV12@ABQAV12@@std@@QAE@XZ PROC ; std::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@PAVValue@Json@@HPBQAV34@ABQAV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@PAVValue@Json@@HPBQAV12@ABQAV12@@std@@QAE@XZ ENDP ; std::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>::_Ranit<Json::Value *,int,Json::Value * const *,Json::Value * const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ PROC ; std::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VPathArgument@Json@@HPBV34@ABV34@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ ENDP ; std::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>::_Ranit<Json::PathArgument,int,Json::PathArgument const *,Json::PathArgument const &>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0length_error@std@@QAE@ABV01@@Z PROC			; std::length_error::length_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV01@@Z ENDP			; std::length_error::length_error
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-, COMDAT
; _this$ = ecx

; 444  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-

; 446  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>, COMDAT
; _this$ = ecx

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVValue@Json@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@Deque_cons
	cmp	DWORD PTR __Pdeque$[ebp], 0
	je	SHORT $LN1@Deque_cons
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR __Off$[ebp]
	ja	SHORT $LN1@Deque_cons
	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Pdeque$[ebp]
	add	ecx, DWORD PTR [edx+28]
	cmp	DWORD PTR __Off$[ebp], ecx
	jbe	SHORT $LN3@Deque_cons
$LN1@Deque_cons:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@Deque_cons:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 132  : 			_Myoff = _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 133  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-, COMDAT
; _this$ = ecx

; 444  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-

; 446  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>, COMDAT
; _this$ = ecx

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>

; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 76   : 	_Vector_const_iterator(_Tptr _Ptr, const _Container_base *_Pvector)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VPathArgument@Json@@HPBV12@ABV12@@std@@QAE@XZ

; 77   : 		{	// construct with pointer _Ptr
; 78   : 		_SCL_SECURE_VALIDATE(_Pvector != NULL && ((_Myvec *)_Pvector)->_Myfirst <= _Ptr && _Ptr <= ((_Myvec *)_Pvector)->_Mylast);

	cmp	DWORD PTR __Pvector$[ebp], 0
	je	SHORT $LN1@Vector_con@3
	mov	eax, DWORD PTR __Pvector$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	cmp	ecx, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN1@Vector_con@3
	mov	edx, DWORD PTR __Pvector$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [edx+16]
	jbe	SHORT $LN2@Vector_con@3
$LN1@Vector_con@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@Vector_con@3:

; 79   : 		this->_Set_container(_Pvector);

	mov	ecx, DWORD PTR __Pvector$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 80   : 		_Myptr = _Ptr;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+4], eax

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@IPAPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$60797 = -8					; size = 4
__Newoff$60796 = -4					; size = 4
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back, COMDAT
; _this$ = ecx

; 863  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 864  : 
; 865  :  #if _HAS_ITERATOR_DEBUGGING
; 866  : 		if (empty())
; 867  : 			_DEBUG_ERROR("deque empty before pop");
; 868  : 		else
; 869  : 			{	// something to erase, do it
; 870  : 			_Orphan_off(_Myoff + _Mysize - 1);
; 871  : 
; 872  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 873  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@pop_back

; 874  : 			{	// something to erase, do it
; 875  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 876  : 
; 877  : 			size_type _Newoff = _Mysize + _Myoff - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	lea	edx, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR __Newoff$60796[ebp], edx

; 878  : 			size_type _Block = _Newoff / _DEQUESIZ;

	mov	eax, DWORD PTR __Newoff$60796[ebp]
	mov	DWORD PTR __Block$60797[ebp], eax

; 879  : 			if (_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR __Block$60797[ebp]
	ja	SHORT $LN2@pop_back

; 880  : 				_Block -= _Mapsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Block$60797[ebp]
	sub	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$60797[ebp], ecx
$LN2@pop_back:

; 881  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR __Newoff$60796[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR __Block$60797[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy

; 882  : 			if (--_Mysize == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN4@pop_back

; 883  : 				_Myoff = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN4@pop_back:

; 884  : 			}
; 885  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Block$60778 = -4					; size = 4
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front, COMDAT
; _this$ = ecx

; 819  : 		{	// erase element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 820  : 
; 821  :  #if _HAS_ITERATOR_DEBUGGING
; 822  : 		if (empty())
; 823  : 			_DEBUG_ERROR("deque empty before pop");
; 824  : 		else
; 825  : 			{	// something to erase, do it
; 826  : 			_Orphan_off(_Myoff);
; 827  : 
; 828  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 829  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@pop_front

; 830  : 			{	// something to erase, do it
; 831  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 832  : 
; 833  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Block$60778[ebp], edx

; 834  : 			this->_Alval.destroy(_Map[_Block] + _Myoff % _DEQUESIZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR __Block$60778[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy

; 835  : 			if (_Mapsize * _DEQUESIZ <= ++_Myoff)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], edx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [edx+24]
	ja	SHORT $LN2@pop_front

; 836  : 				_Myoff = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$LN2@pop_front:

; 837  : 			if (--_Mysize == 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+28], 0
	jne	SHORT $LN4@pop_front

; 838  : 				_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN4@pop_front:

; 839  : 			}
; 840  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z PROC ; std::allocator<Json::Value *>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@PAVValue@Json@@PAV12@@std@@YAXPAPAVValue@Json@@ABQAV12@@Z ; std::_Construct<Json::Value *,Json::Value *>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ENDP ; std::allocator<Json::Value *>::construct
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@PAVValue@Json@@@std@@YAPAPAVValue@Json@@IPAPAV12@@Z ; std::_Allocate<Json::Value *>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Block$60654 = -4					; size = 4
?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front, COMDAT
; _this$ = ecx

; 819  : 		{	// erase element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 820  : 
; 821  :  #if _HAS_ITERATOR_DEBUGGING
; 822  : 		if (empty())
; 823  : 			_DEBUG_ERROR("deque empty before pop");
; 824  : 		else
; 825  : 			{	// something to erase, do it
; 826  : 			_Orphan_off(_Myoff);
; 827  : 
; 828  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 829  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
	movzx	eax, al
	test	eax, eax
	jne	$LN4@pop_front@2

; 830  : 			{	// something to erase, do it
; 831  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 832  : 
; 833  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shr	edx, 2
	mov	DWORD PTR __Block$60654[ebp], edx

; 834  : 			this->_Alval.destroy(_Map[_Block] + _Myoff % _DEQUESIZ);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$60654[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy

; 835  : 			if (_Mapsize * _DEQUESIZ <= ++_Myoff)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	shl	ecx, 2
	mov	edx, DWORD PTR _this$[ebp]
	cmp	ecx, DWORD PTR [edx+24]
	ja	SHORT $LN2@pop_front@2

; 836  : 				_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
$LN2@pop_front@2:

; 837  : 			if (--_Mysize == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN4@pop_front@2

; 838  : 				_Myoff = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
$LN4@pop_front@2:

; 839  : 			}
; 840  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter, COMDAT
; _this$ = ecx

; 685  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		return (iterator(_Where._Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 687  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z PROC ; std::allocator<Json::PathArgument>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VPathArgument@Json@@@std@@YAPAVPathArgument@Json@@IPAV12@@Z ; std::_Allocate<Json::PathArgument>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ENDP ; std::allocator<Json::PathArgument>::allocate
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T76640 = -24						; size = 4
$T76639 = -20						; size = 4
$T76638 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0VPathArgument@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VPathArgument@Json@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::PathArgument>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T76640[ebp], eax
	mov	ecx, DWORD PTR $T76640[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T76639[ebp], eax
	cmp	DWORD PTR $T76639[ebp], 0
	je	SHORT $LN3@Container_
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T76639[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_
$LN3@Container_:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T76638[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T76638[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
;	COMDAT ??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VErrorInfo@Reader@Json@@HPBV345@ABV345@V_Iterator_base_aux@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VErrorInfo@Reader@Json@@HPBV345@ABV345@V_Iterator_base_aux@2@@std@@QAE@XZ PROC ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &,std::_Iterator_base_aux>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base_aux@std@@QAE@XZ	; std::_Iterator_base_aux::_Iterator_base_aux
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VErrorInfo@Reader@Json@@HPBV345@ABV345@V_Iterator_base_aux@2@@std@@QAE@XZ ENDP ; std::_Iterator_with_base<std::random_access_iterator_tag,Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &,std::_Iterator_base_aux>::_Iterator_with_base<std::random_access_iterator_tag,Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &,std::_Iterator_base_aux>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ PROC ; std::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator_with_base@Urandom_access_iterator_tag@std@@VErrorInfo@Reader@Json@@HPBV345@ABV345@V_Iterator_base_aux@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ ENDP ; std::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>::_Ranit<Json::Reader::ErrorInfo,int,Json::Reader::ErrorInfo const *,Json::Reader::ErrorInfo const &>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator==, COMDAT
; _this$ = ecx

; 243  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 244  : 
; 245  :  #if _HAS_ITERATOR_DEBUGGING
; 246  : 		_Compat(_Right);
; 247  : 		return (_Myoff == _Right._Myoff);
; 248  : 		}
; 249  : 
; 250  :  #elif _SECURE_SCL
; 251  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container() && this->_Same_container(_Right));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@operator@21
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@operator@21
	mov	edx, DWORD PTR __Right$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Same_container@_Iterator_base_aux@std@@QBE_NABV12@@Z ; std::_Iterator_base_aux::_Same_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@operator@21
$LN1@operator@21:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@21:

; 252  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR [edx+4]
	sete	cl
	mov	al, cl

; 253  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>, COMDAT
; _this$ = ecx

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN3@Deque_cons@2
	cmp	DWORD PTR __Pdeque$[ebp], 0
	je	SHORT $LN1@Deque_cons@2
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR __Off$[ebp]
	ja	SHORT $LN1@Deque_cons@2
	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Pdeque$[ebp]
	add	ecx, DWORD PTR [edx+28]
	cmp	DWORD PTR __Off$[ebp], ecx
	jbe	SHORT $LN3@Deque_cons@2
$LN1@Deque_cons@2:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@Deque_cons@2:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 132  : 			_Myoff = _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 133  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xmemory
_TEXT	ENDS
;	COMDAT ?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Val$ = 12						; size = 4
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct, COMDAT
; _this$ = ecx

; 154  : 		{	// construct object at _Ptr with value _Val

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 155  : 		_Construct(_Ptr, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	??$_Construct@VErrorInfo@Reader@Json@@V123@@std@@YAXPAVErrorInfo@Reader@Json@@ABV123@@Z ; std::_Construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
	add	esp, 8

; 156  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocate, COMDAT
; _this$ = ecx

; 144  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 145  : 		return (_Allocate(_Count, (pointer)0));

	push	0
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	??$_Allocate@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@IPAV123@@Z ; std::_Allocate<Json::Reader::ErrorInfo>
	add	esp, 8

; 146  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocate
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::~_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::~_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$60332 = -4					; size = 4
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1268 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$LN6@Tidy@3:

; 1269 : 		while (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Tidy@3

; 1270 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN6@Tidy@3
$LN5@Tidy@3:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Count$60332[ebp], edx
$LN4@Tidy@3:
	cmp	DWORD PTR __Count$60332[ebp], 0
	jbe	SHORT $LN3@Tidy@3

; 1272 : 			{	// free storage for a block and destroy pointer
; 1273 : 			if (*(_Map + --_Count) != 0)

	mov	eax, DWORD PTR __Count$60332[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$60332[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$60332[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN2@Tidy@3

; 1274 : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$60332[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate
$LN2@Tidy@3:

; 1275 : 			this->_Almap.destroy(_Map + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$60332[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?destroy@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo *>::destroy

; 1276 : 			}

	jmp	SHORT $LN4@Tidy@3
$LN3@Tidy@3:

; 1277 : 
; 1278 : 		if (_Map)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN1@Tidy@3

; 1279 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
$LN1@Tidy@3:

; 1280 : 		_Mapsize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1281 : 		_Map = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::~_Container_base_aux_alloc_real<std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::~_Container_base_aux_alloc_real<std::allocator<Json::Value *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$60126 = -8					; size = 4
__Newoff$60125 = -4					; size = 4
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back, COMDAT
; _this$ = ecx

; 863  : 		{	// erase element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 864  : 
; 865  :  #if _HAS_ITERATOR_DEBUGGING
; 866  : 		if (empty())
; 867  : 			_DEBUG_ERROR("deque empty before pop");
; 868  : 		else
; 869  : 			{	// something to erase, do it
; 870  : 			_Orphan_off(_Myoff + _Mysize - 1);
; 871  : 
; 872  :  #else /* _HAS_ITERATOR_DEBUGGING */
; 873  : 		if (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN4@pop_back@2

; 874  : 			{	// something to erase, do it
; 875  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 876  : 
; 877  : 			size_type _Newoff = _Mysize + _Myoff - 1;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	lea	edx, DWORD PTR [edx+ecx-1]
	mov	DWORD PTR __Newoff$60125[ebp], edx

; 878  : 			size_type _Block = _Newoff / _DEQUESIZ;

	mov	eax, DWORD PTR __Newoff$60125[ebp]
	shr	eax, 2
	mov	DWORD PTR __Block$60126[ebp], eax

; 879  : 			if (_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	cmp	edx, DWORD PTR __Block$60126[ebp]
	ja	SHORT $LN2@pop_back@2

; 880  : 				_Block -= _Mapsize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Block$60126[ebp]
	sub	ecx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$60126[ebp], ecx
$LN2@pop_back@2:

; 881  : 			this->_Alval.destroy(_Map[_Block] + _Newoff % _DEQUESIZ);

	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR __Newoff$60125[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$60126[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?destroy@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy

; 882  : 			if (--_Mysize == 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+28], 0
	jne	SHORT $LN4@pop_back@2

; 883  : 				_Myoff = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+24], 0
$LN4@pop_back@2:

; 884  : 			}
; 885  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 680  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 681  : 		return (const_iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 682  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 675  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 676  : 		return (iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 677  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin, COMDAT
; _this$ = ecx

; 670  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  : 		return (const_iterator(_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 672  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin, COMDAT
; _this$ = ecx

; 665  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 666  : 		return (iterator(_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 667  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??1?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@XZ PROC ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::~_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 436  : 		{

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 437  : 		_Myownedaux->~_Aux_cont();
; 438  : 
; 439  : 		_Alaux.deallocate(_Myownedaux, 1);

	push	1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?deallocate@?$allocator@V_Aux_cont@std@@@std@@QAEXPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::deallocate

; 440  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@XZ ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::~_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T76683 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z PROC ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 425  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T76683[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>

; 426  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ENDP ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy, COMDAT
; _this$ = ecx

; 1118 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1119 : 		_Destroy_range(_First, _Last, this->_Alval);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@VPathArgument@Json@@@std@@@std@@YAXPAVPathArgument@Json@@0AAV?$allocator@VPathArgument@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::PathArgument> >
	add	esp, 12					; 0000000cH

; 1120 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end, COMDAT
; _this$ = ecx

; 655  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 656  : 		return (const_iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 657  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin, COMDAT
; _this$ = ecx

; 645  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		return (const_iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 647  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::~_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::~_Deque_map<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::~_Container_base_aux_alloc_real<std::allocator<Json::Value *> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::~_Deque_map<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::~_Deque_val<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::~_Deque_val<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::~_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Container_base_aux_alloc_real@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@XZ ; std::_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >::~_Container_base_aux_alloc_real<std::allocator<Json::PathArgument> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::~_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator!=, COMDAT
; _this$ = ecx

; 261  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 263  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear, COMDAT
; _this$ = ecx

; 1085 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1087 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 680  : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 681  : 		return (const_iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 682  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 670  : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 671  : 		return (const_iterator(_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 672  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 640  : 		{	// destroy the deque

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 641  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 642  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
__ehhandler$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stack
;	COMDAT ?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop, COMDAT
; _this$ = ecx

; 62   : 		{	// erase last element

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 63   : 		c.pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back

; 64   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
; Function compile flags: /Odtp
; File e:\newggdevelop\client\ggjsoncpp\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
_this$ = -72						; size = 4
$T76724 = -68						; size = 4
_buffer$ = -64						; size = 51
__$ArrayPad$ = -12					; size = 4
_line$ = -8						; size = 4
_column$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_location$ = 12						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 870  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T76724[ebp], 0

; 871  :    int line, column;
; 872  :    getLocationLineAndColumn( location, line, column );

	lea	eax, DWORD PTR _column$[ebp]
	push	eax
	lea	ecx, DWORD PTR _line$[ebp]
	push	ecx
	mov	edx, DWORD PTR _location$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn

; 873  :    char buffer[18+16+16+1];
; 874  : #if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__)
; 875  :    sprintf_s(buffer, sizeof(buffer), "Line %d, Column %d", line, column);

	mov	eax, DWORD PTR _column$[ebp]
	push	eax
	mov	ecx, DWORD PTR _line$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
	push	51					; 00000033H
	lea	edx, DWORD PTR _buffer$[ebp]
	push	edx
	call	DWORD PTR __imp__sprintf_s
	add	esp, 20					; 00000014H

; 876  : #else
; 877  :    snprintf(buffer, sizeof(buffer), "Line %d, Column %d", line, column);
; 878  : #endif
; 879  :    return buffer;

	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	ecx, DWORD PTR $T76724[ebp]
	or	ecx, 1
	mov	DWORD PTR $T76724[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 880  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
PUBLIC	?readNumber@Reader@Json@@AAEXXZ			; Json::Reader::readNumber
; Function compile flags: /Odtp
;	COMDAT ?readNumber@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?readNumber@Reader@Json@@AAEXXZ PROC			; Json::Reader::readNumber, COMDAT
; _this$ = ecx

; 444  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
$LN4@readNumber:

; 445  :    while ( current_ != end_ )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+100]
	cmp	edx, DWORD PTR [ecx+96]
	je	SHORT $LN5@readNumber

; 446  :    {
; 447  :       if ( !(*current_ >= '0'  &&  *current_ <= '9')  &&
; 448  :            !in( *current_, '.', 'e', 'E', '+', '-' ) )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN1@readNumber
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	movsx	edx, BYTE PTR [ecx]
	cmp	edx, 57					; 00000039H
	jle	SHORT $LN2@readNumber
$LN1@readNumber:
	push	45					; 0000002dH
	push	43					; 0000002bH
	push	69					; 00000045H
	push	101					; 00000065H
	push	46					; 0000002eH
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	call	?in@Json@@YA_NDDDDDD@Z			; Json::in
	add	esp, 24					; 00000018H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@readNumber

; 449  :          break;

	jmp	SHORT $LN5@readNumber
$LN2@readNumber:

; 450  :       ++current_;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+100], edx

; 451  :    }

	jmp	SHORT $LN4@readNumber
$LN5@readNumber:

; 452  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readNumber@Reader@Json@@AAEXXZ ENDP			; Json::Reader::readNumber
_TEXT	ENDS
PUBLIC	?strictMode@Features@Json@@SA?AV12@XZ		; Json::Features::strictMode
; Function compile flags: /Odtp
;	COMDAT ?strictMode@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
_features$ = -4						; size = 2
___$ReturnUdt$ = 8					; size = 4
?strictMode@Features@Json@@SA?AV12@XZ PROC		; Json::Features::strictMode, COMDAT

; 44   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 45   :    Features features;

	lea	ecx, DWORD PTR _features$[ebp]
	call	??0Features@Json@@QAE@XZ		; Json::Features::Features

; 46   :    features.allowComments_ = false;

	mov	BYTE PTR _features$[ebp], 0

; 47   :    features.strictRoot_ = true;

	mov	BYTE PTR _features$[ebp+1], 1

; 48   :    return features;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	cx, WORD PTR _features$[ebp]
	mov	WORD PTR [eax], cx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 49   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?strictMode@Features@Json@@SA?AV12@XZ ENDP		; Json::Features::strictMode
_TEXT	ENDS
PUBLIC	?all@Features@Json@@SA?AV12@XZ			; Json::Features::all
; Function compile flags: /Odtp
;	COMDAT ?all@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?all@Features@Json@@SA?AV12@XZ PROC			; Json::Features::all, COMDAT

; 37   : {

	push	ebp
	mov	ebp, esp

; 38   :    return Features();

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Features@Json@@QAE@XZ		; Json::Features::Features
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 39   : }

	pop	ebp
	ret	0
?all@Features@Json@@SA?AV12@XZ ENDP			; Json::Features::all
_TEXT	ENDS
PUBLIC	??9ValueIteratorBase@Json@@QBE_NABV01@@Z	; Json::ValueIteratorBase::operator!=
; Function compile flags: /Odtp
; File e:\newggdevelop\client\include\json\value.h
;	COMDAT ??9ValueIteratorBase@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??9ValueIteratorBase@Json@@QBE_NABV01@@Z PROC		; Json::ValueIteratorBase::operator!=, COMDAT
; _this$ = ecx

; 948  :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 949  :          return !isEqual( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z ; Json::ValueIteratorBase::isEqual
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 950  :       }

	mov	esp, ebp
	pop	ebp
	ret	4
??9ValueIteratorBase@Json@@QBE_NABV01@@Z ENDP		; Json::ValueIteratorBase::operator!=
_TEXT	ENDS
PUBLIC	??8ValueIteratorBase@Json@@QBE_NABV01@@Z	; Json::ValueIteratorBase::operator==
; Function compile flags: /Odtp
;	COMDAT ??8ValueIteratorBase@Json@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??8ValueIteratorBase@Json@@QBE_NABV01@@Z PROC		; Json::ValueIteratorBase::operator==, COMDAT
; _this$ = ecx

; 943  :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 944  :          return isEqual( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isEqual@ValueIteratorBase@Json@@IBE_NABV12@@Z ; Json::ValueIteratorBase::isEqual

; 945  :       }

	mov	esp, ebp
	pop	ebp
	ret	4
??8ValueIteratorBase@Json@@QBE_NABV01@@Z ENDP		; Json::ValueIteratorBase::operator==
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1runtime_error@std@@UAE@XZ		; std::runtime_error::~runtime_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@7
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@7:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stdexcept
_TEXT	ENDS
;	COMDAT ??1length_error@std@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1length_error@std@@UAE@XZ PROC			; std::length_error::~length_error, COMDAT
; _this$ = ecx

; 109  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7length_error@std@@6B@

; 110  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	esp, ebp
	pop	ebp
	ret	0
??1length_error@std@@UAE@XZ ENDP			; std::length_error::~length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Message$ = 8						; size = 4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::length_error::length_error, COMDAT
; _this$ = ecx

; 105  : 		{	// construct from message string

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Message$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0logic_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::logic_error::logic_error
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx], OFFSET ??_7length_error@std@@6B@

; 106  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::length_error::length_error
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glogic_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glogic_error@std@@UAEPAXI@Z PROC			; std::logic_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1logic_error@std@@UAE@XZ		; std::logic_error::~logic_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@8
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@8:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glogic_error@std@@UAEPAXI@Z ENDP			; std::logic_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ
_TEXT	SEGMENT
tv67 = -8						; size = 4
_this$ = -4						; size = 4
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ PROC ; std::_Iterator_base_aux::_Getmycont, COMDAT
; _this$ = ecx

; 457  : 		{	// Go through the aux object to get the container

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 458  : 		return _Myaux ? _Myaux->_Getcont() : 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	?_Getcont@_Aux_cont@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Aux_cont::_Getcont
	mov	DWORD PTR tv67[ebp], eax
	jmp	SHORT $LN4@Getmycont
$LN3@Getmycont:
	mov	DWORD PTR tv67[ebp], 0
$LN4@Getmycont:
	mov	eax, DWORD PTR tv67[ebp]

; 459  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ENDP ; std::_Iterator_base_aux::_Getmycont
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Gbad_alloc@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Gbad_alloc@std@@UAEPAXI@Z PROC			; std::bad_alloc::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1bad_alloc@std@@UAE@XZ		; std::bad_alloc::~bad_alloc
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@9
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@9:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Gbad_alloc@std@@UAEPAXI@Z ENDP			; std::bad_alloc::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--, COMDAT
; _this$ = ecx

; 176  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	xor	eax, eax
	je	SHORT $LN4@operator@31
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator@31
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN4@operator@31:

; 178  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff > ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	xor	edx, edx
	je	SHORT $LN2@operator@31
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+24]
	ja	SHORT $LN2@operator@31
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@31:

; 179  : 
; 180  :  #if _HAS_ITERATOR_DEBUGGING
; 181  : 		if (this->_Mycont == 0
; 182  : 			|| _Myoff == ((_Mydeque *)this->_Mycont)->_Myoff)
; 183  : 			_DEBUG_ERROR("deque iterator not decrementable");
; 184  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 185  : 
; 186  : 		--_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 187  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>, COMDAT
; _this$ = ecx

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	xor	eax, eax
	je	SHORT $LN3@Deque_cons@3
	cmp	DWORD PTR __Pdeque$[ebp], 0
	je	SHORT $LN1@Deque_cons@3
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR __Off$[ebp]
	ja	SHORT $LN1@Deque_cons@3
	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Pdeque$[ebp]
	add	ecx, DWORD PTR [edx+28]
	cmp	DWORD PTR __Off$[ebp], ecx
	jbe	SHORT $LN3@Deque_cons@3
$LN1@Deque_cons@3:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@Deque_cons@3:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 132  : 			_Myoff = _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 133  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??F?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--, COMDAT
; _this$ = ecx

; 176  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 177  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	xor	eax, eax
	je	SHORT $LN4@operator@32
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator@32
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN4@operator@32:

; 178  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff > ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	xor	edx, edx
	je	SHORT $LN2@operator@32
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+24]
	ja	SHORT $LN2@operator@32
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@32:

; 179  : 
; 180  :  #if _HAS_ITERATOR_DEBUGGING
; 181  : 		if (this->_Mycont == 0
; 182  : 			|| _Myoff == ((_Mydeque *)this->_Mycont)->_Myoff)
; 183  : 			_DEBUG_ERROR("deque iterator not decrementable");
; 184  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 185  : 
; 186  : 		--_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 187  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 188  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>, COMDAT
; _this$ = ecx

; 125  : 		_Deque_const_iterator(size_type _Off, const _Mydequebase *_Pdeque)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@PAVValue@Json@@HPBQAV12@ABQAV12@@std@@QAE@XZ

; 126  : 			{	// construct with offset _Off in *_Pdeque
; 127  : 			_SCL_SECURE_TRAITS_VALIDATE(
; 128  : 				_Pdeque != NULL &&
; 129  : 				((_Mydeque *)_Pdeque)->_Myoff <= _Off && _Off <= (((_Mydeque *)_Pdeque)->_Myoff + ((_Mydeque *)_Pdeque)->_Mysize));

	xor	eax, eax
	je	SHORT $LN3@Deque_cons@4
	cmp	DWORD PTR __Pdeque$[ebp], 0
	je	SHORT $LN1@Deque_cons@4
	mov	ecx, DWORD PTR __Pdeque$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	cmp	edx, DWORD PTR __Off$[ebp]
	ja	SHORT $LN1@Deque_cons@4
	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	edx, DWORD PTR __Pdeque$[ebp]
	add	ecx, DWORD PTR [edx+28]
	cmp	DWORD PTR __Off$[ebp], ecx
	jbe	SHORT $LN3@Deque_cons@4
$LN1@Deque_cons@4:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@Deque_cons@4:

; 130  : 				
; 131  : 			this->_Set_container(_Pdeque);

	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Set_container@_Iterator_base_aux@std@@QAEXQBV_Container_base_aux@2@@Z ; std::_Iterator_base_aux::_Set_container

; 132  : 			_Myoff = _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], edx

; 133  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--, COMDAT
; _this$ = ecx

; 408  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--

; 410  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 411  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??F?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??F?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--, COMDAT
; _this$ = ecx

; 408  : 		{	// predecrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 409  : 		--*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??F?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--

; 410  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 411  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??F?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++, COMDAT
; _this$ = ecx

; 153  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	xor	eax, eax
	je	SHORT $LN4@operator@33
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator@33
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN4@operator@33:

; 155  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	xor	edx, edx
	je	SHORT $LN2@operator@33
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN2@operator@33
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@33:

; 156  : 
; 157  :  #if _HAS_ITERATOR_DEBUGGING
; 158  : 		if (this->_Mycont == 0
; 159  : 			|| ((_Mydeque *)this->_Mycont)->_Myoff
; 160  : 				+ ((_Mydeque *)this->_Mycont)->_Mysize == _Myoff)
; 161  : 			_DEBUG_ERROR("deque iterator not incrementable");
; 162  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 163  : 
; 164  : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
__Block$ = -4						; size = 4
??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*, COMDAT
; _this$ = ecx

; 136  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 2
	mov	DWORD PTR __Block$[ebp], ecx

; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 3
	mov	DWORD PTR __Off$[ebp], eax

; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator@34
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@34:

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], edx
	jb	SHORT $LN2@operator@34
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@34:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN1@operator@34

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR __Block$[ebp]
	sub	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$[ebp], edx
$LN1@operator@34:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]

; 144  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Base$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?_Checked_iterator_base@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 		_Deque_const_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR __Base$[ebp]
	call	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>

; 70   : 		return _Base;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Base$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Base$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Checked_iterator_base@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Base$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?_Checked_iterator_base@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 68   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 69   : 		_Deque_const_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR __Base$[ebp]
	call	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>

; 70   : 		return _Base;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Base$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Base$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 71   : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Checked_iterator_base@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@6
$LN5@Uninit_cop@6:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@6:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@6

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
	jmp	SHORT $LN5@Uninit_cop@6
$LN4@Uninit_cop@6:
	jmp	SHORT $LN10@Uninit_cop@6
__catch$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@6
$LN2@Uninit_cop@6:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@6:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@6

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
	jmp	SHORT $LN2@Uninit_cop@6
$LN1@Uninit_cop@6:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@6:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@6:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0
__tryblocktable$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$2
__ehfuncinfo$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
__Next$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Uninit_copy<Json::PathArgument const *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT

; 124  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, arbitrary type

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 125  : 	_DEBUG_RANGE(_First, _Last);
; 126  : 	_DEBUG_POINTER(_Dest);
; 127  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 128  : 
; 129  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 130  : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN6@Uninit_cop@7
$LN5@Uninit_cop@7:
	mov	ecx, DWORD PTR __Dest$[ebp]
	add	ecx, 36					; 00000024H
	mov	DWORD PTR __Dest$[ebp], ecx
	mov	edx, DWORD PTR __First$[ebp]
	add	edx, 36					; 00000024H
	mov	DWORD PTR __First$[ebp], edx
$LN6@Uninit_cop@7:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Uninit_cop@7

; 131  : 		_Al.construct(_Dest, *_First);

	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?construct@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@ABV34@@Z ; std::allocator<Json::PathArgument>::construct
	jmp	SHORT $LN5@Uninit_cop@7
$LN4@Uninit_cop@7:
	jmp	SHORT $LN10@Uninit_cop@7
__catch$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$0:

; 132  : 	_CATCH_ALL
; 133  : 	for (; _Next != _Dest; ++_Next)

	jmp	SHORT $LN3@Uninit_cop@7
$LN2@Uninit_cop@7:
	mov	eax, DWORD PTR __Next$[ebp]
	add	eax, 36					; 00000024H
	mov	DWORD PTR __Next$[ebp], eax
$LN3@Uninit_cop@7:
	mov	ecx, DWORD PTR __Next$[ebp]
	cmp	ecx, DWORD PTR __Dest$[ebp]
	je	SHORT $LN1@Uninit_cop@7

; 134  : 		_Al.destroy(_Next);

	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	?destroy@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@@Z ; std::allocator<Json::PathArgument>::destroy
	jmp	SHORT $LN2@Uninit_cop@7
$LN1@Uninit_cop@7:

; 135  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 136  : 	_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1
	ret	0
$LN10@Uninit_cop@7:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z$1:

; 137  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN9@Uninit_cop@7:

; 138  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Uninit_copy<Json::PathArgument const *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++, COMDAT
; _this$ = ecx

; 153  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	xor	eax, eax
	je	SHORT $LN4@operator@35
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator@35
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN4@operator@35:

; 155  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	xor	edx, edx
	je	SHORT $LN2@operator@35
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN2@operator@35
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@35:

; 156  : 
; 157  :  #if _HAS_ITERATOR_DEBUGGING
; 158  : 		if (this->_Mycont == 0
; 159  : 			|| ((_Mydeque *)this->_Mycont)->_Myoff
; 160  : 				+ ((_Mydeque *)this->_Mycont)->_Mysize == _Myoff)
; 161  : 			_DEBUG_ERROR("deque iterator not incrementable");
; 162  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 163  : 
; 164  : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
__Block$ = -4						; size = 4
??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*, COMDAT
; _this$ = ecx

; 136  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Block$[ebp], ecx

; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 0
	mov	DWORD PTR __Off$[ebp], eax

; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator@36
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@36:

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], edx
	jb	SHORT $LN2@operator@36
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@36:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN1@operator@36

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR __Block$[ebp]
	sub	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$[ebp], edx
$LN1@operator@36:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR __Block$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	eax, ecx

; 144  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@1@@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-, COMDAT
; _this$ = ecx

; 444  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-

; 446  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@1@@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++, COMDAT
; _this$ = ecx

; 395  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++

; 397  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 398  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*, COMDAT
; _this$ = ecx

; 385  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*

; 387  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@1@@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-, COMDAT
; _this$ = ecx

; 444  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 445  : 		return (*(_Mybase *)this - _Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-

; 446  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@1@@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator!=, COMDAT
; _this$ = ecx

; 261  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 262  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator==
	movzx	eax, al
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 263  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator!=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator++, COMDAT
; _this$ = ecx

; 153  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@operator@37
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator@37
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN4@operator@37:

; 155  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@operator@37
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN2@operator@37
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@37:

; 156  : 
; 157  :  #if _HAS_ITERATOR_DEBUGGING
; 158  : 		if (this->_Mycont == 0
; 159  : 			|| ((_Mydeque *)this->_Mycont)->_Myoff
; 160  : 				+ ((_Mydeque *)this->_Mycont)->_Mysize == _Myoff)
; 161  : 			_DEBUG_ERROR("deque iterator not incrementable");
; 162  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 163  : 
; 164  : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator++
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0ABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$_Fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0ABVErrorInfo@Reader@Json@@@Z PROC ; std::_Fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,Json::Reader::ErrorInfo>, COMDAT

; 3156 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp

; 3157 : 	_DEBUG_RANGE(_First, _Last);
; 3158 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN3@Fill@4
$LN2@Fill@4:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
$LN3@Fill@4:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN4@Fill@4

; 3159 : 		*_First = _Val;

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
	mov	ecx, eax
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
	jmp	SHORT $LN2@Fill@4
$LN4@Fill@4:

; 3160 : 	}

	pop	ebp
	ret	0
??$_Fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0ABVErrorInfo@Reader@Json@@@Z ENDP ; std::_Fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z PROC ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ENDP ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z PROC ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ENDP ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\memory
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z
_TEXT	SEGMENT
$T77396 = -2						; size = 1
$T77395 = -1						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z PROC ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T77395[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@PAVPathArgument@Json@@PAV12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAPAVPathArgument@Json@@0@Z ; std::_Ptr_cat<Json::PathArgument *,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T77396[ebp], al
	movzx	eax, BYTE PTR $T77395[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T77396[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@PAVPathArgument@Json@@@std@@YAPAVPathArgument@Json@@AAPAV12@@Z ; std::_Checked_base<Json::PathArgument *>
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ENDP ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@V?$allocator@VPathArgument@Json@@@2@@stdext@@YAPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@0PAV12@AAV?$allocator@VPathArgument@Json@@@4@@Z
_TEXT	SEGMENT
$T77400 = -2						; size = 1
$T77399 = -1						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 4
__Al$ = 28						; size = 4
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@V?$allocator@VPathArgument@Json@@@2@@stdext@@YAPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@0PAV12@AAV?$allocator@VPathArgument@Json@@@4@@Z PROC ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *,std::allocator<Json::PathArgument> >, COMDAT

; 819  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	ecx

; 820  : 	return (_STD _Uninit_copy(_CHECKED_BASE(_First),
; 821  : 		_CHECKED_BASE(_Last), _Dest, _Al,
; 822  : 		_STD _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T77399[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@AAPAVPathArgument@Json@@@Z ; std::_Ptr_cat<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *>
	add	esp, 8
	mov	BYTE PTR $T77400[ebp], al
	movzx	eax, BYTE PTR $T77399[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T77400[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >
	add	esp, 4
	push	eax
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@std@@YAPBVPathArgument@Json@@AAV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@0@@Z ; std::_Checked_base<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >
	add	esp, 4
	push	eax
	call	??$_Uninit_copy@PBVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@std@@YAPAVPathArgument@Json@@PBV12@0PAV12@AAV?$allocator@VPathArgument@Json@@@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Uninit_copy<Json::PathArgument const *,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 24					; 00000018H

; 823  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@V?$allocator@VPathArgument@Json@@@2@@stdext@@YAPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@0PAV12@AAV?$allocator@VPathArgument@Json@@@4@@Z ENDP ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$unchecked_uninitialized_copy@PAVPathArgument@Json@@PAV12@V?$allocator@VPathArgument@Json@@@std@@@stdext@@YAPAVPathArgument@Json@@PAV12@00AAV?$allocator@VPathArgument@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::PathArgument *,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 16					; 00000010H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@0PAV23@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Ptr$ = 24						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@0PAV23@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >, COMDAT
; _this$ = ecx

; 1138 : 		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1139 : 		{	// copy initializing [_First, _Last), using allocator
; 1140 : 		return (_STDEXT unchecked_uninitialized_copy(_First, _Last,
; 1141 : 			_Ptr, this->_Alval));

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$unchecked_uninitialized_copy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@PAVPathArgument@Json@@V?$allocator@VPathArgument@Json@@@2@@stdext@@YAPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@0PAV12@AAV?$allocator@VPathArgument@Json@@@4@@Z ; stdext::unchecked_uninitialized_copy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >,Json::PathArgument *,std::allocator<Json::PathArgument> >
	add	esp, 24					; 00000018H

; 1142 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
??$_Ucopy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@0PAV23@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>, COMDAT
; _this$ = ecx

; 120  : 		_Deque_const_iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Ranit@VErrorInfo@Reader@Json@@HPBV123@ABV123@@std@@QAE@XZ

; 121  : 			{	// construct with null deque pointer
; 122  : 			_Myoff = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 123  : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z PROC ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 327  : 		{	// construct with pointer _Ptr

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >

; 328  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ENDP ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>, COMDAT
; _this$ = ecx

; 375  : 	_Deque_iterator()

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>

; 376  : 		{	// construct with null vector pointer
; 377  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
__Block$ = -4						; size = 4
??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*, COMDAT
; _this$ = ecx

; 136  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	shr	ecx, 2
	mov	DWORD PTR __Block$[ebp], ecx

; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 3
	mov	DWORD PTR __Off$[ebp], eax

; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator@38
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@38:

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], edx
	jb	SHORT $LN2@operator@38
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@38:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN1@operator@38

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR __Block$[ebp]
	sub	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$[ebp], edx
$LN1@operator@38:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	edx, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR [edx+eax*4]

; 144  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77417 = -24						; size = 4
$T77416 = -20						; size = 4
$T77415 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0VErrorInfo@Reader@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Reader::ErrorInfo>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77417[ebp], eax
	mov	ecx, DWORD PTR $T77417[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77416[ebp], eax
	cmp	DWORD PTR $T77416[ebp], 0
	je	SHORT $LN3@Container_@5
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77416[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@5
$LN3@Container_@5:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@5:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77415[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77415[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z$0
__ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
tv133 = -32						; size = 4
_this$ = -28						; size = 4
$T77432 = -24						; size = 4
$T77431 = -20						; size = 4
$T77430 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 1
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z PROC ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 419  : 		{

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::_Container_base_aux
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??$?0PAVValue@Json@@@?$allocator@V_Aux_cont@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<std::_Aux_cont>::allocator<std::_Aux_cont><Json::Value *>

; 420  : 		_Myownedaux = new (_Alaux.allocate(1)) _Aux_cont(this);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?allocate@?$allocator@V_Aux_cont@std@@@std@@QAEPAV_Aux_cont@2@I@Z ; std::allocator<std::_Aux_cont>::allocate
	mov	DWORD PTR $T77432[ebp], eax
	mov	ecx, DWORD PTR $T77432[ebp]
	push	ecx
	push	4
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T77431[ebp], eax
	cmp	DWORD PTR $T77431[ebp], 0
	je	SHORT $LN3@Container_@6
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	mov	ecx, DWORD PTR $T77431[ebp]
	call	??0_Aux_cont@std@@QAE@QBV_Container_base_aux@1@@Z ; std::_Aux_cont::_Aux_cont
	mov	DWORD PTR tv133[ebp], eax
	jmp	SHORT $LN4@Container_@6
$LN3@Container_@6:
	mov	DWORD PTR tv133[ebp], 0
$LN4@Container_@6:
	mov	eax, DWORD PTR tv133[ebp]
	mov	DWORD PTR $T77430[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR $T77430[ebp]
	mov	DWORD PTR [ecx], edx

; 421  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Container_base_aux@std@@QAE@XZ	; std::_Container_base_aux::~_Container_base_aux
__ehhandler$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77446 = -80						; size = 28
$T77445 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen, COMDAT

; 1210 : 		{	// report length error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1211 : 		_THROW(length_error, "deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77446[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77446[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77445[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77445[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77446[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@3:

; 1212 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77446[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Make_iter, COMDAT
; _this$ = ecx

; 660  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 661  : 		return (iterator(_Where._Myptr, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Make_iter
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>, COMDAT
; _this$ = ecx

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>

; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=, COMDAT
; _this$ = ecx

; 198  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@operator@39
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@operator@39
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@operator@39:

; 200  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(
; 201  : 			_Myoff + _Off <= ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize &&
; 202  : 			_Myoff + _Off >= ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@operator@39
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [edi+24]
	add	ecx, DWORD PTR [eax+28]
	cmp	esi, ecx
	ja	SHORT $LN1@operator@39
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+24]
	jae	SHORT $LN3@operator@39
$LN1@operator@39:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@39:

; 203  : 		_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 204  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 205  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*, COMDAT
; _this$ = ecx

; 385  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*

; 387  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=, COMDAT
; _this$ = ecx

; 198  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	DWORD PTR _this$[ebp], ecx

; 199  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN5@operator@40
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN5@operator@40
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN5@operator@40:

; 200  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(
; 201  : 			_Myoff + _Off <= ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize &&
; 202  : 			_Myoff + _Off >= ((_Mydeque *)(this->_Getmycont()))->_Myoff);

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN3@operator@40
	mov	eax, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [eax+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [edi+24]
	add	ecx, DWORD PTR [eax+28]
	cmp	esi, ecx
	ja	SHORT $LN1@operator@40
	mov	edx, DWORD PTR _this$[ebp]
	mov	esi, DWORD PTR [edx+4]
	add	esi, DWORD PTR __Off$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	cmp	esi, DWORD PTR [eax+24]
	jae	SHORT $LN3@operator@40
$LN1@operator@40:
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@40:

; 203  : 		_Myoff += _Off;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 204  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 205  : 		}

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T77466 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 478  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77466[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >::_Container_base_aux_alloc_real<std::allocator<Json::Reader::ErrorInfo> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>

; 479  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77471 = -80						; size = 28
$T77470 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen, COMDAT

; 1210 : 		{	// report length error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1211 : 		_THROW(length_error, "deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77471[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77471[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77470[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77470[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77471[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@4:

; 1212 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77471[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 8
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 685  : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 686  : 		return (iterator(_Where._Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 687  : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T77483 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z PROC ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 478  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77483[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Container_base_aux_alloc_real@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >::_Container_base_aux_alloc_real<std::allocator<Json::Value *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>

; 479  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T77489 = -28						; size = 4
$T77488 = -24						; size = 4
$T77487 = -20						; size = 4
__Newmap$ = -16						; size = 4
__Myptr$ = -12						; size = 4
__Inc$ = -8						; size = 4
__Myboff$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap, COMDAT
; _this$ = ecx

; 1225 : 		{	// grow map by _Count pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1226 : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
	shr	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN6@Growmap

; 1227 : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@KAXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
$LN6@Growmap:

; 1228 : 
; 1229 : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	DWORD PTR __Inc$[ebp], eax

; 1230 : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	DWORD PTR __Inc$[ebp], 8
	jae	SHORT $LN5@Growmap

; 1231 : 			_Inc = _DEQUEMAPSIZ;

	mov	DWORD PTR __Inc$[ebp], 8
$LN5@Growmap:

; 1232 : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Inc$[ebp]
	jae	SHORT $LN4@Growmap
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
	shr	eax, 2
	sub	eax, DWORD PTR __Inc$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], eax
	ja	SHORT $LN4@Growmap

; 1233 : 			_Count = _Inc;

	mov	eax, DWORD PTR __Inc$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Growmap:

; 1234 : 		size_type _Myboff = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	shr	edx, 2
	mov	DWORD PTR __Myboff$[ebp], edx

; 1235 : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
	mov	DWORD PTR __Newmap$[ebp], eax

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;

	mov	edx, DWORD PTR __Myboff$[ebp]
	mov	eax, DWORD PTR __Newmap$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Myptr$[ebp], ecx

; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Myboff$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1240 : 		if (_Myboff <= _Count)

	mov	ecx, DWORD PTR __Myboff$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@Growmap

; 1241 : 			{	// increment greater than offset of initial block
; 1242 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map,
; 1243 : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1244 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 1245 : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	DWORD PTR $T77487[ebp], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR $T77487[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Myboff$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H

; 1246 : 			_STDEXT unchecked_uninitialized_fill_n(_Newmap, _Myboff,
; 1247 : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	mov	DWORD PTR $T77488[ebp], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR $T77488[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myboff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newmap$[ebp]
	push	edx
	call	??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H

; 1248 : 			}
; 1249 : 		else

	jmp	SHORT $LN2@Growmap
$LN3@Growmap:

; 1250 : 			{	// increment not greater than offset of initial block
; 1251 : 			_STDEXT unchecked_uninitialized_copy(_Map,
; 1252 : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H

; 1253 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Count,
; 1254 : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Newmap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	??$unchecked_uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1255 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count,
; 1256 : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	mov	DWORD PTR $T77489[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR $T77489[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAPAVValue@Json@@IPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@stdext@@YAXPAPAPAVValue@Json@@IABQAPAV12@AAV?$allocator@PAPAVValue@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Value * * *,unsigned int,Json::Value * *,std::allocator<Json::Value * *> >
	add	esp, 16					; 00000010H
$LN2@Growmap:

; 1257 : 			}
; 1258 : 
; 1259 : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@0AAV?$allocator@PAPAVValue@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Value * *> >
	add	esp, 12					; 0000000cH

; 1260 : 		if (_Map)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN1@Growmap

; 1261 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
$LN1@Growmap:

; 1262 : 
; 1263 : 		_Map = _Newmap;	// point at new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newmap$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1264 : 		_Mapsize += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1265 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
xdata$x	SEGMENT
__unwindtable$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ$0
__ehfuncinfo$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
_TEXT	SEGMENT
$T77493 = -80						; size = 28
$T77492 = -52						; size = 40
__$EHRec$ = -12						; size = 12
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen, COMDAT

; 1259 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 1260 : 		_THROW(length_error, "vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	lea	ecx, DWORD PTR $T77493[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T77493[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77492[ebp]
	call	??0length_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::length_error::length_error
	push	OFFSET __TI3?AVlength_error@std@@
	lea	ecx, DWORD PTR $T77492[ebp]
	push	ecx
	call	__CxxThrowException@8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77493[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@Xlen@5:

; 1261 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ$0:
	lea	ecx, DWORD PTR $T77493[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen
; Function compile flags: /Odtp
;	COMDAT ?erase@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@0@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
__Ptr$60616 = -20					; size = 4
__Last$ = -16						; size = 8
__First$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@0@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::erase, COMDAT
; _this$ = ecx

; 1028 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	mov	DWORD PTR _this$[ebp], ecx

; 1029 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Make_iter

; 1030 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Make_iter

; 1031 : 
; 1032 : 		if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@erase@2

; 1033 : 			{	// worth doing, copy down over hole
; 1034 : 
; 1035 :  #if _HAS_ITERATOR_DEBUGGING
; 1036 : 			if (_Last < _First || _First._Mycont != this
; 1037 : 				|| _First._Myptr < _Myfirst || _Mylast < _Last._Myptr)
; 1038 : 				_DEBUG_ERROR("vector erase iterator outside range");
; 1039 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1040 : 				_VEC_ITER_BASE(_First));
; 1041 : 			_Orphan_range(_First._Myptr, _Mylast);
; 1042 : 
; 1043 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1044 : 			pointer _Ptr = _STDEXT unchecked_copy(_VEC_ITER_BASE(_Last), _Mylast,
; 1045 : 				_VEC_ITER_BASE(_First));

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp+4]
	push	edx
	call	??$unchecked_copy@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ; stdext::unchecked_copy<Json::PathArgument *,Json::PathArgument *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$60616[ebp], eax

; 1046 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1047 : 
; 1048 : 			_Destroy(_Ptr, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$60616[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1049 : 			_Mylast = _Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ptr$60616[ebp]
	mov	DWORD PTR [eax+16], ecx
$LN1@erase@2:

; 1050 : 			}
; 1051 : #if _HAS_ITERATOR_DEBUGGING
; 1052 :         return (iterator(_First._Myptr, this));
; 1053 : #else
; 1054 : 		return (_First);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __First$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1055 : #endif
; 1056 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@0@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end, COMDAT
; _this$ = ecx

; 650  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 651  : 		return (iterator(_Mylast, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 652  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin, COMDAT
; _this$ = ecx

; 640  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		return (iterator(_Myfirst, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@PAVPathArgument@Json@@PBV_Container_base_aux@1@@Z ; std::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_iterator<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 642  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??H?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+, COMDAT
; _this$ = ecx

; 208  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 210  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??H?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+, COMDAT
; _this$ = ecx

; 208  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 209  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 210  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 211  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T77513 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct allocator and base from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77513[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_map@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_map<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>

; 501  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -32						; size = 4
$T77519 = -28						; size = 4
$T77518 = -24						; size = 4
$T77517 = -20						; size = 4
__Newmap$ = -16						; size = 4
__Myptr$ = -12						; size = 4
__Inc$ = -8						; size = 4
__Myboff$ = -4						; size = 4
__Count$ = 8						; size = 4
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap, COMDAT
; _this$ = ecx

; 1225 : 		{	// grow map by _Count pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	mov	DWORD PTR _this$[ebp], ecx

; 1226 : 		if (max_size() / _DEQUESIZ - _Mapsize < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN6@Growmap@2

; 1227 : 			_Xlen();	// result too long

	call	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@KAXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
$LN6@Growmap@2:

; 1228 : 
; 1229 : 		size_type _Inc = _Mapsize / 2;	// try to grow by 50%

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shr	eax, 1
	mov	DWORD PTR __Inc$[ebp], eax

; 1230 : 		if (_Inc < _DEQUEMAPSIZ)

	cmp	DWORD PTR __Inc$[ebp], 8
	jae	SHORT $LN5@Growmap@2

; 1231 : 			_Inc = _DEQUEMAPSIZ;

	mov	DWORD PTR __Inc$[ebp], 8
$LN5@Growmap@2:

; 1232 : 		if (_Count < _Inc && _Mapsize <= max_size() / _DEQUESIZ - _Inc)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, DWORD PTR __Inc$[ebp]
	jae	SHORT $LN4@Growmap@2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
	sub	eax, DWORD PTR __Inc$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+20], eax
	ja	SHORT $LN4@Growmap@2

; 1233 : 			_Count = _Inc;

	mov	eax, DWORD PTR __Inc$[ebp]
	mov	DWORD PTR __Count$[ebp], eax
$LN4@Growmap@2:

; 1234 : 		size_type _Myboff = _Myoff / _DEQUESIZ;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR __Myboff$[ebp], edx

; 1235 : 		_Mapptr _Newmap = this->_Almap.allocate(_Mapsize + _Count);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
	mov	DWORD PTR __Newmap$[ebp], eax

; 1236 : 		_Mapptr _Myptr = _Newmap + _Myboff;

	mov	edx, DWORD PTR __Myboff$[ebp]
	mov	eax, DWORD PTR __Newmap$[ebp]
	lea	ecx, DWORD PTR [eax+edx*4]
	mov	DWORD PTR __Myptr$[ebp], ecx

; 1237 : 
; 1238 : 		_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Myboff,
; 1239 : 			_Map + _Mapsize, _Myptr, this->_Almap);	// copy initial to end

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	edx, DWORD PTR __Myboff$[ebp]
	lea	eax, DWORD PTR [ecx+edx*4]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1240 : 		if (_Myboff <= _Count)

	mov	ecx, DWORD PTR __Myboff$[ebp]
	cmp	ecx, DWORD PTR __Count$[ebp]
	ja	SHORT $LN3@Growmap@2

; 1241 : 			{	// increment greater than offset of initial block
; 1242 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map,
; 1243 : 				_Map + _Myboff, _Myptr, this->_Almap);	// copy rest of old

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	call	??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1244 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count - _Myboff,
; 1245 : 				(_Tptr)0, this->_Almap);	// clear suffix of new

	mov	DWORD PTR $T77517[ebp], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	lea	edx, DWORD PTR $T77517[ebp]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Myboff$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	call	??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H

; 1246 : 			_STDEXT unchecked_uninitialized_fill_n(_Newmap, _Myboff,
; 1247 : 				(_Tptr)0, this->_Almap);	// clear prefix of new

	mov	DWORD PTR $T77518[ebp], 0
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	lea	eax, DWORD PTR $T77518[ebp]
	push	eax
	mov	ecx, DWORD PTR __Myboff$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Newmap$[ebp]
	push	edx
	call	??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H

; 1248 : 			}
; 1249 : 		else

	jmp	SHORT $LN2@Growmap@2
$LN3@Growmap@2:

; 1250 : 			{	// increment not greater than offset of initial block
; 1251 : 			_STDEXT unchecked_uninitialized_copy(_Map,
; 1252 : 				_Map + _Count, _Myptr, this->_Almap);	// copy more old

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	mov	ecx, DWORD PTR __Myptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H

; 1253 : 			_Myptr = _STDEXT unchecked_uninitialized_copy(_Map + _Count,
; 1254 : 				_Map + _Myboff, _Newmap, this->_Almap);	// copy rest of old

	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 8
	push	edx
	mov	eax, DWORD PTR __Newmap$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	call	??$unchecked_uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR __Myptr$[ebp], eax

; 1255 : 			_STDEXT unchecked_uninitialized_fill_n(_Myptr, _Count,
; 1256 : 				(_Tptr)0, this->_Almap);	// clear rest to initial block

	mov	DWORD PTR $T77519[ebp], 0
	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 8
	push	eax
	lea	ecx, DWORD PTR $T77519[ebp]
	push	ecx
	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	mov	eax, DWORD PTR __Myptr$[ebp]
	push	eax
	call	??$unchecked_uninitialized_fill_n@PAPAVErrorInfo@Reader@Json@@IPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@stdext@@YAXPAPAVErrorInfo@Reader@Json@@IABQAV123@AAV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@Z ; stdext::unchecked_uninitialized_fill_n<Json::Reader::ErrorInfo * *,unsigned int,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 16					; 00000010H
$LN2@Growmap@2:

; 1257 : 			}
; 1258 : 
; 1259 : 		_Destroy_range(_Map + _Myboff, _Map + _Mapsize, this->_Almap);

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	lea	eax, DWORD PTR [edx+eax*4]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Myboff$[ebp]
	lea	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	call	??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAV?$allocator@PAVErrorInfo@Reader@Json@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *> >
	add	esp, 12					; 0000000cH

; 1260 : 		if (_Map)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+16], 0
	je	SHORT $LN1@Growmap@2

; 1261 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for old

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
$LN1@Growmap@2:

; 1262 : 
; 1263 : 		_Map = _Newmap;	// point at new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newmap$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 1264 : 		_Mapsize += _Count;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, DWORD PTR __Count$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], ecx

; 1265 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 675  : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 676  : 		return (iterator(_Myoff + _Mysize, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+28]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 677  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 665  : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 666  : 		return (iterator(_Myoff, this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 667  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T77526 = -4						; size = 4
__Al$ = 8						; size = 1
??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z PROC ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct allocator and base from _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77526[ebp], esp
	lea	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_map@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_map<Json::Value *,std::allocator<Json::Value *> >::_Deque_map<Json::Value *,std::allocator<Json::Value *> >
	lea	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>

; 501  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$60188 = -4					; size = 4
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy, COMDAT
; _this$ = ecx

; 1268 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
$LN6@Tidy@4:

; 1269 : 		while (!empty())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN5@Tidy@4

; 1270 : 			pop_back();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
	jmp	SHORT $LN6@Tidy@4
$LN5@Tidy@4:

; 1271 : 		for (size_type _Count = _Mapsize; 0 < _Count; )

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	mov	DWORD PTR __Count$60188[ebp], edx
$LN4@Tidy@4:
	cmp	DWORD PTR __Count$60188[ebp], 0
	jbe	SHORT $LN3@Tidy@4

; 1272 : 			{	// free storage for a block and destroy pointer
; 1273 : 			if (*(_Map + --_Count) != 0)

	mov	eax, DWORD PTR __Count$60188[ebp]
	sub	eax, 1
	mov	DWORD PTR __Count$60188[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$60188[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	je	SHORT $LN2@Tidy@4

; 1274 : 				this->_Alval.deallocate(*(_Map + _Count), _DEQUESIZ);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Count$60188[ebp]
	mov	ecx, DWORD PTR [edx+eax*4]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate
$LN2@Tidy@4:

; 1275 : 			this->_Almap.destroy(_Map + _Count);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	ecx, DWORD PTR __Count$60188[ebp]
	lea	edx, DWORD PTR [eax+ecx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?destroy@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value * *>::destroy

; 1276 : 			}

	jmp	SHORT $LN4@Tidy@4
$LN3@Tidy@4:

; 1277 : 
; 1278 : 		if (_Map)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+16], 0
	je	SHORT $LN1@Tidy@4

; 1279 : 			this->_Almap.deallocate(_Map, _Mapsize);	// free storage for map

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+20]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
$LN1@Tidy@4:

; 1280 : 		_Mapsize = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1281 : 		_Map = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0

; 1282 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear, COMDAT
; _this$ = ecx

; 1085 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1086 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1087 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$ = -8						; size = 4
__Newoff$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = ecx

; 843  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 844  : 
; 845  :  #if _HAS_ITERATOR_DEBUGGING
; 846  : 		this->_Orphan_all();
; 847  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 848  : 
; 849  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 850  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN3@push_back@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 4
	shr	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN3@push_back@2

; 851  : 			_Growmap(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN3@push_back@2:

; 852  : 		size_type _Newoff = _Myoff + _Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR __Newoff$[ebp], eax

; 853  : 		size_type _Block = _Newoff / _DEQUESIZ;

	mov	edx, DWORD PTR __Newoff$[ebp]
	shr	edx, 2
	mov	DWORD PTR __Block$[ebp], edx

; 854  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN2@push_back@2

; 855  : 			_Block -= _Mapsize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Block$[ebp]
	sub	eax, DWORD PTR [edx+20]
	mov	DWORD PTR __Block$[ebp], eax
$LN2@push_back@2:

; 856  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN1@push_back@2

; 857  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_back@2:

; 858  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ; std::allocator<Json::Value *>::construct

; 859  : 		++_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 860  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T77536 = -4						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 554  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77536[ebp], esp
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ; std::allocator<Json::Value *>::allocator<Json::Value *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 555  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy, COMDAT
; _this$ = ecx

; 1123 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1124 : 		if (_Myfirst != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+12], 0
	je	SHORT $LN1@Tidy@5

; 1125 : 			{	// something to free, destroy and deallocate it
; 1126 : 
; 1127 :  #if _HAS_ITERATOR_DEBUGGING
; 1128 : 			this->_Orphan_all();
; 1129 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1130 : 
; 1131 : 			_Destroy(_Myfirst, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 1132 : 			this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+20]
	sub	ecx, DWORD PTR [eax+12]
	mov	eax, ecx
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
$LN1@Tidy@5:

; 1133 : 			}
; 1134 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 0

; 1135 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy, COMDAT
; _this$ = ecx

; 1102 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1103 : 		_Myfirst = 0, _Mylast = 0, _Myend = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0

; 1104 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN4@Buy@3

; 1105 : 			return (false);

	xor	al, al
	jmp	SHORT $LN5@Buy@3
	jmp	SHORT $LN3@Buy@3
$LN4@Buy@3:

; 1106 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN2@Buy@3

; 1107 : 			_Xlen();	// result too long

	call	?_Xlen@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@KAXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Xlen

; 1108 : 		else

	jmp	SHORT $LN3@Buy@3
$LN2@Buy@3:

; 1109 : 			{	// nonempty array, allocate storage
; 1110 : 			_Myfirst = this->_Alval.allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?allocate@?$allocator@VPathArgument@Json@@@std@@QAEPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+12], eax

; 1111 : 			_Mylast = _Myfirst;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	mov	DWORD PTR [edx+16], ecx

; 1112 : 			_Myend = _Myfirst + _Capacity;

	mov	edx, DWORD PTR __Capacity$[ebp]
	imul	edx, 36					; 00000024H
	mov	eax, DWORD PTR _this$[ebp]
	add	edx, DWORD PTR [eax+12]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], edx
$LN3@Buy@3:

; 1113 : 			}
; 1114 : 		return (true);

	mov	al, 1
$LN5@Buy@3:

; 1115 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?clear@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -44						; size = 4
$T77548 = -40						; size = 8
$T77547 = -32						; size = 8
$T77546 = -24						; size = 8
$T77545 = -16						; size = 8
$T77544 = -8						; size = 8
?clear@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXXZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::clear, COMDAT
; _this$ = ecx

; 1059 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	DWORD PTR _this$[ebp], ecx

; 1060 : 		erase(begin(), end());

	lea	eax, DWORD PTR $T77545[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77544[ebp], ecx
	mov	DWORD PTR $T77544[ebp+4], edx
	lea	eax, DWORD PTR $T77547[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T77546[ebp], ecx
	mov	DWORD PTR $T77546[ebp+4], edx
	mov	eax, DWORD PTR $T77544[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T77544[ebp]
	push	ecx
	mov	edx, DWORD PTR $T77546[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T77546[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77548[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE?AV?$_Vector_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::erase

; 1061 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?clear@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXXZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::clear
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator++, COMDAT
; _this$ = ecx

; 153  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 154  : 		_SCL_SECURE_TRAITS_VALIDATE(this->_Has_container());

	mov	eax, 1
	test	eax, eax
	je	SHORT $LN4@operator@41
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@operator@41
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN4@operator@41:

; 155  : 		_SCL_SECURE_TRAITS_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	edx, 1
	test	edx, edx
	je	SHORT $LN2@operator@41
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [esi+24]
	add	ecx, DWORD PTR [eax+28]
	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+4], ecx
	jb	SHORT $LN2@operator@41
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@41:

; 156  : 
; 157  :  #if _HAS_ITERATOR_DEBUGGING
; 158  : 		if (this->_Mycont == 0
; 159  : 			|| ((_Mydeque *)this->_Mycont)->_Myoff
; 160  : 				+ ((_Mydeque *)this->_Mycont)->_Mysize == _Myoff)
; 161  : 			_DEBUG_ERROR("deque iterator not incrementable");
; 162  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 163  : 
; 164  : 		++_Myoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 165  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 166  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Off$ = -8						; size = 4
__Block$ = -4						; size = 4
??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*, COMDAT
; _this$ = ecx

; 136  : 			{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 137  : 			size_type _Block = _Myoff / _DEQUESIZ;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR __Block$[ebp], ecx

; 138  : 			size_type _Off = _Myoff & (_DEQUESIZ - 1);	// assume power of 2

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+4]
	and	eax, 0
	mov	DWORD PTR __Off$[ebp], eax

; 139  : 			_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator@42
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN3@operator@42:

; 140  : 			_SCL_SECURE_VALIDATE_RANGE(_Myoff < ((_Mydeque *)(this->_Getmycont()))->_Myoff + ((_Mydeque *)(this->_Getmycont()))->_Mysize);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR [esi+24]
	add	edx, DWORD PTR [eax+28]
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+4], edx
	jb	SHORT $LN2@operator@42
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@42:

; 141  : 			if (static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize <= _Block)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN1@operator@42

; 142  : 				_Block -= static_cast<const _Mydeque *>(this->_Getmycont())->_Mapsize;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	edx, DWORD PTR __Block$[ebp]
	sub	edx, DWORD PTR [eax+20]
	mov	DWORD PTR __Block$[ebp], edx
$LN1@operator@42:

; 143  : 			return ((static_cast<const _Mydeque *>(this->_Getmycont())->_Map)[_Block][_Off]);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	imul	ecx, 44					; 0000002cH
	mov	edx, DWORD PTR __Block$[ebp]
	add	ecx, DWORD PTR [eax+edx*4]
	mov	eax, ecx

; 144  : 			}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Block$ = -8						; size = 4
__Newoff$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back, COMDAT
; _this$ = ecx

; 843  : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 844  : 
; 845  :  #if _HAS_ITERATOR_DEBUGGING
; 846  : 		this->_Orphan_all();
; 847  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 848  : 
; 849  : 		if ((_Myoff + _Mysize) % _DEQUESIZ == 0
; 850  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN3@push_back@3
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN3@push_back@3

; 851  : 			_Growmap(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN3@push_back@3:

; 852  : 		size_type _Newoff = _Myoff + _Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+28]
	mov	DWORD PTR __Newoff$[ebp], eax

; 853  : 		size_type _Block = _Newoff / _DEQUESIZ;

	mov	edx, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR __Block$[ebp], edx

; 854  : 		if (_Mapsize <= _Block)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	cmp	ecx, DWORD PTR __Block$[ebp]
	ja	SHORT $LN2@push_back@3

; 855  : 			_Block -= _Mapsize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Block$[ebp]
	sub	eax, DWORD PTR [edx+20]
	mov	DWORD PTR __Block$[ebp], eax
$LN2@push_back@3:

; 856  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN1@push_back@3

; 857  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_back@3:

; 858  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct

; 859  : 		++_Mysize;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	add	edx, 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], edx

; 860  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T77557 = -4						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 554  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77557[ebp], esp
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+20], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+28], 0

; 555  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 640  : 		{	// destroy the deque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 641  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 642  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stack
_TEXT	ENDS
;	COMDAT ?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val$ = 8						; size = 4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push, COMDAT
; _this$ = ecx

; 57   : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 58   : 		c.push_back(_Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back

; 59   : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 28   : 		{	// construct with empty container

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >

; 29   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
_TEXT	ENDS
;	COMDAT ??4?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Ptr$58449 = -8					; size = 4
__Ptr$58439 = -4					; size = 4
__Right$ = 8						; size = 4
??4?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::operator=, COMDAT
; _this$ = ecx

; 563  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 564  : 		if (this != &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	je	$LN9@operator@43

; 565  : 			{	// worth doing
; 566  : 
; 567  :  #if _HAS_ITERATOR_DEBUGGING
; 568  : 			this->_Orphan_all();
; 569  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 570  : 
; 571  : 			if (_Right.size() == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	test	eax, eax
	jne	SHORT $LN8@operator@43

; 572  : 				clear();	// new sequence empty, erase existing sequence

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::clear
	jmp	$LN9@operator@43
$LN8@operator@43:

; 573  : 			else if (_Right.size() <= size())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	cmp	esi, eax
	ja	SHORT $LN6@operator@43

; 574  : 				{	// enough elements, copy new and destroy old
; 575  : 				pointer _Ptr = _STDEXT unchecked_copy(_Right._Myfirst, _Right._Mylast,
; 576  : 					_Myfirst);	// copy new

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+12]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ; stdext::unchecked_copy<Json::PathArgument *,Json::PathArgument *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$58439[ebp], eax

; 577  : 				_Destroy(_Ptr, _Mylast);	// destroy old

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Ptr$58439[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 578  : 				_Mylast = _Myfirst + _Right.size();

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
	jmp	$LN9@operator@43
$LN6@operator@43:

; 579  : 				}
; 580  : 			else if (_Right.size() <= capacity())

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::capacity
	cmp	esi, eax
	ja	SHORT $LN4@operator@43

; 581  : 				{	// enough room, copy and construct new
; 582  : 				pointer _Ptr = _Right._Myfirst + size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	imul	eax, 36					; 00000024H
	mov	ecx, DWORD PTR __Right$[ebp]
	add	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR __Ptr$58449[ebp], eax

; 583  : 				_STDEXT unchecked_copy(_Right._Myfirst, _Ptr, _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Ptr$58449[ebp]
	push	ecx
	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	call	??$unchecked_copy@PAVPathArgument@Json@@PAV12@@stdext@@YAPAVPathArgument@Json@@PAV12@00@Z ; stdext::unchecked_copy<Json::PathArgument *,Json::PathArgument *>
	add	esp, 12					; 0000000cH

; 584  : 				_Mylast = _Ucopy(_Ptr, _Right._Mylast, _Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR __Ptr$58449[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], eax

; 585  : 				}
; 586  : 			else

	jmp	$LN9@operator@43
$LN4@operator@43:

; 587  : 				{	// not enough room, allocate new array and construct new
; 588  : 				if (_Myfirst != 0)

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+12], 0
	je	SHORT $LN2@operator@43

; 589  : 					{	// discard old array
; 590  : 					_Destroy(_Myfirst, _Mylast);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXPAVPathArgument@Json@@0@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Destroy

; 591  : 					this->_Alval.deallocate(_Myfirst, _Myend - _Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	sub	eax, DWORD PTR [edx+12]
	cdq
	mov	ecx, 36					; 00000024H
	idiv	ecx
	push	eax
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	call	?deallocate@?$allocator@VPathArgument@Json@@@std@@QAEXPAVPathArgument@Json@@I@Z ; std::allocator<Json::PathArgument>::deallocate
$LN2@operator@43:

; 592  : 					}
; 593  : 				if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@operator@43

; 594  : 					_Mylast = _Ucopy(_Right._Myfirst, _Right._Mylast,
; 595  : 						_Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	push	edx
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@PAVPathArgument@Json@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@PAV23@00@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<Json::PathArgument *>
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+16], eax
$LN9@operator@43:

; 596  : 				}
; 597  : 			}
; 598  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 599  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 559  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy

; 560  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
__ehhandler$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z$3
__ehfuncinfo$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv69 = -44						; size = 4
_this$ = -40						; size = 4
$T77581 = -36						; size = 8
$T77580 = -28						; size = 8
$T77579 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >, COMDAT
; _this$ = ecx

; 500  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 8
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T77579[ebp], esp
	push	eax
	call	??0?$allocator@VPathArgument@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::PathArgument>::allocator<Json::PathArgument>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE@V?$allocator@VPathArgument@Json@@@1@@Z ; std::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >::_Vector_val<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 501  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBEIXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAE_NI@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Buy
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@vector@6

; 502  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 503  : 			_Mylast = _Ucopy(_Right.begin(), _Right.end(), _Myfirst);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+12]
	push	eax
	lea	ecx, DWORD PTR $T77580[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR $T77581[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QBE?AV?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@2@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::begin
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEPAVPathArgument@Json@@V?$_Vector_const_iterator@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@1@0PAV23@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Ucopy<std::_Vector_const_iterator<Json::PathArgument,std::allocator<Json::PathArgument> > >
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR tv69[ebp]
	mov	DWORD PTR [ecx+16], edx
	jmp	SHORT $LN5@vector@6
__catch$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z$0:

; 504  : 			_CATCH_ALL
; 505  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@IAEXXZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::_Tidy

; 506  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 507  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN3@vector@6
	ret	0
$LN5@vector@6:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN3@vector@6:

; 508  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector@6:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_val@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ
__ehhandler$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
PUBLIC	__$ArrayPad$
PUBLIC	?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormattedErrorMessages
;	COMDAT xdata$x
; File e:\newggdevelop\client\ggjsoncpp\json_reader.cpp
xdata$x	SEGMENT
__unwindtable$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$9
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	02H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2
	DD	03H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4
	DD	05H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6
	DD	07H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7
	DD	08H
	DD	FLAT:__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8
__ehfuncinfo$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	0aH
	DD	FLAT:__unwindtable$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
tv193 = -360						; size = 4
tv205 = -356						; size = 4
tv191 = -352						; size = 4
tv204 = -348						; size = 4
tv189 = -344						; size = 4
tv203 = -340						; size = 4
tv187 = -336						; size = 4
tv202 = -332						; size = 4
tv185 = -328						; size = 4
tv201 = -324						; size = 4
tv183 = -320						; size = 4
tv200 = -316						; size = 4
tv181 = -312						; size = 4
tv199 = -308						; size = 4
tv179 = -304						; size = 4
tv65 = -300						; size = 4
_this$ = -296						; size = 4
$T77618 = -292						; size = 4
$T77607 = -288						; size = 28
$T77606 = -260						; size = 28
$T77605 = -232						; size = 28
$T77604 = -204						; size = 28
$T77603 = -176						; size = 28
$T77602 = -148						; size = 28
$T77601 = -120						; size = 28
$T77600 = -92						; size = 28
$T77599 = -64						; size = 8
_error$56986 = -56					; size = 4
_itError$56980 = -52					; size = 8
_formattedMessage$ = -44				; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Reader::getFormattedErrorMessages, COMDAT
; _this$ = ecx

; 893  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 348				; 0000015cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T77618[ebp], 0

; 894  :    std::string formattedMessage;

	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 895  :    for ( Errors::const_iterator itError = errors_.begin();

	lea	eax, DWORD PTR _itError$56980[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	jmp	SHORT $LN4@getFormatt
$LN3@getFormatt:

; 896  :          itError != errors_.end();
; 897  :          ++itError )

	lea	ecx, DWORD PTR _itError$56980[ebp]
	call	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator++
$LN4@getFormatt:
	lea	ecx, DWORD PTR $T77599[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	push	eax
	lea	ecx, DWORD PTR _itError$56980[ebp]
	call	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator!=
	movzx	edx, al
	test	edx, edx
	je	$LN2@getFormatt

; 898  :    {
; 899  :       const ErrorInfo &error = *itError;

	lea	ecx, DWORD PTR _itError$56980[ebp]
	call	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
	mov	DWORD PTR _error$56986[ebp], eax

; 900  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	eax, DWORD PTR _error$56986[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	edx, DWORD PTR $T77600[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv179[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv179[ebp]
	push	ecx
	push	OFFSET ??_C@_02KAOAMBHJ@?$CK?5?$AA@
	lea	edx, DWORD PTR $T77601[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv199[ebp], eax
	mov	eax, DWORD PTR tv199[ebp]
	mov	DWORD PTR tv181[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR tv181[ebp]
	push	ecx
	lea	edx, DWORD PTR $T77602[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv200[ebp], eax
	mov	eax, DWORD PTR tv200[ebp]
	mov	DWORD PTR tv183[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv183[ebp]
	push	ecx
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T77602[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T77601[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T77600[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 901  :       formattedMessage += "  " + error.message_ + "\n";

	mov	edx, DWORD PTR _error$56986[ebp]
	add	edx, 12					; 0000000cH
	push	edx
	push	OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
	lea	eax, DWORD PTR $T77603[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv201[ebp], eax
	mov	ecx, DWORD PTR tv201[ebp]
	mov	DWORD PTR tv185[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	edx, DWORD PTR tv185[ebp]
	push	edx
	lea	eax, DWORD PTR $T77604[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv202[ebp], eax
	mov	ecx, DWORD PTR tv202[ebp]
	mov	DWORD PTR tv187[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv187[ebp]
	push	edx
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T77604[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T77603[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 902  :       if ( error.extra_ )

	mov	eax, DWORD PTR _error$56986[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	$LN1@getFormatt

; 903  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	ecx, DWORD PTR _error$56986[ebp]
	mov	edx, DWORD PTR [ecx+40]
	push	edx
	lea	eax, DWORD PTR $T77605[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	mov	DWORD PTR tv203[ebp], eax
	mov	ecx, DWORD PTR tv203[ebp]
	mov	DWORD PTR tv189[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR tv189[ebp]
	push	edx
	push	OFFSET ??_C@_04JBAOJHKB@See?5?$AA@
	lea	eax, DWORD PTR $T77606[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv204[ebp], eax
	mov	ecx, DWORD PTR tv204[ebp]
	mov	DWORD PTR tv191[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	OFFSET ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
	mov	edx, DWORD PTR tv191[ebp]
	push	edx
	lea	eax, DWORD PTR $T77607[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv205[ebp], eax
	mov	ecx, DWORD PTR tv205[ebp]
	mov	DWORD PTR tv193[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	edx, DWORD PTR tv193[ebp]
	push	edx
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T77607[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T77606[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T77605[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@getFormatt:

; 904  :    }

	jmp	$LN3@getFormatt
$LN2@getFormatt:

; 905  :    return formattedMessage;

	lea	eax, DWORD PTR _formattedMessage$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T77618[ebp]
	or	ecx, 1
	mov	DWORD PTR $T77618[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 906  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	lea	ecx, DWORD PTR _formattedMessage$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	lea	ecx, DWORD PTR $T77600[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2:
	lea	ecx, DWORD PTR $T77601[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3:
	lea	ecx, DWORD PTR $T77602[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4:
	lea	ecx, DWORD PTR $T77603[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5:
	lea	ecx, DWORD PTR $T77604[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6:
	lea	ecx, DWORD PTR $T77605[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7:
	lea	ecx, DWORD PTR $T77606[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8:
	lea	ecx, DWORD PTR $T77607[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$9:
	mov	eax, DWORD PTR $T77618[ebp]
	and	eax, 1
	je	$LN17@getFormatt
	and	DWORD PTR $T77618[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN17@getFormatt:
	ret	0
__ehhandler$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-352]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Reader::getFormattedErrorMessages
PUBLIC	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
; Function compile flags: /Odtp
;	COMDAT ?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T77629 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Reader::getFormatedErrorMessages, COMDAT
; _this$ = ecx

; 886  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T77629[ebp], 0

; 887  :     return getFormattedErrorMessages();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormattedErrorMessages
	mov	ecx, DWORD PTR $T77629[ebp]
	or	ecx, 1
	mov	DWORD PTR $T77629[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 888  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Reader::getFormatedErrorMessages
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0
__ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
_TEXT	SEGMENT
_this$ = -68						; size = 4
$T77634 = -61						; size = 1
_info$ = -60						; size = 44
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_extra$ = 16						; size = 4
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z PROC ; Json::Reader::addError, COMDAT
; _this$ = ecx

; 785  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 786  :    ErrorInfo info;

	lea	ecx, DWORD PTR _info$[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 787  :    info.token_ = token;

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _info$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _info$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _info$[ebp+8], eax

; 788  :    info.message_ = message;

	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _info$[ebp+12]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 789  :    info.extra_ = extra;

	mov	edx, DWORD PTR _extra$[ebp]
	mov	DWORD PTR _info$[ebp+40], edx

; 790  :    errors_.push_back( info );

	lea	eax, DWORD PTR _info$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back

; 791  :    return false;

	mov	BYTE PTR $T77634[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _info$[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	mov	al, BYTE PTR $T77634[ebp]

; 792  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR _info$[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ENDP ; Json::Reader::addError
PUBLIC	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T77647 = -80						; size = 28
$T77646 = -49						; size = 1
$T77645 = -48						; size = 28
$T77644 = -18						; size = 1
_c$56758 = -17						; size = 1
_index$56754 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeEscapeSequence, COMDAT
; _this$ = ecx

; 760  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 761  :    if ( end - current < 4 )

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR _end$[ebp]
	sub	ecx, DWORD PTR [eax]
	cmp	ecx, 4
	jge	SHORT $LN10@decodeUnic

; 762  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	push	OFFSET ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T77645[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _current$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T77645[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T77644[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77645[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T77644[ebp]
	jmp	$LN11@decodeUnic
$LN10@decodeUnic:

; 763  :    unicode = 0;

	mov	eax, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [eax], 0

; 764  :    for ( int index =0; index < 4; ++index )

	mov	DWORD PTR _index$56754[ebp], 0
	jmp	SHORT $LN9@decodeUnic
$LN8@decodeUnic:
	mov	ecx, DWORD PTR _index$56754[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$56754[ebp], ecx
$LN9@decodeUnic:
	cmp	DWORD PTR _index$56754[ebp], 4
	jge	$LN7@decodeUnic

; 765  :    {
; 766  :       Char c = *current++;

	mov	edx, DWORD PTR _current$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _c$56758[ebp], cl
	mov	edx, DWORD PTR _current$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [ecx], eax

; 767  :       unicode *= 16;

	mov	edx, DWORD PTR _unicode$[ebp]
	mov	eax, DWORD PTR [edx]
	shl	eax, 4
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [ecx], eax

; 768  :       if ( c >= '0'  &&  c <= '9' )

	movsx	edx, BYTE PTR _c$56758[ebp]
	cmp	edx, 48					; 00000030H
	jl	SHORT $LN6@decodeUnic
	movsx	eax, BYTE PTR _c$56758[ebp]
	cmp	eax, 57					; 00000039H
	jg	SHORT $LN6@decodeUnic

; 769  :          unicode += c - '0';

	movsx	ecx, BYTE PTR _c$56758[ebp]
	mov	edx, DWORD PTR _unicode$[ebp]
	mov	eax, DWORD PTR [edx]
	lea	ecx, DWORD PTR [ecx+eax-48]
	mov	edx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [edx], ecx
	jmp	$LN5@decodeUnic
$LN6@decodeUnic:

; 770  :       else if ( c >= 'a'  &&  c <= 'f' )

	movsx	eax, BYTE PTR _c$56758[ebp]
	cmp	eax, 97					; 00000061H
	jl	SHORT $LN4@decodeUnic
	movsx	ecx, BYTE PTR _c$56758[ebp]
	cmp	ecx, 102				; 00000066H
	jg	SHORT $LN4@decodeUnic

; 771  :          unicode += c - 'a' + 10;

	movsx	edx, BYTE PTR _c$56758[ebp]
	mov	eax, DWORD PTR _unicode$[ebp]
	mov	ecx, DWORD PTR [eax]
	lea	edx, DWORD PTR [edx+ecx-87]
	mov	eax, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN5@decodeUnic
$LN4@decodeUnic:

; 772  :       else if ( c >= 'A'  &&  c <= 'F' )

	movsx	ecx, BYTE PTR _c$56758[ebp]
	cmp	ecx, 65					; 00000041H
	jl	SHORT $LN2@decodeUnic
	movsx	edx, BYTE PTR _c$56758[ebp]
	cmp	edx, 70					; 00000046H
	jg	SHORT $LN2@decodeUnic

; 773  :          unicode += c - 'A' + 10;

	movsx	eax, BYTE PTR _c$56758[ebp]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx-55]
	mov	ecx, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [ecx], eax

; 774  :       else

	jmp	SHORT $LN5@decodeUnic
$LN2@decodeUnic:

; 775  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	push	OFFSET ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T77647[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _current$[ebp]
	mov	eax, DWORD PTR [edx]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T77647[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T77646[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77647[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T77646[ebp]
	jmp	SHORT $LN11@decodeUnic
$LN5@decodeUnic:

; 776  :    }

	jmp	$LN8@decodeUnic
$LN7@decodeUnic:

; 777  :    return true;

	mov	al, 1
$LN11@decodeUnic:

; 778  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T77645[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T77647[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeEscapeSequence
PUBLIC	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
__ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T77661 = -80						; size = 28
$T77660 = -49						; size = 1
$T77659 = -48						; size = 28
$T77658 = -17						; size = 1
_surrogatePair$56735 = -16				; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeCodePoint, COMDAT
; _this$ = ecx

; 730  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 731  : 
; 732  :    if ( !decodeUnicodeEscapeSequence( token, current, end, unicode ) )

	mov	eax, DWORD PTR _unicode$[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@decodeUnic@2

; 733  :       return false;

	xor	al, al
	jmp	$LN8@decodeUnic@2
$LN7@decodeUnic@2:

; 734  :    if (unicode >= 0xD800 && unicode <= 0xDBFF)

	mov	edx, DWORD PTR _unicode$[ebp]
	cmp	DWORD PTR [edx], 55296			; 0000d800H
	jb	$LN6@decodeUnic@2
	mov	eax, DWORD PTR _unicode$[ebp]
	cmp	DWORD PTR [eax], 56319			; 0000dbffH
	ja	$LN6@decodeUnic@2

; 735  :    {
; 736  :       // surrogate pairs
; 737  :       if (end - current < 6)

	mov	ecx, DWORD PTR _current$[ebp]
	mov	edx, DWORD PTR _end$[ebp]
	sub	edx, DWORD PTR [ecx]
	cmp	edx, 6
	jge	SHORT $LN5@decodeUnic@2

; 738  :          return addError( "additional six characters expected to parse unicode surrogate pair.", token, current );

	push	OFFSET ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
	lea	ecx, DWORD PTR $T77659[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	lea	eax, DWORD PTR $T77659[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T77658[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77659[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T77658[ebp]
	jmp	$LN8@decodeUnic@2
$LN5@decodeUnic@2:

; 739  :       unsigned int surrogatePair;
; 740  :       if (*(current++) == '\\' && *(current++)== 'u')

	mov	ecx, DWORD PTR _current$[ebp]
	mov	edx, DWORD PTR [ecx]
	movsx	eax, BYTE PTR [edx]
	mov	ecx, DWORD PTR _current$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 1
	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [ecx], edx
	cmp	eax, 92					; 0000005cH
	jne	SHORT $LN4@decodeUnic@2
	mov	edx, DWORD PTR _current$[ebp]
	mov	eax, DWORD PTR [edx]
	movsx	ecx, BYTE PTR [eax]
	mov	edx, DWORD PTR _current$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, 1
	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [edx], eax
	cmp	ecx, 117				; 00000075H
	jne	SHORT $LN4@decodeUnic@2

; 741  :       {
; 742  :          if (decodeUnicodeEscapeSequence( token, current, end, surrogatePair ))

	lea	eax, DWORD PTR _surrogatePair$56735[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN3@decodeUnic@2

; 743  :          {
; 744  :             unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);

	mov	edx, DWORD PTR _unicode$[ebp]
	mov	eax, DWORD PTR [edx]
	and	eax, 1023				; 000003ffH
	shl	eax, 10					; 0000000aH
	mov	ecx, DWORD PTR _surrogatePair$56735[ebp]
	and	ecx, 1023				; 000003ffH
	lea	edx, DWORD PTR [eax+ecx+65536]
	mov	eax, DWORD PTR _unicode$[ebp]
	mov	DWORD PTR [eax], edx

; 745  :          } 
; 746  :          else

	jmp	SHORT $LN2@decodeUnic@2
$LN3@decodeUnic@2:

; 747  :             return false;

	xor	al, al
	jmp	SHORT $LN8@decodeUnic@2
$LN2@decodeUnic@2:

; 748  :       } 
; 749  :       else

	jmp	SHORT $LN6@decodeUnic@2
$LN4@decodeUnic@2:

; 750  :          return addError( "expecting another \\u token to begin the second half of a unicode surrogate pair", token, current );

	push	OFFSET ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
	lea	ecx, DWORD PTR $T77661[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _current$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77661[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T77660[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77661[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T77660[ebp]
	jmp	SHORT $LN8@decodeUnic@2
$LN6@decodeUnic@2:

; 751  :    }
; 752  :    return true;

	mov	al, 1
$LN8@decodeUnic@2:

; 753  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T77659[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T77661[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeCodePoint
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tv166 = -104						; size = 4
tv86 = -100						; size = 4
tv92 = -96						; size = 4
_this$ = -92						; size = 4
$T77674 = -88						; size = 28
$T77673 = -60						; size = 28
$T77672 = -29						; size = 1
_unicode$56717 = -28					; size = 4
_escape$56703 = -22					; size = 1
_c$56695 = -21						; size = 1
_end$ = -20						; size = 4
_current$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_decoded$ = 12						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 679  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 680  :    decoded.reserve( token.end_ - token.start_ - 2 );

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	sub	edx, 2
	push	edx
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 681  :    Location current = token.start_ + 1; // skip '"'

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 682  :    Location end = token.end_ - 1;      // do not include '"'

	mov	edx, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR [edx+8]
	sub	eax, 1
	mov	DWORD PTR _end$[ebp], eax
$LN20@decodeStri:

; 683  :    while ( current != end )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	$LN19@decodeStri

; 684  :    {
; 685  :       Char c = *current++;

	mov	edx, DWORD PTR _current$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _c$56695[ebp], al
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 686  :       if ( c == '"' )

	movsx	edx, BYTE PTR _c$56695[ebp]
	cmp	edx, 34					; 00000022H
	jne	SHORT $LN18@decodeStri
	jmp	$LN19@decodeStri

; 687  :          break;

	jmp	$LN17@decodeStri
$LN18@decodeStri:

; 688  :       else if ( c == '\\' )

	movsx	eax, BYTE PTR _c$56695[ebp]
	cmp	eax, 92					; 0000005cH
	jne	$LN16@decodeStri

; 689  :       {
; 690  :          if ( current == end )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	jne	SHORT $LN15@decodeStri

; 691  :             return addError( "Empty escape sequence in string", token, current );

	push	OFFSET ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T77673[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T77673[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T77672[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77673[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T77672[ebp]
	jmp	$LN21@decodeStri
$LN15@decodeStri:

; 692  :          Char escape = *current++;

	mov	edx, DWORD PTR _current$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _escape$56703[ebp], al
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 693  :          switch ( escape )

	movsx	edx, BYTE PTR _escape$56703[ebp]
	mov	DWORD PTR tv92[ebp], edx
	mov	eax, DWORD PTR tv92[ebp]
	sub	eax, 34					; 00000022H
	mov	DWORD PTR tv92[ebp], eax
	cmp	DWORD PTR tv92[ebp], 83			; 00000053H
	ja	$LN2@decodeStri
	mov	ecx, DWORD PTR tv92[ebp]
	movzx	edx, BYTE PTR $LN25@decodeStri[ecx]
	jmp	DWORD PTR $LN27@decodeStri[edx*4]
$LN12@decodeStri:

; 694  :          {
; 695  :          case '"': decoded += '"'; break;

	push	34					; 00000022H
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	$LN13@decodeStri
$LN11@decodeStri:

; 696  :          case '/': decoded += '/'; break;

	push	47					; 0000002fH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	$LN13@decodeStri
$LN10@decodeStri:

; 697  :          case '\\': decoded += '\\'; break;

	push	92					; 0000005cH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	$LN13@decodeStri
$LN9@decodeStri:

; 698  :          case 'b': decoded += '\b'; break;

	push	8
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	$LN13@decodeStri
$LN8@decodeStri:

; 699  :          case 'f': decoded += '\f'; break;

	push	12					; 0000000cH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	$LN13@decodeStri
$LN7@decodeStri:

; 700  :          case 'n': decoded += '\n'; break;

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	$LN13@decodeStri
$LN6@decodeStri:

; 701  :          case 'r': decoded += '\r'; break;

	push	13					; 0000000dH
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	$LN13@decodeStri
$LN5@decodeStri:

; 702  :          case 't': decoded += '\t'; break;

	push	9
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
	jmp	SHORT $LN13@decodeStri
$LN4@decodeStri:

; 703  :          case 'u':
; 704  :             {
; 705  :                unsigned int unicode;
; 706  :                if ( !decodeUnicodeCodePoint( token, current, end, unicode ) )

	lea	eax, DWORD PTR _unicode$56717[ebp]
	push	eax
	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	lea	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@decodeStri

; 707  :                   return false;

	xor	al, al
	jmp	SHORT $LN21@decodeStri
$LN3@decodeStri:

; 708  :                decoded += codePointToUTF8(unicode);

	mov	edx, DWORD PTR _unicode$56717[ebp]
	push	edx
	lea	eax, DWORD PTR $T77674[ebp]
	push	eax
	call	?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::codePointToUTF8
	add	esp, 8
	mov	DWORD PTR tv86[ebp], eax
	mov	ecx, DWORD PTR tv86[ebp]
	mov	DWORD PTR tv166[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv166[ebp]
	push	edx
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T77674[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 709  :             }
; 710  :             break;

	jmp	SHORT $LN13@decodeStri
$LN2@decodeStri:

; 711  :          default:
; 712  : 			 decoded += c;

	movzx	eax, BYTE PTR _c$56695[ebp]
	push	eax
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 713  : 			 decoded += escape;

	movzx	ecx, BYTE PTR _escape$56703[ebp]
	push	ecx
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
$LN13@decodeStri:

; 714  :             //return addError( "Bad escape sequence in string", token, current );
; 715  :          }
; 716  :       }
; 717  :       else

	jmp	SHORT $LN17@decodeStri
$LN16@decodeStri:

; 718  :       {
; 719  :          decoded += c;

	movzx	edx, BYTE PTR _c$56695[ebp]
	push	edx
	mov	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
$LN17@decodeStri:

; 720  :       }
; 721  :    }

	jmp	$LN20@decodeStri
$LN19@decodeStri:

; 722  :    return true;

	mov	al, 1
$LN21@decodeStri:

; 723  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN27@decodeStri:
	DD	$LN12@decodeStri
	DD	$LN11@decodeStri
	DD	$LN10@decodeStri
	DD	$LN9@decodeStri
	DD	$LN8@decodeStri
	DD	$LN7@decodeStri
	DD	$LN6@decodeStri
	DD	$LN5@decodeStri
	DD	$LN4@decodeStri
	DD	$LN2@decodeStri
$LN25@decodeStri:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR $T77673[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	lea	ecx, DWORD PTR $T77674[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Reader::decodeString
; Function compile flags: /Odtp
;	COMDAT ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
PUBLIC	??1Reader@Json@@QAE@XZ				; Json::Reader::~Reader
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1Reader@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1Reader@Json@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??1Reader@Json@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??1Reader@Json@@QAE@XZ$2
__ehfuncinfo$??1Reader@Json@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??1Reader@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1Reader@Json@@QAE@XZ PROC				; Json::Reader::~Reader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1Reader@Json@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??1Reader@Json@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??1Reader@Json@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??1Reader@Json@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1Reader@Json@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1Reader@Json@@QAE@XZ ENDP				; Json::Reader::~Reader
PUBLIC	??EValueIterator@Json@@QAEAAV01@XZ		; Json::ValueIterator::operator++
; Function compile flags: /Odtp
; File e:\newggdevelop\client\include\json\value.h
;	COMDAT ??EValueIterator@Json@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??EValueIterator@Json@@QAEAAV01@XZ PROC			; Json::ValueIterator::operator++, COMDAT
; _this$ = ecx

; 1104 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1105 :          increment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?increment@ValueIteratorBase@Json@@IAEXXZ ; Json::ValueIteratorBase::increment

; 1106 :          return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1107 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??EValueIterator@Json@@QAEAAV01@XZ ENDP			; Json::ValueIterator::operator++
_TEXT	ENDS
PUBLIC	??FValueIterator@Json@@QAEAAV01@XZ		; Json::ValueIterator::operator--
; Function compile flags: /Odtp
;	COMDAT ??FValueIterator@Json@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??FValueIterator@Json@@QAEAAV01@XZ PROC			; Json::ValueIterator::operator--, COMDAT
; _this$ = ecx

; 1098 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1099 :          decrement();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?decrement@ValueIteratorBase@Json@@IAEXXZ ; Json::ValueIteratorBase::decrement

; 1100 :          return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1101 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??FValueIterator@Json@@QAEAAV01@XZ ENDP			; Json::ValueIterator::operator--
_TEXT	ENDS
PUBLIC	??FValueIterator@Json@@QAE?AV01@H@Z		; Json::ValueIterator::operator--
; Function compile flags: /Odtp
;	COMDAT ??FValueIterator@Json@@QAE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_temp$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??FValueIterator@Json@@QAE?AV01@H@Z PROC		; Json::ValueIterator::operator--, COMDAT
; _this$ = ecx

; 1091 :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1092 :          SelfType temp( *this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0ValueIterator@Json@@QAE@ABV01@@Z	; Json::ValueIterator::ValueIterator

; 1093 :          --*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??FValueIterator@Json@@QAEAAV01@XZ	; Json::ValueIterator::operator--

; 1094 :          return temp;

	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@QAE@ABV01@@Z	; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1095 :       }

	mov	esp, ebp
	pop	ebp
	ret	8
??FValueIterator@Json@@QAE?AV01@H@Z ENDP		; Json::ValueIterator::operator--
_TEXT	ENDS
PUBLIC	??EValueIterator@Json@@QAE?AV01@H@Z		; Json::ValueIterator::operator++
; Function compile flags: /Odtp
;	COMDAT ??EValueIterator@Json@@QAE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_temp$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??EValueIterator@Json@@QAE?AV01@H@Z PROC		; Json::ValueIterator::operator++, COMDAT
; _this$ = ecx

; 1084 :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1085 :          SelfType temp( *this );

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR _temp$[ebp]
	call	??0ValueIterator@Json@@QAE@ABV01@@Z	; Json::ValueIterator::ValueIterator

; 1086 :          ++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??EValueIterator@Json@@QAEAAV01@XZ	; Json::ValueIterator::operator++

; 1087 :          return temp;

	lea	ecx, DWORD PTR _temp$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0ValueIterator@Json@@QAE@ABV01@@Z	; Json::ValueIterator::ValueIterator
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1088 :       }

	mov	esp, ebp
	pop	ebp
	ret	8
??EValueIterator@Json@@QAE?AV01@H@Z ENDP		; Json::ValueIterator::operator++
_TEXT	ENDS
PUBLIC	??EValueConstIterator@Json@@QAEAAV01@XZ		; Json::ValueConstIterator::operator++
; Function compile flags: /Odtp
;	COMDAT ??EValueConstIterator@Json@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??EValueConstIterator@Json@@QAEAAV01@XZ PROC		; Json::ValueConstIterator::operator++, COMDAT
; _this$ = ecx

; 1042 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1043 :          increment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?increment@ValueIteratorBase@Json@@IAEXXZ ; Json::ValueIteratorBase::increment

; 1044 :          return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1045 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??EValueConstIterator@Json@@QAEAAV01@XZ ENDP		; Json::ValueConstIterator::operator++
_TEXT	ENDS
PUBLIC	??FValueConstIterator@Json@@QAEAAV01@XZ		; Json::ValueConstIterator::operator--
; Function compile flags: /Odtp
;	COMDAT ??FValueConstIterator@Json@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??FValueConstIterator@Json@@QAEAAV01@XZ PROC		; Json::ValueConstIterator::operator--, COMDAT
; _this$ = ecx

; 1036 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1037 :          decrement();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?decrement@ValueIteratorBase@Json@@IAEXXZ ; Json::ValueIteratorBase::decrement

; 1038 :          return *this;

	mov	eax, DWORD PTR _this$[ebp]

; 1039 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??FValueConstIterator@Json@@QAEAAV01@XZ ENDP		; Json::ValueConstIterator::operator--
_TEXT	ENDS
PUBLIC	??FValueConstIterator@Json@@QAE?AV01@H@Z	; Json::ValueConstIterator::operator--
; Function compile flags: /Odtp
;	COMDAT ??FValueConstIterator@Json@@QAE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_temp$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??FValueConstIterator@Json@@QAE?AV01@H@Z PROC		; Json::ValueConstIterator::operator--, COMDAT
; _this$ = ecx

; 1029 :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1030 :          SelfType temp( *this );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _temp$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _temp$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _temp$[ebp+8], eax

; 1031 :          --*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??FValueConstIterator@Json@@QAEAAV01@XZ	; Json::ValueConstIterator::operator--

; 1032 :          return temp;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _temp$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _temp$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1033 :       }

	mov	esp, ebp
	pop	ebp
	ret	8
??FValueConstIterator@Json@@QAE?AV01@H@Z ENDP		; Json::ValueConstIterator::operator--
_TEXT	ENDS
PUBLIC	??EValueConstIterator@Json@@QAE?AV01@H@Z	; Json::ValueConstIterator::operator++
; Function compile flags: /Odtp
;	COMDAT ??EValueConstIterator@Json@@QAE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
_temp$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??EValueConstIterator@Json@@QAE?AV01@H@Z PROC		; Json::ValueConstIterator::operator++, COMDAT
; _this$ = ecx

; 1022 :       {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 1023 :          SelfType temp( *this );

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR _temp$[ebp], ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR _temp$[ebp+4], edx
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _temp$[ebp+8], eax

; 1024 :          ++*this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??EValueConstIterator@Json@@QAEAAV01@XZ	; Json::ValueConstIterator::operator++

; 1025 :          return temp;

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR _temp$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	eax, DWORD PTR _temp$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR _temp$[ebp+8]
	mov	DWORD PTR [ecx+8], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1026 :       }

	mov	esp, ebp
	pop	ebp
	ret	8
??EValueConstIterator@Json@@QAE?AV01@H@Z ENDP		; Json::ValueConstIterator::operator++
_TEXT	ENDS
PUBLIC	??GValueIteratorBase@Json@@QBEHABV01@@Z		; Json::ValueIteratorBase::operator-
; Function compile flags: /Odtp
;	COMDAT ??GValueIteratorBase@Json@@QBEHABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_other$ = 8						; size = 4
??GValueIteratorBase@Json@@QBEHABV01@@Z PROC		; Json::ValueIteratorBase::operator-, COMDAT
; _this$ = ecx

; 953  :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 954  :          return computeDistance( other );

	mov	eax, DWORD PTR _other$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?computeDistance@ValueIteratorBase@Json@@IBEHABV12@@Z ; Json::ValueIteratorBase::computeDistance

; 955  :       }

	mov	esp, ebp
	pop	ebp
	ret	4
??GValueIteratorBase@Json@@QBEHABV01@@Z ENDP		; Json::ValueIteratorBase::operator-
_TEXT	ENDS
PUBLIC	??4Path@Json@@QAEAAV01@ABV01@@Z			; Json::Path::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Path@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Path@Json@@QAEAAV01@ABV01@@Z PROC			; Json::Path::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Path@Json@@QAEAAV01@ABV01@@Z ENDP			; Json::Path::operator=
_TEXT	ENDS
PUBLIC	??0Path@Json@@QAE@ABV01@@Z			; Json::Path::Path
; Function compile flags: /Odtp
;	COMDAT ??0Path@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0Path@Json@@QAE@ABV01@@Z PROC				; Json::Path::Path, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@ABV01@@Z ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::vector<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0Path@Json@@QAE@ABV01@@Z ENDP				; Json::Path::Path
_TEXT	ENDS
PUBLIC	??1Path@Json@@QAE@XZ				; Json::Path::~Path
; Function compile flags: /Odtp
;	COMDAT ??1Path@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Path@Json@@QAE@XZ PROC				; Json::Path::~Path, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$vector@VPathArgument@Json@@V?$allocator@VPathArgument@Json@@@std@@@std@@QAE@XZ ; std::vector<Json::PathArgument,std::allocator<Json::PathArgument> >::~vector<Json::PathArgument,std::allocator<Json::PathArgument> >
	mov	esp, ebp
	pop	ebp
	ret	0
??1Path@Json@@QAE@XZ ENDP				; Json::Path::~Path
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??_Glength_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___flags$ = 8						; size = 4
??_Glength_error@std@@UAEPAXI@Z PROC			; std::length_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1length_error@std@@UAE@XZ		; std::length_error::~length_error
	mov	eax, DWORD PTR ___flags$[ebp]
	and	eax, 1
	je	SHORT $LN1@scalar@12
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN1@scalar@12:
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??_Glength_error@std@@UAEPAXI@Z ENDP			; std::length_error::`scalar deleting destructor'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>, COMDAT
; _this$ = ecx

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>

; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>, COMDAT
; _this$ = ecx

; 381  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Pdeque$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>

; 382  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++, COMDAT
; _this$ = ecx

; 395  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 396  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++

; 397  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 398  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*, COMDAT
; _this$ = ecx

; 385  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*

; 387  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Base$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?_Checked_iterator_base@?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 363  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 		_Deque_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR __Base$[ebp]
	call	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>

; 365  : 		return _Base;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Base$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Base$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 366  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Checked_iterator_base@?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Checked_iterator_base@?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Base$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
?_Checked_iterator_base@?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base, COMDAT
; _this$ = ecx

; 363  : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 364  : 		_Deque_iterator<_Ty, _Alloc, false> _Base(this->_Myoff, this->_Getmycont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	lea	ecx, DWORD PTR __Base$[ebp]
	call	??0?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAE@IPBV_Container_base_aux@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>

; 365  : 		return _Base;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Base$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Base$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 366  : 	}

	mov	esp, ebp
	pop	ebp
	ret	4
?_Checked_iterator_base@?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@3
$LN2@Copy_opt@3:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
$LN3@Copy_opt@3:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@3

; 2472 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
	mov	ecx, eax
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
	jmp	SHORT $LN2@Copy_opt@3
$LN1@Copy_opt@3:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
$LN2@Copy_backw@3:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_backw@3

; 2676 : 		*--_Dest = *--_Last;

	lea	ecx, DWORD PTR __Last$[ebp]
	call	??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??F?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
	mov	ecx, eax
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
	jmp	SHORT $LN2@Copy_backw@3
$LN1@Copy_backw@3:

; 2677 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Checked_iterator_base
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@4
$LN2@Copy_opt@4:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
$LN3@Copy_opt@4:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@4

; 2472 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Copy_opt@4
$LN1@Copy_opt@4:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	pop	esi
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>, COMDAT

; 2673 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi
$LN2@Copy_backw@4:

; 2674 : 	_DEBUG_RANGE(_First, _Last);
; 2675 : 	while (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_backw@4

; 2676 : 		*--_Dest = *--_Last;

	lea	ecx, DWORD PTR __Last$[ebp]
	call	??F?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??F?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator--
	mov	ecx, eax
	call	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Copy_backw@4
$LN1@Copy_backw@4:

; 2677 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2678 : 	}

	pop	esi
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z PROC ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>, COMDAT

; 1138 : 	{

	push	ebp
	mov	ebp, esp

; 1139 : 		return _It._Checked_iterator_base();

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	call	?_Checked_iterator_base@?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::_Checked_iterator_base
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1140 : 	}

	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ENDP ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@5
$LN2@Copy_opt@5:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator++
$LN3@Copy_opt@5:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@5

; 2472 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator*
	mov	ecx, eax
	call	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
	jmp	SHORT $LN2@Copy_opt@5
$LN1@Copy_opt@5:

; 2473 : 	return (_Dest);

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>, COMDAT

; 2469 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	esi

; 2470 : 	_DEBUG_RANGE(_First, _Last);
; 2471 : 	for (; _First != _Last; ++_Dest, ++_First)

	jmp	SHORT $LN3@Copy_opt@6
$LN2@Copy_opt@6:
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??E?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator++
$LN3@Copy_opt@6:
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@Copy_opt@6

; 2472 : 		*_Dest = *_First;

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
	mov	esi, eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator*
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [eax], edx
	jmp	SHORT $LN2@Copy_opt@6
$LN1@Copy_opt@6:

; 2473 : 	return (_Dest);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	edx, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2474 : 	}

	pop	esi
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
tv79 = -16						; size = 4
_this$ = -12						; size = 4
__Block$ = -8						; size = 4
__Newoff$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front, COMDAT
; _this$ = ecx

; 799  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 
; 801  :  #if _HAS_ITERATOR_DEBUGGING
; 802  : 		this->_Orphan_all();
; 803  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 804  : 
; 805  : 		if (_Myoff % _DEQUESIZ == 0
; 806  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	xor	edx, edx
	mov	ecx, 4
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_front
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 4
	shr	eax, 2
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN2@push_front

; 807  : 			_Growmap(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_front:

; 808  : 		size_type _Newoff = _Myoff != 0 ? _Myoff
; 809  : 			: _Mapsize * _DEQUESIZ;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN5@push_front
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv79[ebp], ecx
	jmp	SHORT $LN6@push_front
$LN5@push_front:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	shl	eax, 2
	mov	DWORD PTR tv79[ebp], eax
$LN6@push_front:
	mov	ecx, DWORD PTR tv79[ebp]
	mov	DWORD PTR __Newoff$[ebp], ecx

; 810  : 		size_type _Block = --_Newoff / _DEQUESIZ;

	mov	edx, DWORD PTR __Newoff$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Newoff$[ebp], edx
	mov	eax, DWORD PTR __Newoff$[ebp]
	shr	eax, 2
	mov	DWORD PTR __Block$[ebp], eax

; 811  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN1@push_front

; 812  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_front:

; 813  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 4
	div	esi
	mov	eax, DWORD PTR __Block$[ebp]
	mov	ecx, DWORD PTR [ecx+eax*4]
	lea	edx, DWORD PTR [ecx+edx*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?construct@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV34@@Z ; std::allocator<Json::Value *>::construct

; 814  : 		_Myoff = _Newoff;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 815  : 		++_Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], eax

; 816  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z PROC ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Different_checked_iterator_base_type_tag>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ENDP ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z
_TEXT	SEGMENT
__Base_tag$ = -1					; size = 1
___$ReturnUdt$ = 8					; size = 4
__It$ = 12						; size = 4
??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z PROC ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 1163 : 	{

	push	ebp
	mov	ebp, esp
	push	ecx

; 1164 : 		typename _Checked_iterator_base_helper<_Iter>::_Checked_iterator_base_type_tag _Base_tag;
; 1165 : 		return _Checked_base(_It, _Base_tag);

	movzx	eax, BYTE PTR __Base_tag$[ebp]
	push	eax
	mov	ecx, DWORD PTR __It$[ebp]
	push	ecx
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@U_Different_checked_iterator_base_type_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@U_Different_checked_iterator_base_type_tag@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Different_checked_iterator_base_type_tag>
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1166 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ENDP ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T78105 = -16						; size = 8
$T78104 = -8						; size = 8
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Val$ = 24						; size = 4
??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z PROC ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>, COMDAT

; 3186 : 	{	// copy _Val through [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 3187 : 	_Fill(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78104[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78105[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	call	??$_Fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0ABVErrorInfo@Reader@Json@@@Z ; std::_Fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,Json::Reader::ErrorInfo>
	add	esp, 20					; 00000014H

; 3188 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z ENDP ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*, COMDAT
; _this$ = ecx

; 385  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 386  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*

; 387  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=, COMDAT
; _this$ = ecx

; 421  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=

; 423  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 424  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=, COMDAT
; _this$ = ecx

; 421  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 422  : 		*(_Mybase *)this += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=

; 423  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 424  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
tv77 = -16						; size = 4
_this$ = -12						; size = 4
__Block$ = -8						; size = 4
__Newoff$ = -4						; size = 4
__Val$ = 8						; size = 4
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front, COMDAT
; _this$ = ecx

; 799  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 800  : 
; 801  :  #if _HAS_ITERATOR_DEBUGGING
; 802  : 		this->_Orphan_all();
; 803  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 804  : 
; 805  : 		if (_Myoff % _DEQUESIZ == 0
; 806  : 			&& _Mapsize <= (_Mysize + _DEQUESIZ) / _DEQUESIZ)

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+24]
	xor	edx, edx
	mov	ecx, 1
	div	ecx
	test	edx, edx
	jne	SHORT $LN2@push_front@2
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	add	eax, 1
	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	ja	SHORT $LN2@push_front@2

; 807  : 			_Growmap(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@push_front@2:

; 808  : 		size_type _Newoff = _Myoff != 0 ? _Myoff
; 809  : 			: _Mapsize * _DEQUESIZ;

	mov	edx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [edx+24], 0
	je	SHORT $LN5@push_front@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	mov	DWORD PTR tv77[ebp], ecx
	jmp	SHORT $LN6@push_front@2
$LN5@push_front@2:
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR tv77[ebp], eax
$LN6@push_front@2:
	mov	ecx, DWORD PTR tv77[ebp]
	mov	DWORD PTR __Newoff$[ebp], ecx

; 810  : 		size_type _Block = --_Newoff / _DEQUESIZ;

	mov	edx, DWORD PTR __Newoff$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Newoff$[ebp], edx
	mov	eax, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR __Block$[ebp], eax

; 811  : 		if (_Map[_Block] == 0)

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Block$[ebp]
	cmp	DWORD PTR [edx+eax*4], 0
	jne	SHORT $LN1@push_front@2

; 812  : 			_Map[_Block] = this->_Alval.allocate(_DEQUESIZ);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR __Block$[ebp]
	mov	DWORD PTR [edx+ecx*4], eax
$LN1@push_front@2:

; 813  : 		this->_Alval.construct(_Map[_Block] + _Newoff % _DEQUESIZ, _Val);

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	mov	eax, DWORD PTR __Newoff$[ebp]
	xor	edx, edx
	mov	esi, 1
	div	esi
	imul	edx, 44					; 0000002cH
	mov	eax, DWORD PTR __Block$[ebp]
	add	edx, DWORD PTR [ecx+eax*4]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 12					; 0000000cH
	call	?construct@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct

; 814  : 		_Myoff = _Newoff;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newoff$[ebp]
	mov	DWORD PTR [ecx+24], edx

; 815  : 		++_Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	add	ecx, 1
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+28], ecx

; 816  : 		}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+, COMDAT
; _this$ = ecx

; 427  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 428  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 429  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 430  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+, COMDAT
; _this$ = ecx

; 427  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 428  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 429  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 430  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+
_TEXT	ENDS
PUBLIC	??0Reader@Json@@QAE@ABVFeatures@1@@Z		; Json::Reader::Reader
;	COMDAT xdata$x
; File e:\newggdevelop\client\ggjsoncpp\json_reader.cpp
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$2
__ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Reader@Json@@QAE@ABVFeatures@1@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_features$ = 8						; size = 4
??0Reader@Json@@QAE@ABVFeatures@1@@Z PROC		; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 108  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	edx, DWORD PTR _features$[ebp]
	mov	ax, WORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	WORD PTR [ecx+140], ax
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+142], 0

; 109  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABVFeatures@1@@Z ENDP		; Json::Reader::Reader
PUBLIC	??0Reader@Json@@QAE@XZ				; Json::Reader::Reader
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$2
__ehfuncinfo$??0Reader@Json@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Reader@Json@@QAE@XZ PROC				; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 93   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+92], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+96], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+100], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+104], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+108], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 140				; 0000008cH
	push	edx
	call	?all@Features@Json@@SA?AV12@XZ		; Json::Features::all
	add	esp, 4
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+142], 0

; 94   : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??0Reader@Json@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??0Reader@Json@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@XZ ENDP				; Json::Reader::Reader
PUBLIC	??DValueIterator@Json@@QBEAAVValue@1@XZ		; Json::ValueIterator::operator*
; Function compile flags: /Odtp
; File e:\newggdevelop\client\include\json\value.h
;	COMDAT ??DValueIterator@Json@@QBEAAVValue@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??DValueIterator@Json@@QBEAAVValue@1@XZ PROC		; Json::ValueIterator::operator*, COMDAT
; _this$ = ecx

; 1110 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1111 :          return deref();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ ; Json::ValueIteratorBase::deref

; 1112 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??DValueIterator@Json@@QBEAAVValue@1@XZ ENDP		; Json::ValueIterator::operator*
_TEXT	ENDS
PUBLIC	??DValueConstIterator@Json@@QBEABVValue@1@XZ	; Json::ValueConstIterator::operator*
; Function compile flags: /Odtp
;	COMDAT ??DValueConstIterator@Json@@QBEABVValue@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??DValueConstIterator@Json@@QBEABVValue@1@XZ PROC	; Json::ValueConstIterator::operator*, COMDAT
; _this$ = ecx

; 1048 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1049 :          return deref();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?deref@ValueIteratorBase@Json@@IBEAAVValue@2@XZ ; Json::ValueIteratorBase::deref

; 1050 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
??DValueConstIterator@Json@@QBEABVValue@1@XZ ENDP	; Json::ValueConstIterator::operator*
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ??A?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T78300 = -8						; size = 8
__Off$ = 8						; size = 4
??A?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator[], COMDAT
; _this$ = ecx

; 449  : 		{	// subscript

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 		return (*(*this + _Off));

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78300[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+
	mov	ecx, eax
	call	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*

; 451  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator[]
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Start$ = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse, COMDAT
; _this$ = ecx

; 1031 : 		{	// reverse a subrange

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1032 : 		iterator _Start = begin();

	lea	eax, DWORD PTR __Start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin

; 1033 : 		for (; _First != _Last && _First != --_Last; ++_First)

	jmp	SHORT $LN3@Reverse
$LN2@Reverse:
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 1
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Reverse:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Reverse
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Last$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Reverse

; 1034 : 			_STD _Swap_adl(_Start[_First], _Start[_Last]);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Start$[ebp]
	call	??A?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator[]
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Start$[ebp]
	call	??A?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator[]
	push	eax
	call	??$_Swap_adl@PAVValue@Json@@@std@@YAXAAPAVValue@Json@@0@Z ; std::_Swap_adl<Json::Value *>
	add	esp, 8
	jmp	SHORT $LN2@Reverse
$LN4@Reverse:

; 1035 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78309 = -28						; size = 8
$T78308 = -20						; size = 8
$T78307 = -11						; size = 1
$T78306 = -10						; size = 1
$T78305 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78305[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78306[ebp], al
	movzx	ecx, BYTE PTR $T78305[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78306[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78307[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78308[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78309[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2486 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78316 = -28						; size = 8
$T78315 = -20						; size = 8
$T78314 = -11						; size = 1
$T78313 = -10						; size = 1
$T78312 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78312[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78313[ebp], al
	movzx	ecx, BYTE PTR $T78312[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78313[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78314[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78315[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78316[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2486 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78323 = -28						; size = 8
$T78322 = -20						; size = 8
$T78321 = -11						; size = 1
$T78320 = -10						; size = 1
$T78319 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78319[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78320[ebp], al
	movzx	ecx, BYTE PTR $T78319[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78320[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78321[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78322[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78323[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2486 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78330 = -28						; size = 8
$T78329 = -20						; size = 8
$T78328 = -11						; size = 1
$T78327 = -10						; size = 1
$T78326 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 2481 : 	{	// copy [_First, _Last) to [_Dest, ...), random_access iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2482 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2483 : 	_OutIt _Result = _Dest + (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+

; 2484 : 	_Copy_opt(_First, _Last, _CHECKED_BASE(_Dest), 
; 2485 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78326[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78327[ebp], al
	movzx	ecx, BYTE PTR $T78326[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78327[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78328[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78329[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78330[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@2@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2486 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2487 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
xdata$x	SEGMENT
__unwindtable$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$4 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$0
__catchsym$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$2
__tryblocktable$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$4
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$5
__ehfuncinfo$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T78335 = -48						; size = 4
$T78334 = -44						; size = 4
$T78333 = -40						; size = 8
__Num$63744 = -32					; size = 4
__Off$ = -28						; size = 4
__Rem$ = -24						; size = 4
__Oldsize$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT
; _this$ = ecx

; 971  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 			_It _First, _It _Last, input_iterator_tag)
; 973  : 		{	// insert [_First, _Last) at _Where, input iterators
; 974  : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T78333[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
	mov	DWORD PTR __Off$[ebp], eax

; 975  : 
; 976  :  #if _HAS_ITERATOR_DEBUGGING
; 977  : 		if (_Mysize < _Off)
; 978  : 			_DEBUG_ERROR("deque insert iterator outside range");
; 979  : 		_DEBUG_RANGE(_First, _Last);
; 980  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 981  : 
; 982  : 		size_type _Rem = _Mysize - _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Rem$[ebp], edx

; 983  : 		size_type _Oldsize = _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 984  : 
; 985  : 		if (_First == _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@Insert
	jmp	$LN21@Insert
$LN19@Insert:

; 986  : 			;
; 987  : 		else if (_Off < _Rem)

	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Rem$[ebp]
	jae	$LN17@Insert

; 988  : 			{	// closer to front
; 989  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 990  : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN15@Insert
$LN14@Insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator++
$LN15@Insert:
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@Insert

; 991  : 				push_front((value_type)*_First);	// prepend flipped

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T78334[ebp], ecx
	lea	edx, DWORD PTR $T78334[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
	jmp	SHORT $LN14@Insert
$LN13@Insert:
	jmp	SHORT $LN22@Insert
__catch$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$0:
$LN12@Insert:

; 992  : 
; 993  : 			_CATCH_ALL
; 994  : 			for (; _Oldsize < _Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jae	SHORT $LN11@Insert

; 995  : 				pop_front();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
	jmp	SHORT $LN12@Insert
$LN11@Insert:

; 996  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 997  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$1
	ret	0
$LN22@Insert:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$1:

; 998  : 
; 999  : 			size_type _Num = _Mysize - _Oldsize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, DWORD PTR __Oldsize$[ebp]
	mov	DWORD PTR __Num$63744[ebp], eax

; 1000 : 
; 1001 : 			if (0 < _Off)

	cmp	DWORD PTR __Off$[ebp], 0
	jbe	SHORT $LN10@Insert

; 1002 : 				{	// insert not at beginning, flip new stuff into place
; 1003 : 				_Reverse(_Num, _Num + _Off);

	mov	ecx, DWORD PTR __Num$63744[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Num$63744[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse

; 1004 : 				_Reverse(0, _Num + _Off);

	mov	eax, DWORD PTR __Num$63744[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse

; 1005 : 				}
; 1006 : 			else

	jmp	SHORT $LN9@Insert
$LN10@Insert:

; 1007 : 				_Reverse(0, _Num);	// flip new stuff in place

	mov	ecx, DWORD PTR __Num$63744[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse
$LN9@Insert:

; 1008 : 			}
; 1009 : 		else

	jmp	$LN21@Insert
$LN17@Insert:

; 1010 : 			{	// closer to back
; 1011 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2

; 1012 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN6@Insert
$LN5@Insert:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator++
$LN6@Insert:
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Insert

; 1013 : 				push_back((value_type)*_First);	// append

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR $T78335[ebp], ecx
	lea	edx, DWORD PTR $T78335[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
	jmp	SHORT $LN5@Insert
$LN4@Insert:
	jmp	SHORT $LN24@Insert
__catch$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$2:
$LN3@Insert:

; 1014 : 
; 1015 : 			_CATCH_ALL
; 1016 : 			for (; _Oldsize < _Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jae	SHORT $LN2@Insert

; 1017 : 				pop_back();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
	jmp	SHORT $LN3@Insert
$LN2@Insert:

; 1018 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1019 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$3
	ret	0
$LN24@Insert:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$3:

; 1020 : 
; 1021 : 			if (_Off < _Oldsize)

	mov	edx, DWORD PTR __Off$[ebp]
	cmp	edx, DWORD PTR __Oldsize$[ebp]
	jae	SHORT $LN21@Insert

; 1022 : 				{	// insert not at end, flip new stuff into place
; 1023 : 				_Reverse(_Off, _Oldsize);

	mov	eax, DWORD PTR __Oldsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse

; 1024 : 				_Reverse(_Oldsize, _Mysize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse

; 1025 : 				_Reverse(_Off, _Mysize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Reverse
$LN21@Insert:

; 1026 : 				}
; 1027 : 			}
; 1028 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z
_TEXT	SEGMENT
$T78361 = -20						; size = 8
$T78360 = -12						; size = 8
$T78359 = -3						; size = 1
$T78358 = -2						; size = 1
$T78357 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z PROC ; std::copy<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 2561 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2562 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2563 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78357[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	BYTE PTR $T78358[ebp], al
	movzx	eax, BYTE PTR $T78357[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78358[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78359[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78360[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78361[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2564 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ENDP ; std::copy<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$copy@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z
_TEXT	SEGMENT
$T78368 = -20						; size = 8
$T78367 = -12						; size = 8
$T78366 = -3						; size = 1
$T78365 = -2						; size = 1
$T78364 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z PROC ; std::copy<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 2561 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2562 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2563 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78364[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	BYTE PTR $T78365[ebp], al
	movzx	eax, BYTE PTR $T78364[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78365[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78366[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78367[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78368[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2564 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z ENDP ; std::copy<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$copy@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0V10@@Z
_TEXT	SEGMENT
$T78375 = -20						; size = 8
$T78374 = -12						; size = 8
$T78373 = -3						; size = 1
$T78372 = -2						; size = 1
$T78371 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0V10@@Z PROC ; std::copy<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 2561 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2562 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2563 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78371[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	BYTE PTR $T78372[ebp], al
	movzx	eax, BYTE PTR $T78371[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78372[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78373[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Iter_random<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78374[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78375[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2564 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0V10@@Z ENDP ; std::copy<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$copy@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0V10@@Z
_TEXT	SEGMENT
$T78382 = -20						; size = 8
$T78381 = -12						; size = 8
$T78380 = -3						; size = 1
$T78379 = -2						; size = 1
$T78378 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0V10@@Z PROC ; std::copy<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 2561 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2562 : 	return (_Copy_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest, 
; 2563 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _Range_checked_iterator_tag()));

	xor	eax, eax
	mov	BYTE PTR $T78378[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Ptr_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	BYTE PTR $T78379[ebp], al
	movzx	eax, BYTE PTR $T78378[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78379[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78380[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Iter_random<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78381[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78382[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_opt@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_opt<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2564 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0V10@@Z ENDP ; std::copy<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??$insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T78386 = -2						; size = 1
$T78385 = -1						; size = 1
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
??$insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT
; _this$ = ecx

; 958  : 		void insert(const_iterator _Where, _It _First, _It _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 959  : 		{	// insert [_First, _Last) at _Where
; 960  : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78385[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	movzx	edx, BYTE PTR $T78386[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >

; 961  : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??$insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Z?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-=, COMDAT
; _this$ = ecx

; 433  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 434  : 		return (*this += -_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+=

; 435  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
$T78391 = -8						; size = 8
__Off$ = 8						; size = 4
??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[], COMDAT
; _this$ = ecx

; 449  : 		{	// subscript

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 450  : 		return (*(*this + _Off));

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78391[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, eax
	call	??D?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*

; 451  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-, COMDAT
; _this$ = ecx

; 438  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 440  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Z?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 441  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Off$ = 8						; size = 4
??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-=, COMDAT
; _this$ = ecx

; 433  : 		{	// decrement by integer

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 434  : 		return (*this += -_Off);

	mov	eax, DWORD PTR __Off$[ebp]
	neg	eax
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??Y?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+=

; 435  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-=
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Tmp$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-, COMDAT
; _this$ = ecx

; 438  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 439  : 		_Myt _Tmp = *this;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Tmp$[ebp], ecx
	mov	DWORD PTR __Tmp$[ebp+4], edx

; 440  : 		return (_Tmp -= _Off);

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$[ebp]
	call	??Z?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QAEAAV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-=
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [eax+4], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 441  : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
$T78401 = -16						; size = 8
$T78400 = -8						; size = 8
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back, COMDAT
; _this$ = ecx

; 789  : 		{	// return last element of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 790  : 		return (*(end() - 1));

	push	1
	lea	eax, DWORD PTR $T78401[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78400[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
	mov	ecx, eax
	call	??D?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator*

; 791  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$3
__ehfuncinfo$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T78408 = -52						; size = 8
$T78407 = -44						; size = 8
$T78406 = -36						; size = 8
$T78405 = -28						; size = 8
$T78404 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 587  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 12					; 0000000cH
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T78404[ebp], esp
	push	eax
	call	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAE@V?$allocator@PAVValue@Json@@@1@@Z ; std::_Deque_val<Json::Value *,std::allocator<Json::Value *> >::_Deque_val<Json::Value *,std::allocator<Json::Value *> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 588  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 589  : 		insert(begin(), _Right.begin(), _Right.end());

	lea	edx, DWORD PTR $T78408[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78407[ebp], ecx
	mov	DWORD PTR $T78407[ebp+4], edx
	lea	eax, DWORD PTR $T78405[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78406[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR $T78407[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78407[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	jmp	SHORT $LN4@deque
__catch$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$0:

; 590  : 		_CATCH_ALL
; 591  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 592  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 593  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@deque
	ret	0
$LN4@deque:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@deque:

; 594  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@deque:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
__ehhandler$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\stack
;	COMDAT ?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top, COMDAT
; _this$ = ecx

; 47   : 		{	// return last element of mutable stack

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 48   : 		return (c.back());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back

; 49   : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
_TEXT	ENDS
PUBLIC	?currentValue@Reader@Json@@AAEAAVValue@2@XZ	; Json::Reader::currentValue
; Function compile flags: /Odtp
; File e:\newggdevelop\client\ggjsoncpp\json_reader.cpp
;	COMDAT ?currentValue@Reader@Json@@AAEAAVValue@2@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?currentValue@Reader@Json@@AAEAAVValue@2@XZ PROC	; Json::Reader::currentValue, COMDAT
; _this$ = ecx

; 824  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 825  :    return *(nodes_.top());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
	mov	eax, DWORD PTR [eax]

; 826  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?currentValue@Reader@Json@@AAEAAVValue@2@XZ ENDP	; Json::Reader::currentValue
_TEXT	ENDS
PUBLIC	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1
__ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
tv95 = -88						; size = 4
tv129 = -84						; size = 4
tv93 = -80						; size = 4
tv128 = -76						; size = 4
_this$ = -72						; size = 4
$T78430 = -68						; size = 28
$T78429 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_placement$ = 16					; size = 4
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z PROC ; Json::Reader::addComment, COMDAT
; _this$ = ecx

; 400  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 401  :    assert( collectComments_ );
; 402  :    if ( placement == commentAfterOnSameLine )

	cmp	DWORD PTR _placement$[ebp], 1
	jne	SHORT $LN3@addComment

; 403  :    {
; 404  :       assert( lastValue_ != 0 );
; 405  :       lastValue_->setComment( std::string( begin, end ), placement );

	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _begin$[ebp]
	push	ecx
	lea	ecx, DWORD PTR $T78429[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	mov	DWORD PTR tv128[ebp], eax
	mov	edx, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv93[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _placement$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv93[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+108]
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78429[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 406  :    }
; 407  :    else

	jmp	SHORT $LN4@addComment
$LN3@addComment:

; 408  :    {
; 409  :       if ( !commentsBefore_.empty() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@addComment

; 410  :          commentsBefore_ += "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@addComment:

; 411  :       commentsBefore_ += std::string( begin, end );

	mov	ecx, DWORD PTR _end$[ebp]
	push	ecx
	mov	edx, DWORD PTR _begin$[ebp]
	push	edx
	lea	ecx, DWORD PTR $T78430[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	mov	DWORD PTR tv129[ebp], eax
	mov	eax, DWORD PTR tv129[ebp]
	mov	DWORD PTR tv95[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv95[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78430[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@addComment:

; 412  :    }
; 413  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0:
	lea	ecx, DWORD PTR $T78429[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1:
	lea	ecx, DWORD PTR $T78430[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ENDP ; Json::Reader::addComment
PUBLIC	?readComment@Reader@Json@@AAE_NXZ		; Json::Reader::readComment
; Function compile flags: /Odtp
;	COMDAT ?readComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
_placement$56394 = -12					; size = 4
_c$ = -6						; size = 1
_successful$ = -5					; size = 1
_commentBegin$ = -4					; size = 4
?readComment@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readComment, COMDAT
; _this$ = ecx

; 370  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	DWORD PTR _this$[ebp], ecx

; 371  :    Location commentBegin = current_ - 1;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	sub	ecx, 1
	mov	DWORD PTR _commentBegin$[ebp], ecx

; 372  :    Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$[ebp], al

; 373  :    bool successful = false;

	mov	BYTE PTR _successful$[ebp], 0

; 374  :    if ( c == '*' )

	movsx	edx, BYTE PTR _c$[ebp]
	cmp	edx, 42					; 0000002aH
	jne	SHORT $LN8@readCommen

; 375  :       successful = readCStyleComment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readCStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCStyleComment
	mov	BYTE PTR _successful$[ebp], al
	jmp	SHORT $LN7@readCommen
$LN8@readCommen:

; 376  :    else if ( c == '/' )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 47					; 0000002fH
	jne	SHORT $LN7@readCommen

; 377  :       successful = readCppStyleComment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readCppStyleComment@Reader@Json@@AAE_NXZ ; Json::Reader::readCppStyleComment
	mov	BYTE PTR _successful$[ebp], al
$LN7@readCommen:

; 378  :    if ( !successful )

	movzx	ecx, BYTE PTR _successful$[ebp]
	test	ecx, ecx
	jne	SHORT $LN5@readCommen

; 379  :       return false;

	xor	al, al
	jmp	SHORT $LN9@readCommen
$LN5@readCommen:

; 380  : 
; 381  :    if ( collectComments_ )

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+142]
	test	eax, eax
	je	SHORT $LN4@readCommen

; 382  :    {
; 383  :       CommentPlacement placement = commentBefore;

	mov	DWORD PTR _placement$56394[ebp], 0

; 384  :       if ( lastValueEnd_  &&  !containsNewLine( lastValueEnd_, commentBegin ) )

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+104], 0
	je	SHORT $LN3@readCommen
	mov	edx, DWORD PTR _commentBegin$[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+104]
	push	ecx
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	add	esp, 8
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@readCommen

; 385  :       {
; 386  :          if ( c != '*'  ||  !containsNewLine( commentBegin, current_ ) )

	movsx	eax, BYTE PTR _c$[ebp]
	cmp	eax, 42					; 0000002aH
	jne	SHORT $LN1@readCommen
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	push	edx
	mov	eax, DWORD PTR _commentBegin$[ebp]
	push	eax
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	add	esp, 8
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@readCommen
$LN1@readCommen:

; 387  :             placement = commentAfterOnSameLine;

	mov	DWORD PTR _placement$56394[ebp], 1
$LN3@readCommen:

; 388  :       }
; 389  : 
; 390  :       addComment( commentBegin, current_, placement );

	mov	edx, DWORD PTR _placement$56394[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	push	ecx
	mov	edx, DWORD PTR _commentBegin$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
$LN4@readCommen:

; 391  :    }
; 392  :    return true;

	mov	al, 1
$LN9@readCommen:

; 393  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readComment@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readComment
_TEXT	ENDS
PUBLIC	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readToken
; Function compile flags: /Odtp
;	COMDAT ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv70 = -12						; size = 4
_this$ = -8						; size = 4
_c$ = -2						; size = 1
_ok$ = -1						; size = 1
_token$ = 8						; size = 4
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readToken, COMDAT
; _this$ = ecx

; 266  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 267  :    skipSpaces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipSpaces@Reader@Json@@AAEXXZ		; Json::Reader::skipSpaces

; 268  :    token.start_ = current_;

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+4], edx

; 269  :    Char c = getNextChar();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?getNextChar@Reader@Json@@AAEDXZ	; Json::Reader::getNextChar
	mov	BYTE PTR _c$[ebp], al

; 270  :    bool ok = true;

	mov	BYTE PTR _ok$[ebp], 1

; 271  :    switch ( c )

	movsx	eax, BYTE PTR _c$[ebp]
	mov	DWORD PTR tv70[ebp], eax
	cmp	DWORD PTR tv70[ebp], 125		; 0000007dH
	ja	$LN2@readToken
	mov	ecx, DWORD PTR tv70[ebp]
	movzx	edx, BYTE PTR $LN20@readToken[ecx]
	jmp	DWORD PTR $LN21@readToken[edx*4]
$LN15@readToken:

; 272  :    {
; 273  :    case '{':
; 274  :       token.type_ = tokenObjectBegin;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 1

; 275  :       break;

	jmp	$LN16@readToken
$LN14@readToken:

; 276  :    case '}':
; 277  :       token.type_ = tokenObjectEnd;

	mov	ecx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [ecx], 2

; 278  :       break;

	jmp	$LN16@readToken
$LN13@readToken:

; 279  :    case '[':
; 280  :       token.type_ = tokenArrayBegin;

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [edx], 3

; 281  :       break;

	jmp	$LN16@readToken
$LN12@readToken:

; 282  :    case ']':
; 283  :       token.type_ = tokenArrayEnd;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 4

; 284  :       break;

	jmp	$LN16@readToken
$LN11@readToken:

; 285  :    case '"':
; 286  :       token.type_ = tokenString;

	mov	ecx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [ecx], 5

; 287  :       ok = readString();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readString@Reader@Json@@AAE_NXZ	; Json::Reader::readString
	mov	BYTE PTR _ok$[ebp], al

; 288  :       break;

	jmp	$LN16@readToken
$LN10@readToken:

; 289  :    case '/':
; 290  :       token.type_ = tokenComment;

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [edx], 12			; 0000000cH

; 291  :       ok = readComment();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readComment@Reader@Json@@AAE_NXZ	; Json::Reader::readComment
	mov	BYTE PTR _ok$[ebp], al

; 292  :       break;

	jmp	$LN16@readToken
$LN9@readToken:

; 293  :    case '0':
; 294  :    case '1':
; 295  :    case '2':
; 296  :    case '3':
; 297  :    case '4':
; 298  :    case '5':
; 299  :    case '6':
; 300  :    case '7':
; 301  :    case '8':
; 302  :    case '9':
; 303  :    case '-':
; 304  :       token.type_ = tokenNumber;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 6

; 305  :       readNumber();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readNumber@Reader@Json@@AAEXXZ		; Json::Reader::readNumber

; 306  :       break;

	jmp	SHORT $LN16@readToken
$LN8@readToken:

; 307  :    case 't':
; 308  :       token.type_ = tokenTrue;

	mov	ecx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [ecx], 7

; 309  :       ok = match( "rue", 3 );

	push	3
	push	OFFSET ??_C@_03FFDNHNKN@rue?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
	mov	BYTE PTR _ok$[ebp], al

; 310  :       break;

	jmp	SHORT $LN16@readToken
$LN7@readToken:

; 311  :    case 'f':
; 312  :       token.type_ = tokenFalse;

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [edx], 8

; 313  :       ok = match( "alse", 4 );

	push	4
	push	OFFSET ??_C@_04KCECFHEP@alse?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
	mov	BYTE PTR _ok$[ebp], al

; 314  :       break;

	jmp	SHORT $LN16@readToken
$LN6@readToken:

; 315  :    case 'n':
; 316  :       token.type_ = tokenNull;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 9

; 317  :       ok = match( "ull", 3 );

	push	3
	push	OFFSET ??_C@_03KNPGGKC@ull?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
	mov	BYTE PTR _ok$[ebp], al

; 318  :       break;

	jmp	SHORT $LN16@readToken
$LN5@readToken:

; 319  :    case ',':
; 320  :       token.type_ = tokenArraySeparator;

	mov	ecx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [ecx], 10			; 0000000aH

; 321  :       break;

	jmp	SHORT $LN16@readToken
$LN4@readToken:

; 322  :    case ':':
; 323  :       token.type_ = tokenMemberSeparator;

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [edx], 11			; 0000000bH

; 324  :       break;

	jmp	SHORT $LN16@readToken
$LN3@readToken:

; 325  :    case 0:
; 326  :       token.type_ = tokenEndOfStream;

	mov	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR [eax], 0

; 327  :       break;

	jmp	SHORT $LN16@readToken
$LN2@readToken:

; 328  :    default:
; 329  :       ok = false;

	mov	BYTE PTR _ok$[ebp], 0
$LN16@readToken:

; 330  :       break;
; 331  :    }
; 332  :    if ( !ok )

	movzx	ecx, BYTE PTR _ok$[ebp]
	test	ecx, ecx
	jne	SHORT $LN1@readToken

; 333  :       token.type_ = tokenError;

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR [edx], 13			; 0000000dH
$LN1@readToken:

; 334  :    token.end_ = current_;

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+8], edx

; 335  :    return true;

	mov	al, 1

; 336  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN21@readToken:
	DD	$LN3@readToken
	DD	$LN11@readToken
	DD	$LN5@readToken
	DD	$LN9@readToken
	DD	$LN10@readToken
	DD	$LN4@readToken
	DD	$LN13@readToken
	DD	$LN12@readToken
	DD	$LN7@readToken
	DD	$LN6@readToken
	DD	$LN8@readToken
	DD	$LN15@readToken
	DD	$LN14@readToken
	DD	$LN2@readToken
$LN20@readToken:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	2
	DB	3
	DB	13					; 0000000dH
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	6
	DB	13					; 0000000dH
	DB	7
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	8
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	9
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	10					; 0000000aH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	11					; 0000000bH
	DB	13					; 0000000dH
	DB	12					; 0000000cH
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readToken
_TEXT	ENDS
PUBLIC	?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ; Json::Reader::expectToken
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0
__ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
_TEXT	SEGMENT
_this$ = -48						; size = 4
$T78448 = -44						; size = 28
$T78447 = -13						; size = 1
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_token$ = 12						; size = 4
_message$ = 16						; size = 4
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z PROC ; Json::Reader::expectToken, COMDAT
; _this$ = ecx

; 256  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 257  :    readToken( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 258  :    if ( token.type_ != type )

	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx]
	cmp	edx, DWORD PTR _type$[ebp]
	je	SHORT $LN1@expectToke

; 259  :       return addError( message, token );

	mov	eax, DWORD PTR _message$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78448[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78448[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T78447[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78448[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T78447[ebp]
	jmp	SHORT $LN2@expectToke
$LN1@expectToke:

; 260  :    return true;

	mov	al, 1
$LN2@expectToke:

; 261  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR $T78448[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ENDP ; Json::Reader::expectToken
PUBLIC	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens
; Function compile flags: /Odtp
;	COMDAT ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_token$ = 8						; size = 4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z PROC	; Json::Reader::skipCommentTokens, COMDAT
; _this$ = ecx

; 238  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 239  :    if ( features_.allowComments_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+140]
	test	ecx, ecx
	je	SHORT $LN5@skipCommen
$LN4@skipCommen:

; 240  :    {
; 241  :       do
; 242  :       {
; 243  :          readToken( token );

	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 244  :       }
; 245  :       while ( token.type_ == tokenComment );

	mov	eax, DWORD PTR _token$[ebp]
	cmp	DWORD PTR [eax], 12			; 0000000cH
	je	SHORT $LN4@skipCommen

; 246  :    }
; 247  :    else

	jmp	SHORT $LN6@skipCommen
$LN5@skipCommen:

; 248  :    {
; 249  :       readToken( token );

	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
$LN6@skipCommen:

; 250  :    }
; 251  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ENDP	; Json::Reader::skipCommentTokens
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
PUBLIC	??_FValue@Json@@QAEXXZ				; Json::Value::`default constructor closure'
; Function compile flags: /Odtp
;	COMDAT ??_FValue@Json@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??_FValue@Json@@QAEXXZ PROC				; Json::Value::`default constructor closure', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	esp, ebp
	pop	ebp
	ret	0
??_FValue@Json@@QAEXXZ ENDP				; Json::Value::`default constructor closure'
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
;	COMDAT ?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
__Start$ = -8						; size = 8
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse, COMDAT
; _this$ = ecx

; 1031 : 		{	// reverse a subrange

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 1032 : 		iterator _Start = begin();

	lea	eax, DWORD PTR __Start$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin

; 1033 : 		for (; _First != _Last && _First != --_Last; ++_First)

	jmp	SHORT $LN3@Reverse@2
$LN2@Reverse@2:
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 1
	mov	DWORD PTR __First$[ebp], ecx
$LN3@Reverse@2:
	mov	edx, DWORD PTR __First$[ebp]
	cmp	edx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Reverse@2
	mov	eax, DWORD PTR __Last$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Last$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	cmp	ecx, DWORD PTR __Last$[ebp]
	je	SHORT $LN4@Reverse@2

; 1034 : 			_STD _Swap_adl(_Start[_First], _Start[_Last]);

	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __Start$[ebp]
	call	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Start$[ebp]
	call	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
	push	eax
	call	??$_Swap_adl@VErrorInfo@Reader@Json@@@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::_Swap_adl<Json::Reader::ErrorInfo>
	add	esp, 8
	jmp	SHORT $LN2@Reverse@2
$LN4@Reverse@2:

; 1035 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78623 = -28						; size = 8
$T78622 = -20						; size = 8
$T78621 = -11						; size = 1
$T78620 = -10						; size = 1
$T78619 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78619[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78620[ebp], al
	movzx	ecx, BYTE PTR $T78619[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78620[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78621[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78622[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78623[ebp]
	push	ecx
	call	??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2690 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z
_TEXT	SEGMENT
$T78630 = -28						; size = 8
$T78629 = -20						; size = 8
$T78628 = -11						; size = 1
$T78627 = -10						; size = 1
$T78626 = -9						; size = 1
__Result$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
___formal$ = 44						; size = 1
??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z PROC ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 2685 : 	{	// copy [_First, _Last) backwards to [..., _Dest), arbitrary iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH

; 2686 : 	// if _OutIt is range checked, this will make sure there is enough space for the copy
; 2687 : 	_OutIt _Result = _Dest - (_Last - _First);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>::operator-
	push	eax
	lea	ecx, DWORD PTR __Result$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Dest$[ebp]
	call	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-

; 2688 : 	_Copy_backward_opt(_First, _Last, _CHECKED_BASE(_Dest),
; 2689 : 		forward_iterator_tag(), _Nonscalar_ptr_iterator_tag(), _Range_checked_iterator_tag());

	xor	edx, edx
	mov	BYTE PTR $T78626[ebp], dl
	xor	eax, eax
	mov	BYTE PTR $T78627[ebp], al
	movzx	ecx, BYTE PTR $T78626[ebp]
	push	ecx
	movzx	edx, BYTE PTR $T78627[ebp]
	push	edx
	movzx	eax, BYTE PTR $T78628[ebp]
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78629[ebp]
	push	edx
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78630[ebp]
	push	ecx
	call	??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V12@Uforward_iterator_tag@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@V10@00Uforward_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::forward_iterator_tag>
	add	esp, 40					; 00000028H

; 2690 : 	return _Result;

	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	eax, DWORD PTR __Result$[ebp]
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR __Result$[ebp+4]
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2691 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ENDP ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
_TEXT	ENDS
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
xdata$x	SEGMENT
__unwindtable$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$4
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$5
	DD	0ffffffffH
	DD	00H
__catchsym$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$0
__catchsym$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$2
__tryblocktable$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$6
	DD	03H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$7
__ehfuncinfo$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
_TEXT	SEGMENT
tv185 = -148						; size = 4
tv188 = -144						; size = 4
tv182 = -140						; size = 4
tv187 = -136						; size = 4
_this$ = -132						; size = 4
$T78635 = -128						; size = 44
$T78634 = -84						; size = 44
$T78633 = -40						; size = 8
__Num$63863 = -32					; size = 4
__Off$ = -28						; size = 4
__Rem$ = -24						; size = 4
__Oldsize$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT
; _this$ = ecx

; 971  : 		void _Insert(const_iterator _Where,

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 132				; 00000084H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 972  : 			_It _First, _It _Last, input_iterator_tag)
; 973  : 		{	// insert [_First, _Last) at _Where, input iterators
; 974  : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T78633[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
	mov	DWORD PTR __Off$[ebp], eax

; 975  : 
; 976  :  #if _HAS_ITERATOR_DEBUGGING
; 977  : 		if (_Mysize < _Off)
; 978  : 			_DEBUG_ERROR("deque insert iterator outside range");
; 979  : 		_DEBUG_RANGE(_First, _Last);
; 980  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 981  : 
; 982  : 		size_type _Rem = _Mysize - _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Rem$[ebp], edx

; 983  : 		size_type _Oldsize = _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 984  : 
; 985  : 		if (_First == _Last)

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??8?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN19@Insert@2
	jmp	$LN21@Insert@2
$LN19@Insert@2:

; 986  : 			;
; 987  : 		else if (_Off < _Rem)

	mov	ecx, DWORD PTR __Off$[ebp]
	cmp	ecx, DWORD PTR __Rem$[ebp]
	jae	$LN17@Insert@2

; 988  : 			{	// closer to front
; 989  : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 990  : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN15@Insert@2
$LN14@Insert@2:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator++
$LN15@Insert@2:
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@Insert@2

; 991  : 				push_front((value_type)*_First);	// prepend flipped

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
	push	eax
	lea	ecx, DWORD PTR $T78634[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR tv187[ebp], eax
	mov	ecx, DWORD PTR tv187[ebp]
	mov	DWORD PTR tv182[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 1
	mov	edx, DWORD PTR tv182[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR $T78634[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	jmp	SHORT $LN14@Insert@2
$LN13@Insert@2:
	jmp	SHORT $LN22@Insert@2
__catch$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$0:
$LN12@Insert@2:

; 992  : 
; 993  : 			_CATCH_ALL
; 994  : 			for (; _Oldsize < _Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jae	SHORT $LN11@Insert@2

; 995  : 				pop_front();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
	jmp	SHORT $LN12@Insert@2
$LN11@Insert@2:

; 996  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 997  : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$1
	ret	0
$LN22@Insert@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$1:

; 998  : 
; 999  : 			size_type _Num = _Mysize - _Oldsize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	sub	eax, DWORD PTR __Oldsize$[ebp]
	mov	DWORD PTR __Num$63863[ebp], eax

; 1000 : 
; 1001 : 			if (0 < _Off)

	cmp	DWORD PTR __Off$[ebp], 0
	jbe	SHORT $LN10@Insert@2

; 1002 : 				{	// insert not at beginning, flip new stuff into place
; 1003 : 				_Reverse(_Num, _Num + _Off);

	mov	ecx, DWORD PTR __Num$63863[ebp]
	add	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Num$63863[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse

; 1004 : 				_Reverse(0, _Num + _Off);

	mov	eax, DWORD PTR __Num$63863[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse

; 1005 : 				}
; 1006 : 			else

	jmp	SHORT $LN9@Insert@2
$LN10@Insert@2:

; 1007 : 				_Reverse(0, _Num);	// flip new stuff in place

	mov	ecx, DWORD PTR __Num$63863[ebp]
	push	ecx
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse
$LN9@Insert@2:

; 1008 : 			}
; 1009 : 		else

	jmp	$LN21@Insert@2
$LN17@Insert@2:

; 1010 : 			{	// closer to back
; 1011 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 3

; 1012 : 			for (; _First != _Last; ++_First)

	jmp	SHORT $LN6@Insert@2
$LN5@Insert@2:
	lea	ecx, DWORD PTR __First$[ebp]
	call	??E?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator++
$LN6@Insert@2:
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN4@Insert@2

; 1013 : 				push_back((value_type)*_First);	// append

	lea	ecx, DWORD PTR __First$[ebp]
	call	??D?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator*
	push	eax
	lea	ecx, DWORD PTR $T78635[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR tv188[ebp], eax
	mov	ecx, DWORD PTR tv188[ebp]
	mov	DWORD PTR tv185[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+12], 4
	mov	edx, DWORD PTR tv185[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	lea	ecx, DWORD PTR $T78635[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	jmp	SHORT $LN5@Insert@2
$LN4@Insert@2:
	jmp	SHORT $LN24@Insert@2
__catch$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$2:
$LN3@Insert@2:

; 1014 : 
; 1015 : 			_CATCH_ALL
; 1016 : 			for (; _Oldsize < _Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jae	SHORT $LN2@Insert@2

; 1017 : 				pop_back();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN3@Insert@2
$LN2@Insert@2:

; 1018 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1019 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$3
	ret	0
$LN24@Insert@2:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$3:

; 1020 : 
; 1021 : 			if (_Off < _Oldsize)

	mov	edx, DWORD PTR __Off$[ebp]
	cmp	edx, DWORD PTR __Oldsize$[ebp]
	jae	SHORT $LN21@Insert@2

; 1022 : 				{	// insert not at end, flip new stuff into place
; 1023 : 				_Reverse(_Off, _Oldsize);

	mov	eax, DWORD PTR __Oldsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse

; 1024 : 				_Reverse(_Oldsize, _Mysize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse

; 1025 : 				_Reverse(_Off, _Mysize);

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reverse@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXII@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Reverse
$LN21@Insert@2:

; 1026 : 				}
; 1027 : 			}
; 1028 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$4:
	lea	ecx, DWORD PTR $T78634[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__unwindfunclet$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z$5:
	lea	ecx, DWORD PTR $T78635[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-152]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\xutility
;	COMDAT ??$copy_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z
_TEXT	SEGMENT
$T78663 = -20						; size = 8
$T78662 = -12						; size = 8
$T78661 = -3						; size = 1
$T78660 = -2						; size = 1
$T78659 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z PROC ; std::copy_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT

; 2721 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2722 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2723 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T78659[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	BYTE PTR $T78660[ebp], al
	movzx	eax, BYTE PTR $T78659[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78660[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78661[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78662[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78663[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,0>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2724 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ENDP ; std::copy_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$copy_backward@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z
_TEXT	SEGMENT
$T78670 = -20						; size = 8
$T78669 = -12						; size = 8
$T78668 = -3						; size = 1
$T78667 = -2						; size = 1
$T78666 = -1						; size = 1
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 8
__Last$ = 20						; size = 8
__Dest$ = 28						; size = 8
??$copy_backward@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z PROC ; std::copy_backward<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >, COMDAT

; 2721 : 	{	// copy [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H

; 2722 : 	return _Copy_backward_opt(_CHECKED_BASE(_First), _CHECKED_BASE(_Last), _Dest,
; 2723 : 		_Iter_random(_First, _Dest), _Ptr_cat(_First, _Dest), _STD _Range_checked_iterator_tag());

	xor	eax, eax
	mov	BYTE PTR $T78666[ebp], al
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Ptr_cat@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AU_Nonscalar_ptr_iterator_tag@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ; std::_Ptr_cat<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	BYTE PTR $T78667[ebp], al
	movzx	eax, BYTE PTR $T78666[ebp]
	push	eax
	movzx	ecx, BYTE PTR $T78667[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78668[ebp]
	push	ecx
	call	??$_Iter_random@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0@Z ; std::_Iter_random<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 12					; 0000000cH
	movzx	edx, BYTE PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78669[ebp]
	push	eax
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78670[ebp]
	push	ecx
	call	??$_Checked_base@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@AAV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@@Z ; std::_Checked_base<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 8
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	??$_Copy_backward_opt@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$0A@@0@0V10@Urandom_access_iterator_tag@0@U_Nonscalar_ptr_iterator_tag@0@U_Range_checked_iterator_tag@0@@Z ; std::_Copy_backward_opt<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,0>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2724 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$copy_backward@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z ENDP ; std::copy_backward<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\deque
_TEXT	ENDS
;	COMDAT ??$insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T78674 = -2						; size = 1
$T78673 = -1						; size = 1
__Where$ = 8						; size = 8
__First$ = 16						; size = 8
__Last$ = 24						; size = 8
??$insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >, COMDAT
; _this$ = ecx

; 958  : 		void insert(const_iterator _Where, _It _First, _It _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 959  : 		{	// insert [_First, _Last) at _Where
; 960  : 		_Insert(_Where, _First, _Last, _Iter_cat(_First));

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78673[ebp]
	push	ecx
	call	??$_Iter_cat@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@std@@YA?AUrandom_access_iterator_tag@0@ABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@@Z ; std::_Iter_cat<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 8
	movzx	edx, BYTE PTR $T78674[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Where$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Where$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00Uinput_iterator_tag@1@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >

; 961  : 		}

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
??$insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
_TEXT	ENDS
PUBLIC	__$ArrayPad$
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	00H
	DD	00H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$4
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$5
	DD	0ffffffffH
	DD	00H
__catchsym$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$6 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$0
__catchsym$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$7 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$2
__tryblocktable$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z DD 00H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$6
	DD	03H
	DD	04H
	DD	05H
	DD	01H
	DD	FLAT:__catchsym$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$7
__ehfuncinfo$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
tv319 = -352						; size = 4
tv318 = -348						; size = 4
_this$ = -344						; size = 4
$T78703 = -340						; size = 8
$T78702 = -332						; size = 8
$T78701 = -324						; size = 8
$T78700 = -316						; size = 8
$T78699 = -308						; size = 8
$T78698 = -300						; size = 8
$T78697 = -292						; size = 8
$T78696 = -284						; size = 8
$T78695 = -276						; size = 8
$T78694 = -268						; size = 8
$T78693 = -260						; size = 8
$T78692 = -252						; size = 8
$T78691 = -244						; size = 8
$T78690 = -236						; size = 8
$T78689 = -228						; size = 8
$T78688 = -220						; size = 8
$T78687 = -212						; size = 8
$T78686 = -204						; size = 8
$T78685 = -196						; size = 8
$T78684 = -188						; size = 8
$T78683 = -180						; size = 8
$T78682 = -172						; size = 8
$T78681 = -164						; size = 8
$T78680 = -156						; size = 8
$T78679 = -148						; size = 8
$T78678 = -140						; size = 8
__Tmp$60873 = -132					; size = 44
__Tmp$60843 = -88					; size = 44
__$ArrayPad$ = -44					; size = 4
__Off$ = -40						; size = 4
__Rem$ = -36						; size = 4
__Num$ = -32						; size = 4
__Mid$ = -28						; size = 8
__Oldsize$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Where$ = 8						; size = 8
__Count$ = 16						; size = 4
__Val$ = 20						; size = 4
?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n, COMDAT
; _this$ = ecx

; 1130 : 		{	// insert _Count * _Val at _Where

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 336				; 00000150H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1131 : 		iterator _Mid;

	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??0?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QAE@XZ ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>

; 1132 : 		size_type _Num;
; 1133 : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T78678[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	push	eax
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??G?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
	mov	DWORD PTR __Off$[ebp], eax

; 1134 : 		size_type _Rem = _Mysize - _Off;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	sub	edx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Rem$[ebp], edx

; 1135 : 		size_type _Oldsize = _Mysize;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	mov	DWORD PTR __Oldsize$[ebp], ecx

; 1136 : 
; 1137 :  #if _HAS_ITERATOR_DEBUGGING
; 1138 : 		if (_Mysize < _Off)
; 1139 : 			_DEBUG_ERROR("deque insert iterator outside range");
; 1140 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1141 : 
; 1142 : 		if (_Off < _Rem)

	mov	edx, DWORD PTR __Off$[ebp]
	cmp	edx, DWORD PTR __Rem$[ebp]
	jae	$LN30@Insert_n@4

; 1143 : 			{	// closer to front
; 1144 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1145 : 			if (_Off < _Count)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	$LN28@Insert_n@4

; 1146 : 				{	// insert longer than prefix
; 1147 : 				for (_Num = _Count - _Off; 0 < _Num; --_Num)

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	jmp	SHORT $LN27@Insert_n@4
$LN26@Insert_n@4:
	mov	edx, DWORD PTR __Num$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Num$[ebp], edx
$LN27@Insert_n@4:
	cmp	DWORD PTR __Num$[ebp], 0
	jbe	SHORT $LN25@Insert_n@4

; 1148 : 					push_front(_Val);	// push excess values

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
	jmp	SHORT $LN26@Insert_n@4
$LN25@Insert_n@4:

; 1149 : 				for (_Num = _Off; 0 < _Num; --_Num)

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Num$[ebp], ecx
	jmp	SHORT $LN24@Insert_n@4
$LN23@Insert_n@4:
	mov	edx, DWORD PTR __Num$[ebp]
	sub	edx, 1
	mov	DWORD PTR __Num$[ebp], edx
$LN24@Insert_n@4:
	cmp	DWORD PTR __Num$[ebp], 0
	jbe	SHORT $LN22@Insert_n@4

; 1150 : 					push_front(begin()[_Count - 1]);	// push prefix

	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, 1
	push	eax
	lea	ecx, DWORD PTR $T78679[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
	jmp	SHORT $LN23@Insert_n@4
$LN22@Insert_n@4:

; 1151 : 
; 1152 : 				_Mid = begin() + _Count;

	mov	edx, DWORD PTR __Count$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78681[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78680[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR __Mid$[ebp], edx
	mov	DWORD PTR __Mid$[ebp+4], eax

; 1153 : 				std::fill(_Mid, _Mid + _Off,
; 1154 : 					_Val);	// fill in rest of values

	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78682[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>
	add	esp, 20					; 00000014H

; 1155 : 				}
; 1156 : 			else

	jmp	$LN21@Insert_n@4
$LN28@Insert_n@4:

; 1157 : 				{	// insert not longer than prefix
; 1158 : 				for (_Num = _Count; 0 < _Num; --_Num)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Num$[ebp], edx
	jmp	SHORT $LN20@Insert_n@4
$LN19@Insert_n@4:
	mov	eax, DWORD PTR __Num$[ebp]
	sub	eax, 1
	mov	DWORD PTR __Num$[ebp], eax
$LN20@Insert_n@4:
	cmp	DWORD PTR __Num$[ebp], 0
	jbe	SHORT $LN18@Insert_n@4

; 1159 : 					push_front(begin()[_Count - 1]);	// push part of prefix

	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	push	ecx
	lea	edx, DWORD PTR $T78683[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
	jmp	SHORT $LN19@Insert_n@4
$LN18@Insert_n@4:

; 1160 : 
; 1161 : 				_Mid = begin() + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78685[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78684[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Mid$[ebp], ecx
	mov	DWORD PTR __Mid$[ebp+4], edx

; 1162 : 				_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$60843[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR tv318[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 1163 : 				std::copy(_Mid + _Count, _Mid + _Off,
; 1164 : 					_Mid);	// copy rest of prefix

	mov	ecx, DWORD PTR __Mid$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Mid$[ebp]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78686[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78687[ebp]
	push	edx
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78688[ebp]
	push	eax
	call	??$copy@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 28					; 0000001cH

; 1165 : 				std::fill(begin() + _Off, _Mid + _Off,
; 1166 : 					_Tmp);	// fill in values

	lea	ecx, DWORD PTR __Tmp$60843[ebp]
	push	ecx
	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78689[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78691[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78690[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>
	add	esp, 20					; 00000014H

; 1167 : 				}

	mov	BYTE PTR __$EHRec$[ebp+12], 0
	lea	ecx, DWORD PTR __Tmp$60843[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
$LN21@Insert_n@4:
	jmp	SHORT $LN33@Insert_n@4
__catch$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$0:
$LN17@Insert_n@4:

; 1168 : 			_CATCH_ALL
; 1169 : 			for (; _Oldsize < _Mysize; )

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+28]
	jae	SHORT $LN16@Insert_n@4

; 1170 : 				pop_front();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
	jmp	SHORT $LN17@Insert_n@4
$LN16@Insert_n@4:

; 1171 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1172 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, __tryend$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$1
	ret	0
$LN33@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$1:

; 1173 : 			}
; 1174 : 		else

	jmp	$LN32@Insert_n@4
$LN30@Insert_n@4:

; 1175 : 			{		// closer to back
; 1176 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 3

; 1177 : 			if (_Rem < _Count)

	mov	edx, DWORD PTR __Rem$[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	jae	$LN13@Insert_n@4

; 1178 : 				{	// insert longer than suffix
; 1179 : 				for (_Num = _Count - _Rem; 0 < _Num; --_Num)

	mov	eax, DWORD PTR __Count$[ebp]
	sub	eax, DWORD PTR __Rem$[ebp]
	mov	DWORD PTR __Num$[ebp], eax
	jmp	SHORT $LN12@Insert_n@4
$LN11@Insert_n@4:
	mov	ecx, DWORD PTR __Num$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Num$[ebp], ecx
$LN12@Insert_n@4:
	cmp	DWORD PTR __Num$[ebp], 0
	jbe	SHORT $LN10@Insert_n@4

; 1180 : 					push_back(_Val);	// push excess values

	mov	edx, DWORD PTR __Val$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	jmp	SHORT $LN11@Insert_n@4
$LN10@Insert_n@4:

; 1181 : 				for (_Num = 0; _Num < _Rem; ++_Num)

	mov	DWORD PTR __Num$[ebp], 0
	jmp	SHORT $LN9@Insert_n@4
$LN8@Insert_n@4:
	mov	eax, DWORD PTR __Num$[ebp]
	add	eax, 1
	mov	DWORD PTR __Num$[ebp], eax
$LN9@Insert_n@4:
	mov	ecx, DWORD PTR __Num$[ebp]
	cmp	ecx, DWORD PTR __Rem$[ebp]
	jae	SHORT $LN7@Insert_n@4

; 1182 : 					push_back(begin()[_Off + _Num]);	// push suffix

	mov	edx, DWORD PTR __Off$[ebp]
	add	edx, DWORD PTR __Num$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78692[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	jmp	SHORT $LN8@Insert_n@4
$LN7@Insert_n@4:

; 1183 : 
; 1184 : 				_Mid = begin() + _Off;

	mov	ecx, DWORD PTR __Off$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78694[ebp]
	push	edx
	lea	eax, DWORD PTR $T78693[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Mid$[ebp], ecx
	mov	DWORD PTR __Mid$[ebp+4], edx

; 1185 : 				std::fill(_Mid, _Mid + _Rem,
; 1186 : 					_Val);	// fill in rest of values

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Rem$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78695[ebp]
	push	edx
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>
	add	esp, 20					; 00000014H

; 1187 : 				}
; 1188 : 			else

	jmp	$LN6@Insert_n@4
$LN13@Insert_n@4:

; 1189 : 				{	// insert not longer than prefix
; 1190 : 				for (_Num = 0; _Num < _Count; ++_Num)

	mov	DWORD PTR __Num$[ebp], 0
	jmp	SHORT $LN5@Insert_n@4
$LN4@Insert_n@4:
	mov	edx, DWORD PTR __Num$[ebp]
	add	edx, 1
	mov	DWORD PTR __Num$[ebp], edx
$LN5@Insert_n@4:
	mov	eax, DWORD PTR __Num$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@Insert_n@4

; 1191 : 					push_back(begin()[_Off + _Rem
; 1192 : 						- _Count + _Num]);	// push part of prefix

	mov	ecx, DWORD PTR __Off$[ebp]
	add	ecx, DWORD PTR __Rem$[ebp]
	sub	ecx, DWORD PTR __Count$[ebp]
	add	ecx, DWORD PTR __Num$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78696[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??A?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEAAVErrorInfo@Reader@Json@@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
	jmp	SHORT $LN4@Insert_n@4
$LN3@Insert_n@4:

; 1193 : 
; 1194 : 				_Mid = begin() + _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78698[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78697[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR __Mid$[ebp], ecx
	mov	DWORD PTR __Mid$[ebp+4], edx

; 1195 : 				_Ty _Tmp = _Val;	// in case _Val is in sequence

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Tmp$60873[ebp]
	call	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
	mov	DWORD PTR tv319[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+12], 4

; 1196 : 				std::copy_backward(_Mid, _Mid + _Rem - _Count,
; 1197 : 					_Mid + _Rem);	// copy rest of prefix

	mov	ecx, DWORD PTR __Rem$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78699[ebp]
	push	edx
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78701[ebp]
	push	ecx
	mov	edx, DWORD PTR __Rem$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78700[ebp]
	push	eax
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, eax
	call	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78702[ebp]
	push	edx
	call	??$copy_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 28					; 0000001cH

; 1198 : 				std::fill(_Mid, _Mid + _Count,
; 1199 : 					_Tmp);	// fill in values

	lea	eax, DWORD PTR __Tmp$60873[ebp]
	push	eax
	mov	ecx, DWORD PTR __Count$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78703[ebp]
	push	edx
	lea	ecx, DWORD PTR __Mid$[ebp]
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Mid$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$[ebp]
	push	ecx
	call	??$fill@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@VErrorInfo@Reader@Json@@@std@@YAXV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0ABVErrorInfo@Reader@Json@@@Z ; std::fill<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,Json::Reader::ErrorInfo>
	add	esp, 20					; 00000014H

; 1200 : 				}

	mov	BYTE PTR __$EHRec$[ebp+12], 3
	lea	ecx, DWORD PTR __Tmp$60873[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
$LN6@Insert_n@4:
	jmp	SHORT $LN35@Insert_n@4
__catch$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$2:
$LN2@Insert_n@4:

; 1201 : 			_CATCH_ALL
; 1202 : 			for (; _Oldsize < _Mysize; )

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Oldsize$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jae	SHORT $LN1@Insert_n@4

; 1203 : 				pop_back();	// restore old size, at least

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN2@Insert_n@4
$LN1@Insert_n@4:

; 1204 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1205 : 			_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, $LN32@Insert_n@4
	ret	0
$LN35@Insert_n@4:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN32@Insert_n@4:

; 1206 : 			}
; 1207 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$4:
	lea	ecx, DWORD PTR __Tmp$60843[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__unwindfunclet$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z$5:
	lea	ecx, DWORD PTR __Tmp$60873[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-356]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n
; Function compile flags: /Odtp
;	COMDAT ?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@0@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T78733 = -80						; size = 8
$T78732 = -72						; size = 8
$T78731 = -64						; size = 8
$T78730 = -56						; size = 8
$T78729 = -48						; size = 8
$T78728 = -40						; size = 8
$T78727 = -32						; size = 8
__Off$ = -24						; size = 4
__Last$ = -20						; size = 8
__First$ = -12						; size = 8
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@0@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase, COMDAT
; _this$ = ecx

; 1044 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter

; 1046 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter

; 1047 : 
; 1048 :  #if _HAS_ITERATOR_DEBUGGING
; 1049 : 		if (_Last < _First
; 1050 : 			|| _First < begin() || end() < _Last)
; 1051 : 			_DEBUG_ERROR("deque erase iterator outside range");
; 1052 : 		_DEBUG_RANGE(_First, _Last);
; 1053 : 
; 1054 : 		size_type _Off = _First - begin();
; 1055 : 		size_type _Count = _Last - _First;
; 1056 : 		bool _Moved = 0 < _Off && _Off + _Count < _Mysize;
; 1057 : 
; 1058 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1059 : 		size_type _Off = _First - begin();

	lea	eax, DWORD PTR $T78727[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
	mov	DWORD PTR __Off$[ebp], eax

; 1060 : 		size_type _Count = _Last - _First;

	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 1061 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1062 : 
; 1063 : 		if (_Off < (size_type)(end() - _Last))

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78728[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator-
	cmp	DWORD PTR __Off$[ebp], eax
	jae	SHORT $LN8@erase@5

; 1064 : 			{	// closer to front
; 1065 : 			std::copy_backward(begin(), _First, _Last);	// copy over hole

	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78729[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78730[ebp]
	push	eax
	call	??$copy_backward@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 28					; 0000001cH

; 1066 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN7@erase@5
$LN6@erase@5:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$LN7@erase@5:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN5@erase@5

; 1067 : 				pop_front();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
	jmp	SHORT $LN6@erase@5
$LN5@erase@5:

; 1068 : 			}
; 1069 : 		else

	jmp	SHORT $LN4@erase@5
$LN8@erase@5:

; 1070 : 			{	// closer to back
; 1071 : 			std::copy(_Last, end(), _First);	// copy over hole

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78731[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78732[ebp]
	push	eax
	call	??$copy@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 28					; 0000001cH

; 1072 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN3@erase@5
$LN2@erase@5:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$LN3@erase@5:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@erase@5

; 1073 : 				pop_back();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
	jmp	SHORT $LN2@erase@5
$LN4@erase@5:

; 1074 : 			}
; 1075 : 
; 1076 :  #if _HAS_ITERATOR_DEBUGGING
; 1077 : 		if (_Moved)
; 1078 : 			this->_Orphan_all();
; 1079 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1080 : 
; 1081 : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78733[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1082 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@0@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z$0
__ehfuncinfo$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T78744 = -80						; size = 8
$T78743 = -72						; size = 8
$T78742 = -64						; size = 8
$T78741 = -56						; size = 8
$T78740 = -48						; size = 8
$T78739 = -40						; size = 8
$T78738 = -32						; size = 8
$T78737 = -24						; size = 8
__$EHRec$ = -12						; size = 12
__Newsize$ = 8						; size = 4
__Val$ = 12						; size = 44
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT
; _this$ = ecx

; 715  : 		{	// determine new length, padding with _Val elements as needed

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 716  : 		if (_Mysize < _Newsize)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+28]
	cmp	ecx, DWORD PTR __Newsize$[ebp]
	jae	SHORT $LN3@resize

; 717  : 			_Insert_n(end(), _Newsize - _Mysize, _Val);

	lea	edx, DWORD PTR $T78738[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78737[ebp], ecx
	mov	DWORD PTR $T78737[ebp+4], edx
	lea	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR __Newsize$[ebp]
	sub	edx, DWORD PTR [ecx+28]
	push	edx
	mov	eax, DWORD PTR $T78737[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78737[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Insert_n@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@IABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Insert_n
	jmp	SHORT $LN2@resize
$LN3@resize:

; 718  : 		else if (_Newsize < _Mysize)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, DWORD PTR [edx+28]
	jae	SHORT $LN2@resize

; 719  : 			erase(begin() + _Newsize, end());

	lea	ecx, DWORD PTR $T78740[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78739[ebp], edx
	mov	DWORD PTR $T78739[ebp+4], eax
	mov	ecx, DWORD PTR __Newsize$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78743[ebp]
	push	edx
	lea	eax, DWORD PTR $T78742[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78741[ebp], ecx
	mov	DWORD PTR $T78741[ebp+4], edx
	mov	eax, DWORD PTR $T78739[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78739[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78741[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78741[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78744[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
$LN2@resize:

; 720  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Val$[ebp]
	call	??1ErrorInfo@Reader@Json@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	48					; 00000030H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z$0:
	lea	ecx, DWORD PTR __Val$[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; Function compile flags: /Odtp
;	COMDAT ?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@0@Z
_TEXT	SEGMENT
_this$ = -84						; size = 4
$T78760 = -80						; size = 8
$T78759 = -72						; size = 8
$T78758 = -64						; size = 8
$T78757 = -56						; size = 8
$T78756 = -48						; size = 8
$T78755 = -40						; size = 8
$T78754 = -32						; size = 8
__Off$ = -24						; size = 4
__Last$ = -20						; size = 8
__First$ = -12						; size = 8
__Count$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 8
__Last_arg$ = 20					; size = 8
?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@0@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase, COMDAT
; _this$ = ecx

; 1044 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	DWORD PTR _this$[ebp], ecx

; 1045 : 		iterator _First = _Make_iter(_First_arg);

	mov	eax, DWORD PTR __First_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter

; 1046 : 		iterator _Last = _Make_iter(_Last_arg);

	mov	eax, DWORD PTR __Last_arg$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Last_arg$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter

; 1047 : 
; 1048 :  #if _HAS_ITERATOR_DEBUGGING
; 1049 : 		if (_Last < _First
; 1050 : 			|| _First < begin() || end() < _Last)
; 1051 : 			_DEBUG_ERROR("deque erase iterator outside range");
; 1052 : 		_DEBUG_RANGE(_First, _Last);
; 1053 : 
; 1054 : 		size_type _Off = _First - begin();
; 1055 : 		size_type _Count = _Last - _First;
; 1056 : 		bool _Moved = 0 < _Off && _Off + _Count < _Mysize;
; 1057 : 
; 1058 :  #else /* _HAS_ITERATOR_DEBUGGING */
; 1059 : 		size_type _Off = _First - begin();

	lea	eax, DWORD PTR $T78754[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
	mov	DWORD PTR __Off$[ebp], eax

; 1060 : 		size_type _Count = _Last - _First;

	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
	mov	DWORD PTR __Count$[ebp], eax

; 1061 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1062 : 
; 1063 : 		if (_Off < (size_type)(end() - _Last))

	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78755[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBEHABV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator-
	cmp	DWORD PTR __Off$[ebp], eax
	jae	SHORT $LN8@erase@6

; 1064 : 			{	// closer to front
; 1065 : 			std::copy_backward(begin(), _First, _Last);	// copy over hole

	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78756[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78757[ebp]
	push	eax
	call	??$copy_backward@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z ; std::copy_backward<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 28					; 0000001cH

; 1066 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN7@erase@6
$LN6@erase@6:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$LN7@erase@6:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN5@erase@6

; 1067 : 				pop_front();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
	jmp	SHORT $LN6@erase@6
$LN5@erase@6:

; 1068 : 			}
; 1069 : 		else

	jmp	SHORT $LN4@erase@6
$LN8@erase@6:

; 1070 : 			{	// closer to back
; 1071 : 			std::copy(_Last, end(), _First);	// copy over hole

	mov	edx, DWORD PTR __First$[ebp+4]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78758[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	lea	eax, DWORD PTR $T78759[ebp]
	push	eax
	call	??$copy@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V12@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V10@00@Z ; std::copy<std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 28					; 0000001cH

; 1072 : 			for (; 0 < _Count; --_Count)

	jmp	SHORT $LN3@erase@6
$LN2@erase@6:
	mov	ecx, DWORD PTR __Count$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Count$[ebp], ecx
$LN3@erase@6:
	cmp	DWORD PTR __Count$[ebp], 0
	jbe	SHORT $LN4@erase@6

; 1073 : 				pop_back();	// pop copied elements

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
	jmp	SHORT $LN2@erase@6
$LN4@erase@6:

; 1074 : 			}
; 1075 : 
; 1076 :  #if _HAS_ITERATOR_DEBUGGING
; 1077 : 		if (_Moved)
; 1078 : 			this->_Orphan_all();
; 1079 :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 1080 : 
; 1081 : 		return (begin() + _Off);

	mov	edx, DWORD PTR __Off$[ebp]
	push	edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78760[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1082 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@0@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
tv80 = -12						; size = 4
_this$ = -8						; size = 4
$T78763 = -4						; size = 4
__Newsize$ = 8						; size = 4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT
; _this$ = ecx

; 710  : 		{	// determine new length, padding with _Ty() elements as needed

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 711  : 		resize(_Newsize, _Ty());

	sub	esp, 44					; 0000002cH
	mov	ecx, esp
	mov	DWORD PTR $T78763[ebp], esp
	call	??0ErrorInfo@Reader@Json@@QAE@XZ
	mov	DWORD PTR tv80[ebp], eax
	mov	eax, DWORD PTR __Newsize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXIVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 712  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T78780 = -128						; size = 8
$T78779 = -120						; size = 8
$T78778 = -112						; size = 8
$T78777 = -104						; size = 8
$T78776 = -96						; size = 8
$T78775 = -88						; size = 8
$T78774 = -80						; size = 8
$T78773 = -72						; size = 8
$T78772 = -64						; size = 8
$T78771 = -56						; size = 8
$T78770 = -48						; size = 8
$T78769 = -40						; size = 8
$T78768 = -32						; size = 8
$T78767 = -24						; size = 8
__Mid$58943 = -16					; size = 8
__Mid$58883 = -8					; size = 8
__Right$ = 8						; size = 4
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=, COMDAT
; _this$ = ecx

; 645  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN6@operator@52
	jmp	$LN5@operator@52
$LN6@operator@52:

; 647  : 			;
; 648  : 		else if (_Right._Mysize == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN4@operator@52

; 649  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
	jmp	$LN5@operator@52
$LN4@operator@52:

; 650  : 		else if (_Right._Mysize <= _Mysize)

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	cmp	ecx, DWORD PTR [eax+28]
	ja	$LN2@operator@52

; 651  : 			{	// new sequence not longer, assign elements and erase unused
; 652  : 			iterator _Mid = std::copy(_Right.begin(), _Right.end(), begin());

	lea	edx, DWORD PTR $T78767[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78768[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78769[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Mid$58883[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 28					; 0000001cH

; 653  : 			erase(_Mid, end());

	lea	ecx, DWORD PTR $T78771[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78770[ebp], edx
	mov	DWORD PTR $T78770[ebp+4], eax
	mov	ecx, DWORD PTR __Mid$58883[ebp]
	mov	DWORD PTR $T78772[ebp], ecx
	mov	edx, DWORD PTR __Mid$58883[ebp+4]
	mov	DWORD PTR $T78772[ebp+4], edx
	mov	eax, DWORD PTR $T78770[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78770[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78772[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78772[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78773[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase

; 654  : 			}
; 655  : 		else

	jmp	$LN5@operator@52
$LN2@operator@52:

; 656  : 			{	// new sequence longer, assign elements and append rest
; 657  : 			const_iterator _Mid = _Right.begin() + _Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	lea	ecx, DWORD PTR __Mid$58943[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78774[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>::operator+

; 658  : 			std::copy(_Right.begin(), _Mid, begin());

	lea	eax, DWORD PTR $T78775[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Mid$58943[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$58943[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78776[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78777[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@V?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1>,std::_Deque_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	add	esp, 28					; 0000001cH

; 659  : 			insert(end(), _Mid, _Right.end());

	lea	ecx, DWORD PTR $T78780[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78779[ebp], edx
	mov	DWORD PTR $T78779[ebp+4], eax
	lea	ecx, DWORD PTR $T78778[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Mid$58943[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Mid$58943[ebp]
	push	edx
	mov	eax, DWORD PTR $T78779[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78779[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
$LN5@operator@52:

; 660  : 			}
; 661  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$3
__ehfuncinfo$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -56						; size = 4
$T78787 = -52						; size = 8
$T78786 = -44						; size = 8
$T78785 = -36						; size = 8
$T78784 = -28						; size = 8
$T78783 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 587  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Right$[ebp]
	add	eax, 12					; 0000000cH
	push	ecx
	mov	ecx, esp
	mov	DWORD PTR $T78783[ebp], esp
	push	eax
	call	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAE@V?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Deque_val<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+16], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+20], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+28], 0

; 588  : 		_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 589  : 		insert(begin(), _Right.begin(), _Right.end());

	lea	edx, DWORD PTR $T78787[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR $T78786[ebp], ecx
	mov	DWORD PTR $T78786[ebp+4], edx
	lea	eax, DWORD PTR $T78784[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78785[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR $T78786[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78786[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@$00@1@00@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo>,1> >
	jmp	SHORT $LN4@deque@2
__catch$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$0:

; 590  : 		_CATCH_ALL
; 591  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 592  : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 593  : 		_CATCH_END

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN2@deque@2
	ret	0
$LN4@deque@2:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN2@deque@2:

; 594  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN3@deque@2:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_val@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
__ehhandler$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Odtp
;	COMDAT ??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -132						; size = 4
$T78817 = -128						; size = 8
$T78816 = -120						; size = 8
$T78815 = -112						; size = 8
$T78814 = -104						; size = 8
$T78813 = -96						; size = 8
$T78812 = -88						; size = 8
$T78811 = -80						; size = 8
$T78810 = -72						; size = 8
$T78809 = -64						; size = 8
$T78808 = -56						; size = 8
$T78807 = -48						; size = 8
$T78806 = -40						; size = 8
$T78805 = -32						; size = 8
$T78804 = -24						; size = 8
__Mid$58766 = -16					; size = 8
__Mid$58706 = -8					; size = 8
__Right$ = 8						; size = 4
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=, COMDAT
; _this$ = ecx

; 645  : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 132				; 00000084H
	mov	DWORD PTR _this$[ebp], ecx

; 646  : 		if (this == &_Right)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	eax, DWORD PTR __Right$[ebp]
	jne	SHORT $LN6@operator@53
	jmp	$LN5@operator@53
$LN6@operator@53:

; 647  : 			;
; 648  : 		else if (_Right._Mysize == 0)

	mov	ecx, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [ecx+28], 0
	jne	SHORT $LN4@operator@53

; 649  : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
	jmp	$LN5@operator@53
$LN4@operator@53:

; 650  : 		else if (_Right._Mysize <= _Mysize)

	mov	edx, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	cmp	ecx, DWORD PTR [eax+28]
	ja	$LN2@operator@53

; 651  : 			{	// new sequence not longer, assign elements and erase unused
; 652  : 			iterator _Mid = std::copy(_Right.begin(), _Right.end(), begin());

	lea	edx, DWORD PTR $T78804[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78805[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78806[ebp]
	push	eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR __Mid$58706[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 28					; 0000001cH

; 653  : 			erase(_Mid, end());

	lea	ecx, DWORD PTR $T78808[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78807[ebp], edx
	mov	DWORD PTR $T78807[ebp+4], eax
	mov	ecx, DWORD PTR __Mid$58706[ebp]
	mov	DWORD PTR $T78809[ebp], ecx
	mov	edx, DWORD PTR __Mid$58706[ebp+4]
	mov	DWORD PTR $T78809[ebp+4], edx
	mov	eax, DWORD PTR $T78807[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78807[ebp]
	push	ecx
	mov	edx, DWORD PTR $T78809[ebp+4]
	push	edx
	mov	eax, DWORD PTR $T78809[ebp]
	push	eax
	lea	ecx, DWORD PTR $T78810[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase

; 654  : 			}
; 655  : 		else

	jmp	$LN5@operator@53
$LN2@operator@53:

; 656  : 			{	// new sequence longer, assign elements and append rest
; 657  : 			const_iterator _Mid = _Right.begin() + _Mysize;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+28]
	push	eax
	lea	ecx, DWORD PTR __Mid$58766[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78811[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>::operator+

; 658  : 			std::copy(_Right.begin(), _Mid, begin());

	lea	eax, DWORD PTR $T78812[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	eax, DWORD PTR __Mid$58766[ebp+4]
	push	eax
	mov	ecx, DWORD PTR __Mid$58766[ebp]
	push	ecx
	lea	edx, DWORD PTR $T78813[ebp]
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR [eax]
	push	edx
	lea	eax, DWORD PTR $T78814[ebp]
	push	eax
	call	??$copy@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@V?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@@std@@YA?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1>,std::_Deque_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
	add	esp, 28					; 0000001cH

; 659  : 			insert(end(), _Mid, _Right.end());

	lea	ecx, DWORD PTR $T78817[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T78816[ebp], edx
	mov	DWORD PTR $T78816[ebp+4], eax
	lea	ecx, DWORD PTR $T78815[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	edx, DWORD PTR [eax+4]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Mid$58766[ebp+4]
	push	ecx
	mov	edx, DWORD PTR __Mid$58766[ebp]
	push	edx
	mov	eax, DWORD PTR $T78816[ebp+4]
	push	eax
	mov	ecx, DWORD PTR $T78816[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$insert@V?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@$00@1@00@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<Json::Value *,std::allocator<Json::Value *>,1> >
$LN5@operator@53:

; 660  : 			}
; 661  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 662  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
_TEXT	ENDS
PUBLIC	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
; Function compile flags: /Odtp
; File e:\newggdevelop\client\ggjsoncpp\json_reader.cpp
;	COMDAT ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_errorCount$ = -16					; size = 4
_skip$ = -12						; size = 12
_skipUntilToken$ = 8					; size = 4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z PROC ; Json::Reader::recoverFromError, COMDAT
; _this$ = ecx

; 797  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	DWORD PTR _this$[ebp], ecx

; 798  :    int errorCount = int(errors_.size());

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
	mov	DWORD PTR _errorCount$[ebp], eax
$LN5@recoverFro:

; 799  :    Token skip;
; 800  :    for (;;)
; 801  :    {
; 802  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@recoverFro

; 803  :          errors_.resize( errorCount ); // discard errors caused by recovery

	mov	edx, DWORD PTR _errorCount$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN3@recoverFro:

; 804  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$[ebp]
	cmp	eax, DWORD PTR _skipUntilToken$[ebp]
	je	SHORT $LN1@recoverFro
	cmp	DWORD PTR _skip$[ebp], 0
	jne	SHORT $LN2@recoverFro
$LN1@recoverFro:

; 805  :          break;

	jmp	SHORT $LN4@recoverFro
$LN2@recoverFro:

; 806  :    }

	jmp	SHORT $LN5@recoverFro
$LN4@recoverFro:

; 807  :    errors_.resize( errorCount );

	mov	ecx, DWORD PTR _errorCount$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 808  :    return false;

	xor	al, al

; 809  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ENDP ; Json::Reader::recoverFromError
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
_TEXT	ENDS
PUBLIC	??4Reader@Json@@QAEAAV01@ABV01@@Z		; Json::Reader::operator=
; Function compile flags: /Odtp
;	COMDAT ??4Reader@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??4Reader@Json@@QAEAAV01@ABV01@@Z PROC			; Json::Reader::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dx, WORD PTR [ecx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+140], dx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+142]
	mov	BYTE PTR [ecx+142], al
	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??4Reader@Json@@QAEAAV01@ABV01@@Z ENDP			; Json::Reader::operator=
_TEXT	ENDS
PUBLIC	??0Reader@Json@@QAE@ABV01@@Z			; Json::Reader::Reader
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0Reader@Json@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$2
__ehfuncinfo$??0Reader@Json@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0Reader@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Reader@Json@@QAE@ABV01@@Z PROC			; Json::Reader::Reader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR ___that$[ebp]
	add	ecx, 32					; 00000020H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR ___that$[ebp]
	add	edx, 64					; 00000040H
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+92]
	mov	DWORD PTR [eax+92], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+96]
	mov	DWORD PTR [eax+96], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+100]
	mov	DWORD PTR [eax+100], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+104]
	mov	DWORD PTR [eax+104], edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+108]
	mov	DWORD PTR [eax+108], edx
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 112				; 00000070H
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	dx, WORD PTR [ecx+140]
	mov	eax, DWORD PTR _this$[ebp]
	mov	WORD PTR [eax+140], dx
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR ___that$[ebp]
	mov	al, BYTE PTR [edx+142]
	mov	BYTE PTR [ecx+142], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABV01@@Z ENDP			; Json::Reader::Reader
PUBLIC	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
; Function compile flags: /Odtp
;	COMDAT ?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_skipUntilToken$ = 16					; size = 4
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z PROC ; Json::Reader::addErrorAndRecover, COMDAT
; _this$ = ecx

; 816  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 817  :    addError( message, token );

	push	0
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _message$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError

; 818  :    return recoverFromError( skipUntilToken );

	mov	edx, DWORD PTR _skipUntilToken$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError

; 819  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ENDP ; Json::Reader::addErrorAndRecover
PUBLIC	__$ArrayPad$
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeString
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_this$ = -76						; size = 4
$T79043 = -69						; size = 1
$T79042 = -68						; size = 16
$T79041 = -45						; size = 1
_decoded$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 668  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 669  :    std::string decoded;

	lea	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 670  :    if ( !decodeString( token, decoded ) )

	lea	eax, DWORD PTR _decoded$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN1@decodeStri@2

; 671  :       return false;

	mov	BYTE PTR $T79041[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79041[ebp]
	jmp	SHORT $LN2@decodeStri@2
$LN1@decodeStri@2:

; 672  :    currentValue() = decoded;

	lea	eax, DWORD PTR _decoded$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79042[ebp]
	call	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T79042[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79042[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 673  :    return true;

	mov	BYTE PTR $T79043[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _decoded$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79043[ebp]
$LN2@decodeStri@2:

; 674  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _decoded$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T79042[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeString
PUBLIC	__$ArrayPad$
PUBLIC	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeDouble
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$5
__ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv178 = -272						; size = 4
tv180 = -268						; size = 4
tv176 = -264						; size = 4
tv73 = -260						; size = 4
tv174 = -256						; size = 4
tv93 = -252						; size = 4
_this$ = -248						; size = 4
$T79061 = -244						; size = 16
$T79060 = -228						; size = 28
$T79059 = -200						; size = 28
$T79058 = -172						; size = 28
$T79057 = -141						; size = 1
$T79056 = -140						; size = 28
$T79055 = -109						; size = 1
_buffer$56669 = -108					; size = 28
_buffer$56667 = -80					; size = 33
__$ArrayPad$ = -44					; size = 4
_bufferSize$ = -40					; size = 4
_format$ = -36						; size = 4
_length$ = -32						; size = 4
_value$ = -28						; size = 8
_count$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeDouble, COMDAT
; _this$ = ecx

; 628  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 629  :    double value = 0;

	fldz
	fstp	QWORD PTR _value$[ebp]

; 630  :    const int bufferSize = 32;

	mov	DWORD PTR _bufferSize$[ebp], 32		; 00000020H

; 631  :    int count;
; 632  :    int length = int(token.end_ - token.start_);

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [eax+8]
	sub	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _length$[ebp], edx

; 633  : 
; 634  :    // Sanity check to avoid buffer overflow exploits.
; 635  :    if (length < 0) {

	jns	SHORT $LN4@decodeDoub

; 636  :       return addError( "Unable to parse token length", token );

	push	OFFSET ??_C@_0BN@MIBOPDFC@Unable?5to?5parse?5token?5length?$AA@
	lea	ecx, DWORD PTR $T79056[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79056[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T79055[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79056[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79055[ebp]
	jmp	$LN5@decodeDoub
$LN4@decodeDoub:

; 637  :    }
; 638  : 
; 639  :    // Avoid using a string constant for the format control string given to
; 640  :    // sscanf, as this can cause hard to debug crashes on OS X. See here for more
; 641  :    // info:
; 642  :    //
; 643  :    //     http://developer.apple.com/library/mac/#DOCUMENTATION/DeveloperTools/gcc-4.0.1/gcc/Incompatibilities.html
; 644  :    char format[] = "%lf";

	mov	edx, DWORD PTR ??_C@_03DLDNIBIK@?$CFlf?$AA@
	mov	DWORD PTR _format$[ebp], edx

; 645  : 
; 646  :    if ( length <= bufferSize )

	cmp	DWORD PTR _length$[ebp], 32		; 00000020H
	jg	SHORT $LN3@decodeDoub

; 647  :    {
; 648  :       Char buffer[bufferSize+1];
; 649  :       memcpy( buffer, token.start_, length );

	mov	eax, DWORD PTR _length$[ebp]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	eax, DWORD PTR _buffer$56667[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 650  :       buffer[length] = 0;

	mov	ecx, DWORD PTR _length$[ebp]
	mov	BYTE PTR _buffer$56667[ebp+ecx], 0

; 651  :       count = sscanf( buffer, format, &value );

	lea	edx, DWORD PTR _value$[ebp]
	push	edx
	lea	eax, DWORD PTR _format$[ebp]
	push	eax
	lea	ecx, DWORD PTR _buffer$56667[ebp]
	push	ecx
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _count$[ebp], eax

; 652  :    }
; 653  :    else

	jmp	SHORT $LN2@decodeDoub
$LN3@decodeDoub:

; 654  :    {
; 655  :       std::string buffer( token.start_, token.end_ );

	mov	edx, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	ecx, DWORD PTR _buffer$56669[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 656  :       count = sscanf( buffer.c_str(), format, &value );

	lea	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR _format$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _buffer$56669[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	call	DWORD PTR __imp__sscanf
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _count$[ebp], eax

; 657  :    }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _buffer$56669[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@decodeDoub:

; 658  : 
; 659  :    if ( count != 1 )

	cmp	DWORD PTR _count$[ebp], 1
	je	$LN1@decodeDoub

; 660  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	edx, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR [edx+8]
	push	eax
	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	lea	ecx, DWORD PTR $T79058[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	mov	DWORD PTR tv93[ebp], eax
	mov	eax, DWORD PTR tv93[ebp]
	mov	DWORD PTR tv174[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv174[ebp]
	push	ecx
	push	OFFSET ??_C@_01GEODFPGF@?8?$AA@
	lea	edx, DWORD PTR $T79059[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv73[ebp], eax
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR tv176[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	ecx, DWORD PTR tv176[ebp]
	push	ecx
	lea	edx, DWORD PTR $T79060[ebp]
	push	edx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv180[ebp], eax
	mov	eax, DWORD PTR tv180[ebp]
	mov	DWORD PTR tv178[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	0
	mov	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv178[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T79057[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T79060[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T79059[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79058[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79057[ebp]
	jmp	SHORT $LN5@decodeDoub
$LN1@decodeDoub:

; 661  :    currentValue() = value;

	sub	esp, 8
	fld	QWORD PTR _value$[ebp]
	fstp	QWORD PTR [esp]
	lea	ecx, DWORD PTR $T79061[ebp]
	call	??0Value@Json@@QAE@N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	lea	eax, DWORD PTR $T79061[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79061[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 662  :    return true;

	mov	al, 1
$LN5@decodeDoub:

; 663  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T79056[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR _buffer$56669[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T79058[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T79059[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T79060[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$5:
	lea	ecx, DWORD PTR $T79061[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeDouble
PUBLIC	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeNumber
EXTRN	__allmul:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5
__ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv363 = -268						; size = 8
tv319 = -260						; size = 8
tv316 = -252						; size = 8
tv215 = -244						; size = 4
tv221 = -240						; size = 4
tv213 = -236						; size = 4
tv220 = -232						; size = 4
tv211 = -228						; size = 4
tv219 = -224						; size = 4
tv132 = -220						; size = 8
tv82 = -212						; size = 4
_this$ = -208						; size = 4
$T79087 = -204						; size = 16
$T79086 = -188						; size = 16
$T79085 = -172						; size = 16
$T79084 = -152						; size = 28
$T79083 = -124						; size = 28
$T79082 = -96						; size = 28
$T79081 = -66						; size = 1
_c$56632 = -65						; size = 1
_digit$56641 = -64					; size = 4
_inspect$56618 = -60					; size = 4
_isNegative$ = -53					; size = 1
_threshold$ = -52					; size = 8
_isDouble$ = -37					; size = 1
_value$ = -36						; size = 8
_current$ = -24						; size = 4
_maxIntegerValue$ = -20					; size = 8
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeNumber, COMDAT
; _this$ = ecx

; 574  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 575  :    bool isDouble = false;

	mov	BYTE PTR _isDouble$[ebp], 0

; 576  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _inspect$56618[ebp], ecx
	jmp	SHORT $LN16@decodeNumb
$LN15@decodeNumb:
	mov	edx, DWORD PTR _inspect$56618[ebp]
	add	edx, 1
	mov	DWORD PTR _inspect$56618[ebp], edx
$LN16@decodeNumb:
	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _inspect$56618[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	je	SHORT $LN14@decodeNumb

; 577  :    {
; 578  :       isDouble = isDouble  
; 579  :                  ||  in( *inspect, '.', 'e', 'E', '+' )  
; 580  :                  ||  ( *inspect == '-'  &&  inspect != token.start_ );

	movzx	edx, BYTE PTR _isDouble$[ebp]
	test	edx, edx
	jne	SHORT $LN19@decodeNumb
	push	43					; 0000002bH
	push	69					; 00000045H
	push	101					; 00000065H
	push	46					; 0000002eH
	mov	eax, DWORD PTR _inspect$56618[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	call	?in@Json@@YA_NDDDDD@Z			; Json::in
	add	esp, 20					; 00000014H
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN19@decodeNumb
	mov	eax, DWORD PTR _inspect$56618[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 45					; 0000002dH
	jne	SHORT $LN20@decodeNumb
	mov	edx, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR _inspect$56618[ebp]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN19@decodeNumb
$LN20@decodeNumb:
	mov	DWORD PTR tv82[ebp], 0
	jmp	SHORT $LN21@decodeNumb
$LN19@decodeNumb:
	mov	DWORD PTR tv82[ebp], 1
$LN21@decodeNumb:
	mov	cl, BYTE PTR tv82[ebp]
	mov	BYTE PTR _isDouble$[ebp], cl

; 581  :    }

	jmp	SHORT $LN15@decodeNumb
$LN14@decodeNumb:

; 582  :    if ( isDouble )

	movzx	edx, BYTE PTR _isDouble$[ebp]
	test	edx, edx
	je	SHORT $LN13@decodeNumb

; 583  :       return decodeDouble( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN17@decodeNumb
$LN13@decodeNumb:

; 584  :    // Attempts to parse the number as an integer. If the number is
; 585  :    // larger than the maximum supported value of an integer then
; 586  :    // we decode the number as a double.
; 587  :    Location current = token.start_;

	mov	ecx, DWORD PTR _token$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _current$[ebp], edx

; 588  :    bool isNegative = *current == '-';

	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	xor	edx, edx
	cmp	ecx, 45					; 0000002dH
	sete	dl
	mov	BYTE PTR _isNegative$[ebp], dl

; 589  :    if ( isNegative )

	movzx	eax, BYTE PTR _isNegative$[ebp]
	test	eax, eax
	je	SHORT $LN12@decodeNumb

; 590  :       ++current;

	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx
$LN12@decodeNumb:

; 591  :    Value::LargestUInt maxIntegerValue = isNegative ? Value::LargestUInt(-Value::minLargestInt) 
; 592  :                                                    : Value::maxLargestUInt;

	movzx	edx, BYTE PTR _isNegative$[ebp]
	test	edx, edx
	je	SHORT $LN22@decodeNumb
	mov	eax, DWORD PTR ?minLargestInt@Value@Json@@2_JB
	neg	eax
	mov	ecx, DWORD PTR ?minLargestInt@Value@Json@@2_JB+4
	adc	ecx, 0
	neg	ecx
	mov	DWORD PTR tv132[ebp], eax
	mov	DWORD PTR tv132[ebp+4], ecx
	jmp	SHORT $LN23@decodeNumb
$LN22@decodeNumb:
	mov	edx, DWORD PTR ?maxLargestUInt@Value@Json@@2_KB
	mov	DWORD PTR tv132[ebp], edx
	mov	eax, DWORD PTR ?maxLargestUInt@Value@Json@@2_KB+4
	mov	DWORD PTR tv132[ebp+4], eax
$LN23@decodeNumb:
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR _maxIntegerValue$[ebp], ecx
	mov	edx, DWORD PTR tv132[ebp+4]
	mov	DWORD PTR _maxIntegerValue$[ebp+4], edx

; 593  :    Value::LargestUInt threshold = maxIntegerValue / 10;

	push	0
	push	10					; 0000000aH
	mov	eax, DWORD PTR _maxIntegerValue$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _maxIntegerValue$[ebp]
	push	ecx
	call	__aulldiv
	mov	DWORD PTR _threshold$[ebp], eax
	mov	DWORD PTR _threshold$[ebp+4], edx

; 594  :    Value::LargestUInt value = 0;

	mov	DWORD PTR _value$[ebp], 0
	mov	DWORD PTR _value$[ebp+4], 0
$LN11@decodeNumb:

; 595  :    while ( current < token.end_ )

	mov	edx, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR _current$[ebp]
	cmp	eax, DWORD PTR [edx+8]
	jae	$LN10@decodeNumb

; 596  :    {
; 597  :       Char c = *current++;

	mov	ecx, DWORD PTR _current$[ebp]
	mov	dl, BYTE PTR [ecx]
	mov	BYTE PTR _c$56632[ebp], dl
	mov	eax, DWORD PTR _current$[ebp]
	add	eax, 1
	mov	DWORD PTR _current$[ebp], eax

; 598  :       if ( c < '0'  ||  c > '9' )

	movsx	ecx, BYTE PTR _c$56632[ebp]
	cmp	ecx, 48					; 00000030H
	jl	SHORT $LN8@decodeNumb
	movsx	edx, BYTE PTR _c$56632[ebp]
	cmp	edx, 57					; 00000039H
	jle	$LN9@decodeNumb
$LN8@decodeNumb:

; 599  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	mov	edx, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	lea	ecx, DWORD PTR $T79082[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0@Z
	mov	DWORD PTR tv219[ebp], eax
	mov	ecx, DWORD PTR tv219[ebp]
	mov	DWORD PTR tv211[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv211[ebp]
	push	edx
	push	OFFSET ??_C@_01GEODFPGF@?8?$AA@
	lea	eax, DWORD PTR $T79083[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv220[ebp], eax
	mov	ecx, DWORD PTR tv220[ebp]
	mov	DWORD PTR tv213[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	edx, DWORD PTR tv213[ebp]
	push	edx
	lea	eax, DWORD PTR $T79084[ebp]
	push	eax
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv221[ebp], eax
	mov	ecx, DWORD PTR tv221[ebp]
	mov	DWORD PTR tv215[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	0
	mov	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	eax, DWORD PTR tv215[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T79081[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T79084[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79083[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79082[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79081[ebp]
	jmp	$LN17@decodeNumb
$LN9@decodeNumb:

; 600  :       Value::UInt digit(c - '0');

	movsx	ecx, BYTE PTR _c$56632[ebp]
	sub	ecx, 48					; 00000030H
	mov	DWORD PTR _digit$56641[ebp], ecx

; 601  :       if ( value >= threshold )

	mov	edx, DWORD PTR _value$[ebp+4]
	cmp	edx, DWORD PTR _threshold$[ebp+4]
	jb	$LN7@decodeNumb
	ja	SHORT $LN30@decodeNumb
	mov	eax, DWORD PTR _value$[ebp]
	cmp	eax, DWORD PTR _threshold$[ebp]
	jb	SHORT $LN7@decodeNumb
$LN30@decodeNumb:

; 602  :       {
; 603  :          // We've hit or exceeded the max value divided by 10 (rounded down). If
; 604  :          // a) we've only just touched the limit, b) this is the last digit, and
; 605  :          // c) it's small enough to fit in that rounding delta, we're okay.
; 606  :          // Otherwise treat this number as a double to avoid overflow.
; 607  :          if (value > threshold ||
; 608  :              current != token.end_ ||
; 609  :              digit > maxIntegerValue % 10)

	mov	ecx, DWORD PTR _value$[ebp+4]
	cmp	ecx, DWORD PTR _threshold$[ebp+4]
	ja	SHORT $LN5@decodeNumb
	jb	SHORT $LN31@decodeNumb
	mov	edx, DWORD PTR _value$[ebp]
	cmp	edx, DWORD PTR _threshold$[ebp]
	ja	SHORT $LN5@decodeNumb
$LN31@decodeNumb:
	mov	eax, DWORD PTR _token$[ebp]
	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN5@decodeNumb
	mov	esi, DWORD PTR _digit$56641[ebp]
	xor	edi, edi
	push	0
	push	10					; 0000000aH
	mov	edx, DWORD PTR _maxIntegerValue$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _maxIntegerValue$[ebp]
	push	eax
	call	__aullrem
	mov	DWORD PTR tv316[ebp], esi
	mov	DWORD PTR tv316[ebp+4], edi
	mov	DWORD PTR tv319[ebp], eax
	mov	DWORD PTR tv319[ebp+4], edx
	mov	ecx, DWORD PTR tv316[ebp+4]
	cmp	ecx, DWORD PTR tv319[ebp+4]
	jb	SHORT $LN7@decodeNumb
	ja	SHORT $LN5@decodeNumb
	mov	edx, DWORD PTR tv316[ebp]
	cmp	edx, DWORD PTR tv319[ebp]
	jbe	SHORT $LN7@decodeNumb
$LN5@decodeNumb:

; 610  :          {
; 611  :             return decodeDouble( token );

	mov	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN17@decodeNumb
$LN7@decodeNumb:

; 612  :          }
; 613  :       }
; 614  :       value = value * 10 + digit;

	push	0
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _value$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	__allmul
	mov	ecx, DWORD PTR _digit$56641[ebp]
	xor	esi, esi
	add	eax, ecx
	adc	edx, esi
	mov	DWORD PTR _value$[ebp], eax
	mov	DWORD PTR _value$[ebp+4], edx

; 615  :    }

	jmp	$LN11@decodeNumb
$LN10@decodeNumb:

; 616  :    if ( isNegative )

	movzx	edx, BYTE PTR _isNegative$[ebp]
	test	edx, edx
	je	SHORT $LN4@decodeNumb

; 617  :       currentValue() = -Value::LargestInt( value );

	mov	eax, DWORD PTR _value$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _value$[ebp+4]
	adc	ecx, 0
	neg	ecx
	push	ecx
	push	eax
	lea	ecx, DWORD PTR $T79085[ebp]
	call	??0Value@Json@@QAE@_J@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	lea	edx, DWORD PTR $T79085[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79085[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	jmp	$LN3@decodeNumb
$LN4@decodeNumb:

; 618  :    else if ( value <= Value::LargestUInt(Value::maxInt) )

	mov	eax, DWORD PTR ?maxInt@Value@Json@@2HB	; Json::Value::maxInt
	cdq
	mov	DWORD PTR tv363[ebp], eax
	mov	DWORD PTR tv363[ebp+4], edx
	mov	eax, DWORD PTR _value$[ebp+4]
	cmp	eax, DWORD PTR tv363[ebp+4]
	ja	SHORT $LN2@decodeNumb
	jb	SHORT $LN33@decodeNumb
	mov	ecx, DWORD PTR _value$[ebp]
	cmp	ecx, DWORD PTR tv363[ebp]
	ja	SHORT $LN2@decodeNumb
$LN33@decodeNumb:

; 619  :       currentValue() = Value::LargestInt( value );

	mov	edx, DWORD PTR _value$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79086[ebp]
	call	??0Value@Json@@QAE@_J@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T79086[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79086[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 620  :    else

	jmp	SHORT $LN3@decodeNumb
$LN2@decodeNumb:

; 621  :       currentValue() = value;

	mov	edx, DWORD PTR _value$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79087[ebp]
	call	??0Value@Json@@QAE@_K@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T79087[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79087[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN3@decodeNumb:

; 622  :    return true;

	mov	al, 1
$LN17@decodeNumb:

; 623  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T79082[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T79083[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T79084[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T79085[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T79086[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5:
	lea	ecx, DWORD PTR $T79087[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-268]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeNumber
PUBLIC	?readValue@Reader@Json@@AAE_NXZ			; Json::Reader::readValue
PUBLIC	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readArray
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1
__ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv140 = -124						; size = 4
tv85 = -120						; size = 4
tv157 = -116						; size = 4
tv159 = -112						; size = 4
_this$ = -108						; size = 4
$T79178 = -104						; size = 28
$T79177 = -73						; size = 1
$T79174 = -72						; size = 4
$T79173 = -68						; size = 16
_badTokenType$56606 = -46				; size = 1
_ok$56600 = -45						; size = 1
_token$56602 = -44					; size = 12
_value$56598 = -32					; size = 4
_endArray$56593 = -28					; size = 12
_index$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readArray, COMDAT
; _this$ = ecx

; 531  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 532  :    currentValue() = Value( arrayValue );

	push	6
	lea	ecx, DWORD PTR $T79173[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv159[ebp], eax
	mov	eax, DWORD PTR tv159[ebp]
	mov	DWORD PTR tv157[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR tv157[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79173[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 533  :    skipSpaces();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipSpaces@Reader@Json@@AAEXXZ		; Json::Reader::skipSpaces

; 534  :    if ( *current_ == ']' ) // empty array

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+100]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 93					; 0000005dH
	jne	SHORT $LN9@readArray

; 535  :    {
; 536  :       Token endArray;
; 537  :       readToken( endArray );

	lea	edx, DWORD PTR _endArray$56593[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 538  :       return true;

	mov	al, 1
	jmp	$LN10@readArray
$LN9@readArray:

; 539  :    }
; 540  :    int index = 0;

	mov	DWORD PTR _index$[ebp], 0
$LN8@readArray:

; 541  :    for (;;)
; 542  :    {
; 543  :       Value &value = currentValue()[ index++ ];

	mov	eax, DWORD PTR _index$[ebp]
	mov	DWORD PTR tv85[ebp], eax
	mov	ecx, DWORD PTR tv85[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??AValue@Json@@QAEAAV01@H@Z		; Json::Value::operator[]
	mov	DWORD PTR _value$56598[ebp], eax
	mov	edx, DWORD PTR _index$[ebp]
	add	edx, 1
	mov	DWORD PTR _index$[ebp], edx

; 544  :       nodes_.push( &value );

	mov	eax, DWORD PTR _value$56598[ebp]
	mov	DWORD PTR $T79174[ebp], eax
	lea	ecx, DWORD PTR $T79174[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push

; 545  :       bool ok = readValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	BYTE PTR _ok$56600[ebp], al

; 546  :       nodes_.pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop

; 547  :       if ( !ok ) // error already set

	movzx	edx, BYTE PTR _ok$56600[ebp]
	test	edx, edx
	jne	SHORT $LN6@readArray

; 548  :          return recoverFromError( tokenArrayEnd );

	push	4
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	jmp	$LN10@readArray
$LN6@readArray:

; 549  : 
; 550  :       Token token;
; 551  :       // Accept Comment after last item in the array.
; 552  :       ok = readToken( token );

	lea	eax, DWORD PTR _token$56602[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _ok$56600[ebp], al
$LN5@readArray:

; 553  :       while ( token.type_ == tokenComment  &&  ok )

	cmp	DWORD PTR _token$56602[ebp], 12		; 0000000cH
	jne	SHORT $LN4@readArray
	movzx	ecx, BYTE PTR _ok$56600[ebp]
	test	ecx, ecx
	je	SHORT $LN4@readArray

; 554  :       {
; 555  :          ok = readToken( token );

	lea	edx, DWORD PTR _token$56602[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _ok$56600[ebp], al

; 556  :       }

	jmp	SHORT $LN5@readArray
$LN4@readArray:

; 557  :       bool badTokenType = ( token.type_ != tokenArraySeparator  &&
; 558  :                             token.type_ != tokenArrayEnd );

	cmp	DWORD PTR _token$56602[ebp], 10		; 0000000aH
	je	SHORT $LN12@readArray
	cmp	DWORD PTR _token$56602[ebp], 4
	je	SHORT $LN12@readArray
	mov	DWORD PTR tv140[ebp], 1
	jmp	SHORT $LN13@readArray
$LN12@readArray:
	mov	DWORD PTR tv140[ebp], 0
$LN13@readArray:
	mov	al, BYTE PTR tv140[ebp]
	mov	BYTE PTR _badTokenType$56606[ebp], al

; 559  :       if ( !ok  ||  badTokenType )

	movzx	ecx, BYTE PTR _ok$56600[ebp]
	test	ecx, ecx
	je	SHORT $LN2@readArray
	movzx	edx, BYTE PTR _badTokenType$56606[ebp]
	test	edx, edx
	je	SHORT $LN3@readArray
$LN2@readArray:

; 560  :       {
; 561  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 
; 562  :                                     token, 
; 563  :                                     tokenArrayEnd );

	push	OFFSET ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
	lea	ecx, DWORD PTR $T79178[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	4
	lea	eax, DWORD PTR _token$56602[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79178[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T79177[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79178[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79177[ebp]
	jmp	SHORT $LN10@readArray
$LN3@readArray:

; 564  :       }
; 565  :       if ( token.type_ == tokenArrayEnd )

	cmp	DWORD PTR _token$56602[ebp], 4
	jne	SHORT $LN1@readArray

; 566  :          break;

	jmp	SHORT $LN7@readArray
$LN1@readArray:

; 567  :    }

	jmp	$LN8@readArray
$LN7@readArray:

; 568  :    return true;

	mov	al, 1
$LN10@readArray:

; 569  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T79173[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T79178[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readArray
PUBLIC	__$ArrayPad$
PUBLIC	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4
__ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
tv203 = -220						; size = 4
tv65 = -216						; size = 4
_this$ = -212						; size = 4
$T79201 = -208						; size = 28
$T79200 = -178						; size = 1
$T79199 = -177						; size = 1
$T79198 = -176						; size = 28
$T79197 = -146						; size = 1
$T79196 = -145						; size = 1
$T79195 = -144						; size = 4
$T79194 = -140						; size = 28
$T79193 = -111						; size = 1
$T79192 = -110						; size = 1
$T79191 = -109						; size = 1
$T79190 = -108						; size = 16
_finalizeTokenOk$56578 = -89				; size = 1
_colon$56561 = -88					; size = 12
_comma$56572 = -76					; size = 12
_initialTokenOk$56551 = -62				; size = 1
_ok$56569 = -61						; size = 1
_value$56567 = -60					; size = 4
_tokenName$ = -56					; size = 12
_name$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___formal$ = 8						; size = 4
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readObject, COMDAT
; _this$ = ecx

; 472  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 208				; 000000d0H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 473  :    Token tokenName;
; 474  :    std::string name;

	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 475  :    currentValue() = Value( objectValue );

	push	7
	lea	ecx, DWORD PTR $T79190[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv203[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv203[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79190[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
$LN16@readObject:

; 476  :    while ( readToken( tokenName ) )

	lea	edx, DWORD PTR _tokenName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	eax, al
	test	eax, eax
	je	$LN15@readObject

; 477  :    {
; 478  :       bool initialTokenOk = true;

	mov	BYTE PTR _initialTokenOk$56551[ebp], 1
$LN14@readObject:

; 479  :       while ( tokenName.type_ == tokenComment  &&  initialTokenOk )

	cmp	DWORD PTR _tokenName$[ebp], 12		; 0000000cH
	jne	SHORT $LN13@readObject
	movzx	ecx, BYTE PTR _initialTokenOk$56551[ebp]
	test	ecx, ecx
	je	SHORT $LN13@readObject

; 480  :          initialTokenOk = readToken( tokenName );

	lea	edx, DWORD PTR _tokenName$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _initialTokenOk$56551[ebp], al
	jmp	SHORT $LN14@readObject
$LN13@readObject:

; 481  :       if  ( !initialTokenOk )

	movzx	eax, BYTE PTR _initialTokenOk$56551[ebp]
	test	eax, eax
	jne	SHORT $LN12@readObject

; 482  :          break;

	jmp	$LN15@readObject
$LN12@readObject:

; 483  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	cmp	DWORD PTR _tokenName$[ebp], 2
	jne	SHORT $LN11@readObject
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN11@readObject

; 484  :          return true;

	mov	BYTE PTR $T79191[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79191[ebp]
	jmp	$LN17@readObject
$LN11@readObject:

; 485  :       if ( tokenName.type_ != tokenString )

	cmp	DWORD PTR _tokenName$[ebp], 5
	je	SHORT $LN10@readObject

; 486  :          break;

	jmp	$LN15@readObject
$LN10@readObject:

; 487  :       
; 488  :       name = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 489  :       if ( !decodeString( tokenName, name ) )

	lea	edx, DWORD PTR _name$[ebp]
	push	edx
	lea	eax, DWORD PTR _tokenName$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN9@readObject

; 490  :          return recoverFromError( tokenObjectEnd );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	BYTE PTR $T79192[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79192[ebp]
	jmp	$LN17@readObject
$LN9@readObject:

; 491  : 
; 492  :       Token colon;
; 493  :       if ( !readToken( colon ) ||  colon.type_ != tokenMemberSeparator )

	lea	edx, DWORD PTR _colon$56561[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN7@readObject
	cmp	DWORD PTR _colon$56561[ebp], 11		; 0000000bH
	je	SHORT $LN8@readObject
$LN7@readObject:

; 494  :       {
; 495  :          return addErrorAndRecover( "Missing ':' after object member name", 
; 496  :                                     colon, 
; 497  :                                     tokenObjectEnd );

	push	OFFSET ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
	lea	ecx, DWORD PTR $T79194[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	2
	lea	ecx, DWORD PTR _colon$56561[ebp]
	push	ecx
	lea	edx, DWORD PTR $T79194[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T79193[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79194[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79193[ebp]
	jmp	$LN17@readObject
$LN8@readObject:

; 498  :       }
; 499  :       Value &value = currentValue()[ name ];

	lea	eax, DWORD PTR _name$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??AValue@Json@@QAEAAV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _value$56567[ebp], eax

; 500  :       nodes_.push( &value );

	mov	ecx, DWORD PTR _value$56567[ebp]
	mov	DWORD PTR $T79195[ebp], ecx
	lea	edx, DWORD PTR $T79195[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push

; 501  :       bool ok = readValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	BYTE PTR _ok$56569[ebp], al

; 502  :       nodes_.pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop

; 503  :       if ( !ok ) // error already set

	movzx	eax, BYTE PTR _ok$56569[ebp]
	test	eax, eax
	jne	SHORT $LN6@readObject

; 504  :          return recoverFromError( tokenObjectEnd );

	push	2
	mov	ecx, DWORD PTR _this$[ebp]
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	BYTE PTR $T79196[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79196[ebp]
	jmp	$LN17@readObject
$LN6@readObject:

; 505  : 
; 506  :       Token comma;
; 507  :       if ( !readToken( comma )
; 508  :             ||  ( comma.type_ != tokenObjectEnd  &&  
; 509  :                   comma.type_ != tokenArraySeparator &&
; 510  :                   comma.type_ != tokenComment ) )

	lea	ecx, DWORD PTR _comma$56572[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN4@readObject
	cmp	DWORD PTR _comma$56572[ebp], 2
	je	SHORT $LN5@readObject
	cmp	DWORD PTR _comma$56572[ebp], 10		; 0000000aH
	je	SHORT $LN5@readObject
	cmp	DWORD PTR _comma$56572[ebp], 12		; 0000000cH
	je	SHORT $LN5@readObject
$LN4@readObject:

; 511  :       {
; 512  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 
; 513  :                                     comma, 
; 514  :                                     tokenObjectEnd );

	push	OFFSET ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
	lea	ecx, DWORD PTR $T79198[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	2
	lea	eax, DWORD PTR _comma$56572[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79198[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T79197[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79198[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79197[ebp]
	jmp	$LN17@readObject
$LN5@readObject:

; 515  :       }
; 516  :       bool finalizeTokenOk = true;

	mov	BYTE PTR _finalizeTokenOk$56578[ebp], 1
$LN3@readObject:

; 517  :       while ( comma.type_ == tokenComment &&
; 518  :               finalizeTokenOk )

	cmp	DWORD PTR _comma$56572[ebp], 12		; 0000000cH
	jne	SHORT $LN2@readObject
	movzx	edx, BYTE PTR _finalizeTokenOk$56578[ebp]
	test	edx, edx
	je	SHORT $LN2@readObject

; 519  :          finalizeTokenOk = readToken( comma );

	lea	eax, DWORD PTR _comma$56572[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	BYTE PTR _finalizeTokenOk$56578[ebp], al
	jmp	SHORT $LN3@readObject
$LN2@readObject:

; 520  :       if ( comma.type_ == tokenObjectEnd )

	cmp	DWORD PTR _comma$56572[ebp], 2
	jne	SHORT $LN1@readObject

; 521  :          return true;

	mov	BYTE PTR $T79199[ebp], 1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79199[ebp]
	jmp	SHORT $LN17@readObject
$LN1@readObject:

; 522  :    }

	jmp	$LN16@readObject
$LN15@readObject:

; 523  :    return addErrorAndRecover( "Missing '}' or object member name", 
; 524  :                               tokenName, 
; 525  :                               tokenObjectEnd );

	push	OFFSET ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
	lea	ecx, DWORD PTR $T79201[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	2
	lea	ecx, DWORD PTR _tokenName$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T79201[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	BYTE PTR $T79200[ebp], al
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79201[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _name$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79200[ebp]
$LN17@readObject:

; 526  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T79190[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T79194[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T79198[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T79201[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readObject
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?readValue@Reader@Json@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3
__ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?readValue@Reader@Json@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?readValue@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
tv175 = -124						; size = 4
tv141 = -120						; size = 4
tv82 = -116						; size = 4
_this$ = -112						; size = 4
$T79219 = -108						; size = 28
$T79218 = -77						; size = 1
$T79217 = -76						; size = 16
$T79216 = -60						; size = 16
$T79215 = -44						; size = 16
_successful$ = -25					; size = 1
_token$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
?readValue@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readValue, COMDAT
; _this$ = ecx

; 187  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readValue@Reader@Json@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 188  :    Token token;
; 189  :    skipCommentTokens( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 190  :    bool successful = true;

	mov	BYTE PTR _successful$[ebp], 1

; 191  : 
; 192  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+142]
	test	edx, edx
	je	SHORT $LN12@readValue
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN12@readValue

; 193  :    {
; 194  :       currentValue().setComment( commentsBefore_, commentBefore );

	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment

; 195  :       commentsBefore_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN12@readValue:

; 196  :    }
; 197  : 
; 198  : 
; 199  :    switch ( token.type_ )

	mov	edx, DWORD PTR _token$[ebp]
	mov	DWORD PTR tv82[ebp], edx
	mov	eax, DWORD PTR tv82[ebp]
	sub	eax, 1
	mov	DWORD PTR tv82[ebp], eax
	cmp	DWORD PTR tv82[ebp], 8
	ja	$LN2@readValue
	mov	ecx, DWORD PTR tv82[ebp]
	jmp	DWORD PTR $LN20@readValue[ecx*4]
$LN9@readValue:

; 200  :    {
; 201  :    case tokenObjectBegin:
; 202  :       successful = readObject( token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readObject
	mov	BYTE PTR _successful$[ebp], al

; 203  :       break;

	jmp	$LN10@readValue
$LN8@readValue:

; 204  :    case tokenArrayBegin:
; 205  :       successful = readArray( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readArray
	mov	BYTE PTR _successful$[ebp], al

; 206  :       break;

	jmp	$LN10@readValue
$LN7@readValue:

; 207  :    case tokenNumber:
; 208  :       successful = decodeNumber( token );

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeNumber
	mov	BYTE PTR _successful$[ebp], al

; 209  :       break;

	jmp	$LN10@readValue
$LN6@readValue:

; 210  :    case tokenString:
; 211  :       successful = decodeString( token );

	lea	edx, DWORD PTR _token$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeString
	mov	BYTE PTR _successful$[ebp], al

; 212  :       break;

	jmp	$LN10@readValue
$LN5@readValue:

; 213  :    case tokenTrue:
; 214  :       currentValue() = true;

	push	1
	lea	ecx, DWORD PTR $T79215[ebp]
	call	??0Value@Json@@QAE@_N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T79215[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79215[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 215  :       break;

	jmp	$LN10@readValue
$LN4@readValue:

; 216  :    case tokenFalse:
; 217  :       currentValue() = false;

	push	0
	lea	ecx, DWORD PTR $T79216[ebp]
	call	??0Value@Json@@QAE@_N@Z			; Json::Value::Value
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T79216[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79216[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 218  :       break;

	jmp	SHORT $LN10@readValue
$LN3@readValue:

; 219  :    case tokenNull:
; 220  :       currentValue() = Value();

	push	0
	lea	ecx, DWORD PTR $T79217[ebp]
	call	??0Value@Json@@QAE@W4ValueType@1@@Z	; Json::Value::Value
	mov	DWORD PTR tv141[ebp], eax
	mov	edx, DWORD PTR tv141[ebp]
	mov	DWORD PTR tv175[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv175[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79217[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 221  :       break;

	jmp	SHORT $LN10@readValue
$LN2@readValue:

; 222  :    default:
; 223  :       return addError( "Syntax error: value, object or array expected.", token );

	push	OFFSET ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
	lea	ecx, DWORD PTR $T79219[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	0
	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T79219[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	BYTE PTR $T79218[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79219[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79218[ebp]
	jmp	SHORT $LN13@readValue
$LN10@readValue:

; 224  :    }
; 225  : 
; 226  :    if ( collectComments_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+142]
	test	ecx, ecx
	je	SHORT $LN1@readValue

; 227  :    {
; 228  :       lastValueEnd_ = current_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+100]
	mov	DWORD PTR [edx+104], ecx

; 229  :       lastValue_ = &currentValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+108], eax
$LN1@readValue:

; 230  :    }
; 231  : 
; 232  :    return successful;

	mov	al, BYTE PTR _successful$[ebp]
$LN13@readValue:

; 233  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN20@readValue:
	DD	$LN9@readValue
	DD	$LN2@readValue
	DD	$LN8@readValue
	DD	$LN2@readValue
	DD	$LN6@readValue
	DD	$LN7@readValue
	DD	$LN5@readValue
	DD	$LN4@readValue
	DD	$LN3@readValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0:
	lea	ecx, DWORD PTR $T79215[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1:
	lea	ecx, DWORD PTR $T79216[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2:
	lea	ecx, DWORD PTR $T79217[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3:
	lea	ecx, DWORD PTR $T79219[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?readValue@Reader@Json@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?readValue@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readValue
PUBLIC	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z	; Json::Reader::parse
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
_TEXT	SEGMENT
_this$ = -64						; size = 4
$T79234 = -60						; size = 28
$T79233 = -32						; size = 4
_successful$ = -25					; size = 1
_token$ = -24						; size = 12
__$EHRec$ = -12						; size = 12
_beginDoc$ = 8						; size = 4
_endDoc$ = 12						; size = 4
_root$ = 16						; size = 4
_collectComments$ = 20					; size = 1
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z PROC	; Json::Reader::parse, COMDAT
; _this$ = ecx

; 145  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 146  :    if ( !features_.allowComments_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+140]
	test	ecx, ecx
	jne	SHORT $LN6@parse

; 147  :    {
; 148  :       collectComments = false;

	mov	BYTE PTR _collectComments$[ebp], 0
$LN6@parse:

; 149  :    }
; 150  : 
; 151  :    begin_ = beginDoc;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _beginDoc$[ebp]
	mov	DWORD PTR [edx+92], eax

; 152  :    end_ = endDoc;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR _endDoc$[ebp]
	mov	DWORD PTR [ecx+96], edx

; 153  :    collectComments_ = collectComments;

	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR _collectComments$[ebp]
	mov	BYTE PTR [eax+142], cl

; 154  :    current_ = begin_;

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+92]
	mov	DWORD PTR [edx+100], ecx

; 155  :    lastValueEnd_ = 0;

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+104], 0

; 156  :    lastValue_ = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+108], 0

; 157  :    commentsBefore_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 158  :    errors_.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 32					; 00000020H
	call	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
$LN5@parse:

; 159  :    while ( !nodes_.empty() )

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN4@parse

; 160  :       nodes_.pop();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
	jmp	SHORT $LN5@parse
$LN4@parse:

; 161  :    nodes_.push( &root );

	mov	edx, DWORD PTR _root$[ebp]
	mov	DWORD PTR $T79233[ebp], edx
	lea	eax, DWORD PTR $T79233[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push

; 162  :    
; 163  :    bool successful = readValue();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
	mov	BYTE PTR _successful$[ebp], al

; 164  :    Token token;
; 165  :    skipCommentTokens( token );

	lea	ecx, DWORD PTR _token$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens

; 166  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	mov	edx, DWORD PTR _this$[ebp]
	movzx	eax, BYTE PTR [edx+142]
	test	eax, eax
	je	SHORT $LN3@parse
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 112				; 00000070H
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@parse

; 167  :       root.setComment( commentsBefore_, commentAfter );

	push	2
	mov	edx, DWORD PTR _this$[ebp]
	add	edx, 112				; 00000070H
	push	edx
	mov	ecx, DWORD PTR _root$[ebp]
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
$LN3@parse:

; 168  :    if ( features_.strictRoot_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+141]
	test	ecx, ecx
	je	SHORT $LN2@parse

; 169  :    {
; 170  :       if ( !root.isArray()  &&  !root.isObject() )

	mov	ecx, DWORD PTR _root$[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN2@parse
	mov	ecx, DWORD PTR _root$[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@parse

; 171  :       {
; 172  :          // Set error location to start of doc, ideally should be first token found in doc
; 173  :          token.type_ = tokenError;

	mov	DWORD PTR _token$[ebp], 13		; 0000000dH

; 174  :          token.start_ = beginDoc;

	mov	ecx, DWORD PTR _beginDoc$[ebp]
	mov	DWORD PTR _token$[ebp+4], ecx

; 175  :          token.end_ = endDoc;

	mov	edx, DWORD PTR _endDoc$[ebp]
	mov	DWORD PTR _token$[ebp+8], edx

; 176  :          addError( "A valid JSON document must be either an array or an object value.",
; 177  :                    token );

	push	OFFSET ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
	lea	ecx, DWORD PTR $T79234[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	0
	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T79234[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T79234[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 178  :          return false;

	xor	al, al
	jmp	SHORT $LN7@parse
$LN2@parse:

; 179  :       }
; 180  :    }
; 181  :    return successful;

	mov	al, BYTE PTR _successful$[ebp]
$LN7@parse:

; 182  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR $T79234[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ENDP	; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
; Function compile flags: /Odtp
;	COMDAT ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_this$ = -12						; size = 4
_end$ = -8						; size = 4
_begin$ = -4						; size = 4
_document$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 116  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR _this$[ebp], ecx

; 117  :    document_ = document;

	mov	eax, DWORD PTR _document$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 118  :    const char *begin = document_.c_str();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _begin$[ebp], eax

; 119  :    const char *end = begin + document_.length();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 64					; 00000040H
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	add	eax, DWORD PTR _begin$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 120  :    return parse( begin, end, root, collectComments );

	movzx	ecx, BYTE PTR _collectComments$[ebp]
	push	ecx
	mov	edx, DWORD PTR _root$[ebp]
	push	edx
	mov	eax, DWORD PTR _end$[ebp]
	push	eax
	mov	ecx, DWORD PTR _begin$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse

; 121  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
PUBLIC	__$ArrayPad$
PUBLIC	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0
__ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_this$ = -52						; size = 4
$T79250 = -45						; size = 1
_doc$ = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 128  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 129  :    //std::istream_iterator<char> begin(sin);
; 130  :    //std::istream_iterator<char> end;
; 131  :    // Those would allow streamed input from a file, if parse() were a
; 132  :    // template function.
; 133  : 
; 134  :    // Since std::string is reference-counted, this at least does not
; 135  :    // create an extra copy.
; 136  :    std::string doc;

	lea	ecx, DWORD PTR _doc$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 137  :    std::getline(sin, doc, (char)EOF);

	push	-1
	lea	eax, DWORD PTR _doc$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sin$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	add	esp, 12					; 0000000cH

; 138  :    return parse( doc, root, collectComments );

	movzx	edx, BYTE PTR _collectComments$[ebp]
	push	edx
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	lea	ecx, DWORD PTR _doc$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
	mov	BYTE PTR $T79250[ebp], al
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _doc$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	al, BYTE PTR $T79250[ebp]

; 139  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR _doc$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
PUBLIC	__$ArrayPad$
PUBLIC	??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ; Json::operator>>
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$2
__ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
_TEXT	SEGMENT
tv128 = -272						; size = 4
tv65 = -268						; size = 4
$T79264 = -264						; size = 4
$T79263 = -260						; size = 28
$T79262 = -232						; size = 40
$T79261 = -192						; size = 28
_reader$ = -164						; size = 144
__$ArrayPad$ = -20					; size = 4
_ok$ = -13						; size = 1
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z PROC ; Json::operator>>, COMDAT

; 910  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 260				; 00000104H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 911  :     Json::Reader reader;

	lea	ecx, DWORD PTR _reader$[ebp]
	call	??0Reader@Json@@QAE@XZ			; Json::Reader::Reader
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 912  :     bool ok = reader.parse(sin, root, true);

	push	1
	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sin$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _reader$[ebp]
	call	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
	mov	BYTE PTR _ok$[ebp], al

; 913  :     if (!ok) {

	movzx	edx, BYTE PTR _ok$[ebp]
	test	edx, edx
	jne	$LN1@operator@55

; 914  :       fprintf(
; 915  :           stderr,
; 916  :           "Error from reader: %s",
; 917  :           reader.getFormattedErrorMessages().c_str());

	lea	eax, DWORD PTR $T79261[ebp]
	push	eax
	lea	ecx, DWORD PTR _reader$[ebp]
	call	?getFormattedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormattedErrorMessages
	mov	DWORD PTR tv65[ebp], eax
	mov	ecx, DWORD PTR tv65[ebp]
	mov	DWORD PTR tv128[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv128[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	push	OFFSET ??_C@_0BG@PKNPKJIB@Error?5from?5reader?3?5?$CFs?$AA@
	call	DWORD PTR __imp____iob_func
	add	eax, 64					; 00000040H
	push	eax
	call	DWORD PTR __imp__fprintf
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79261[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 918  : 
; 919  :       JSON_FAIL_MESSAGE("reader error");

	push	OFFSET ??_C@_0N@KACHDPPK@reader?5error?$AA@
	lea	ecx, DWORD PTR $T79263[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	edx, DWORD PTR $T79263[ebp]
	push	edx
	lea	ecx, DWORD PTR $T79262[ebp]
	call	??0runtime_error@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
	push	OFFSET __TI2?AVruntime_error@std@@
	lea	eax, DWORD PTR $T79262[ebp]
	push	eax
	call	__CxxThrowException@8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T79263[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN1@operator@55:

; 920  :     }
; 921  :     return sin;

	mov	ecx, DWORD PTR _sin$[ebp]
	mov	DWORD PTR $T79264[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _reader$[ebp]
	call	??1Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR $T79264[ebp]
$LN3@operator@55:

; 922  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$0:
	lea	ecx, DWORD PTR _reader$[ebp]
	jmp	??1Reader@Json@@QAE@XZ
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$1:
	lea	ecx, DWORD PTR $T79261[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z$2:
	lea	ecx, DWORD PTR $T79263[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??5Json@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAV12@AAVValue@0@@Z ENDP ; Json::operator>>
END
