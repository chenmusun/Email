; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.30729.01 

	TITLE	e:\newGGDevelop\Client\GGJsonCPP\json_writer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
PUBLIC	?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::FastWriter::write
PUBLIC	?hex@std@@YAAAVios_base@1@AAV21@@Z		; std::hex
PUBLIC	?uppercase@std@@YAAAVios_base@1@AAV21@@Z	; std::uppercase
PUBLIC	??0?$_Fillobj@D@std@@QAE@D@Z			; std::_Fillobj<char>::_Fillobj<char>
PUBLIC	??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z	; std::setfill<char>
PUBLIC	??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ; std::operator<<<char,std::char_traits<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
PUBLIC	??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
PUBLIC	??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
PUBLIC	??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
PUBLIC	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??_C@_05CFGAKADK@?$CF?416g?$AA@			; `string'
PUBLIC	??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@	; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC?$AA@			; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
PUBLIC	??_C@_02DCNDPIBM@?2b?$AA@			; `string'
PUBLIC	??_C@_02FGLPDNBI@?2f?$AA@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n?$AA@			; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r?$AA@			; `string'
PUBLIC	??_C@_02COELENML@?2t?$AA@			; `string'
PUBLIC	??_C@_02DHFAHMIK@?2u?$AA@			; `string'
PUBLIC	??_C@_04MLLLIHIP@null?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_02MCILKGOH@?$HL?$HN?$AA@			; `string'
PUBLIC	??_C@_03MCPBMLDJ@?5?3?5?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_02PFNDMDBO@?$FL?5?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02DHOGEDBE@?5?$FN?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
EXTRN	__imp__strpbrk:PROC
EXTRN	__imp_?setf@ios_base@std@@QAEHHH@Z:PROC
EXTRN	__imp_?setf@ios_base@std@@QAEHH@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:PROC
EXTRN	__imp_?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ:PROC
EXTRN	__imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ:PROC
EXTRN	__imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z:PROC
EXTRN	__imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z:PROC
EXTRN	__imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ:PROC
EXTRN	__imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:PROC
EXTRN	__imp_?length@?$char_traits@D@std@@SAIPBD@Z:PROC
EXTRN	__imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z:PROC
EXTRN	__imp_?eof@?$char_traits@D@std@@SAHXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAEHH@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHOGEDBE@?5?$FN?$AA@
CONST	SEGMENT
??_C@_02DHOGEDBE@?5?$FN?$AA@ DB ' ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFNDMDBO@?$FL?5?$AA@
CONST	SEGMENT
??_C@_02PFNDMDBO@?$FL?5?$AA@ DB '[ ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT
??_C@_03MCPBMLDJ@?5?3?5?$AA@ DB ' : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_02MCILKGOH@?$HL?$HN?$AA@ DB '{}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT
??_C@_04MLLLIHIP@null?$AA@ DB 'null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHFAHMIK@?2u?$AA@
CONST	SEGMENT
??_C@_02DHFAHMIK@?2u?$AA@ DB '\u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02COELENML@?2t?$AA@
CONST	SEGMENT
??_C@_02COELENML@?2t?$AA@ DB '\t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r?$AA@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r?$AA@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n?$AA@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n?$AA@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLPDNBI@?2f?$AA@
CONST	SEGMENT
??_C@_02FGLPDNBI@?2f?$AA@ DB '\f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCNDPIBM@?2b?$AA@
CONST	SEGMENT
??_C@_02DCNDPIBM@?2b?$AA@ DB '\b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC?$AA@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC?$AA@ DB '\"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
CONST	SEGMENT
??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@ DB '"\', 08H, 0cH, 0aH, 0dH, 09H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05CFGAKADK@?$CF?416g?$AA@
CONST	SEGMENT
??_C@_05CFGAKADK@?$CF?416g?$AA@ DB '%.16g', 00H		; `string'
__bad_alloc_Message DD FLAT:??_C@_0P@GHFPNOJB@bad?5allocation?$AA@
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\iomanip
;	COMDAT ??0?$_Fillobj@D@std@@QAE@D@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ch$ = 8						; size = 1
??0?$_Fillobj@D@std@@QAE@D@Z PROC			; std::_Fillobj<char>::_Fillobj<char>, COMDAT
; _this$ = ecx

; 20   : 		{	// construct from fill character

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [eax], cl

; 21   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Fillobj@D@std@@QAE@D@Z ENDP			; std::_Fillobj<char>::_Fillobj<char>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z
_TEXT	SEGMENT
tv76 = -4						; size = 4
__Ostr$ = 8						; size = 4
__Manip$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,int>, COMDAT

; 81   : 	{	// insert by calling function with output stream and argument

	push	ebp
	mov	ebp, esp
	push	ecx

; 82   : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	cmp	DWORD PTR __Ostr$[ebp], 0
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv76[ebp], 0
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR tv76[ebp], edx
$LN4@operator:
	mov	eax, DWORD PTR __Manip$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	mov	edx, DWORD PTR tv76[ebp]
	push	edx
	mov	eax, DWORD PTR __Manip$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	ecx
	add	esp, 8

; 83   : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 84   : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,int>
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
__Manip$ = 12						; size = 4
??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z PROC ; std::operator<<<char,std::char_traits<char> >, COMDAT

; 48   : 	{	// set fill character in output stream

	push	ebp
	mov	ebp, esp

; 49   : 	_Ostr.fill(_Manip._Fill);

	mov	eax, DWORD PTR __Manip$[ebp]
	movzx	ecx, BYTE PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z

; 50   : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]

; 51   : 	}

	pop	ebp
	ret	0
??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ENDP ; std::operator<<<char,std::char_traits<char> >
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Ch$ = 12						; size = 1
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z PROC		; std::setfill<char>, COMDAT

; 29   : 	{	// return a _Fillobj manipulator

	push	ebp
	mov	ebp, esp

; 30   : 	return (_Fillobj<_Elem>(_Ch));

	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Fillobj@D@std@@QAE@D@Z		; std::_Fillobj<char>::_Fillobj<char>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 31   : 	}

	pop	ebp
	ret	0
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ENDP		; std::setfill<char>
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
_TEXT	ENDS
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 81   : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 82   : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	test	eax, eax
	je	SHORT $LN2@Sentry_bas

; 83   : 				_Myostr.rdbuf()->_Unlock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@Sentry_bas:

; 84   : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 75   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [eax], ecx

; 76   : 			if (_Myostr.rdbuf() != 0)

	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx]
	add	eax, DWORD PTR [ecx+4]
	mov	ecx, eax
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	test	eax, eax
	je	SHORT $LN2@Sentry_bas@2

; 77   : 				_Myostr.rdbuf()->_Lock();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@Sentry_bas@2:

; 78   : 			}

	mov	eax, DWORD PTR _this$[ebp]
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 115  : 			{	// test if stream state okay

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 			return (_Ok);

	mov	eax, DWORD PTR _this$[ebp]
	mov	al, BYTE PTR [eax+4]

; 117  : 			}

	mov	esp, ebp
	pop	ebp
	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
EXTRN	___security_cookie:DWORD
EXTRN	___CxxFrameHandler3:PROC
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 102  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 103  : 
; 104  :  #if _HAS_EXCEPTIONS
; 105  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@sentry

; 106  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [ecx]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 107  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 95   : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 96   : 			if (_Ostr.good() && _Ostr.tie() != 0)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@sentry@2
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	test	eax, eax
	je	SHORT $LN1@sentry@2

; 97   : 				_Ostr.tie()->flush();

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN1@sentry@2:

; 98   : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+4], al

; 99   : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	__$ArrayPad$
PUBLIC	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
;	COMDAT xdata$x
; File e:\newggdevelop\client\ggjsoncpp\json_writer.cpp
xdata$x	SEGMENT
__unwindtable$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0
__ehfuncinfo$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
$T75140 = -64						; size = 4
_c$56742 = -57						; size = 1
_normalized$ = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_end$ = -24						; size = 4
_begin$ = -20						; size = 4
_current$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_text$ = 12						; size = 4
?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC ; Json::StyledStreamWriter::normalizeEOL, COMDAT

; 798  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T75140[ebp], 0

; 799  :    std::string normalized;

	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 800  :    normalized.reserve( text.length() );

	mov	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	push	eax
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 801  :    const char *begin = text.c_str();

	mov	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _begin$[ebp], eax

; 802  :    const char *end = begin + text.length();

	mov	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	add	eax, DWORD PTR _begin$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 803  :    const char *current = begin;

	mov	eax, DWORD PTR _begin$[ebp]
	mov	DWORD PTR _current$[ebp], eax
$LN5@normalizeE:

; 804  :    while ( current != end )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN4@normalizeE

; 805  :    {
; 806  :       char c = *current++;

	mov	edx, DWORD PTR _current$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _c$56742[ebp], al
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 807  :       if ( c == '\r' ) // mac or dos EOL

	movsx	edx, BYTE PTR _c$56742[ebp]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@normalizeE

; 808  :       {
; 809  :          if ( *current == '\n' ) // convert dos EOL

	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN2@normalizeE

; 810  :             ++current;

	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx
$LN2@normalizeE:

; 811  :          normalized += '\n';

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 812  :       }
; 813  :       else // handle unix EOL & other char

	jmp	SHORT $LN1@normalizeE
$LN3@normalizeE:

; 814  :          normalized += c;

	movzx	eax, BYTE PTR _c$56742[ebp]
	push	eax
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
$LN1@normalizeE:

; 815  :    }

	jmp	SHORT $LN5@normalizeE
$LN4@normalizeE:

; 816  :    return normalized;

	lea	ecx, DWORD PTR _normalized$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T75140[ebp]
	or	edx, 1
	mov	DWORD PTR $T75140[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 817  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0:
	lea	ecx, DWORD PTR _normalized$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$1:
	mov	eax, DWORD PTR $T75140[ebp]
	and	eax, 1
	je	$LN10@normalizeE
	and	DWORD PTR $T75140[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@normalizeE:
	ret	0
__ehhandler$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledStreamWriter::normalizeEOL
PUBLIC	?unindent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::unindent
; Function compile flags: /Odtp
;	COMDAT ?unindent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?unindent@StyledStreamWriter@Json@@AAEXXZ PROC		; Json::StyledStreamWriter::unindent, COMDAT
; _this$ = ecx

; 756  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	DWORD PTR _this$[ebp], ecx

; 757  :    assert( indentString_.size() >= indentation_.size() );
; 758  :    indentString_.resize( indentString_.size() - indentation_.size() );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	sub	esi, eax
	push	esi
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 759  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?unindent@StyledStreamWriter@Json@@AAEXXZ ENDP		; Json::StyledStreamWriter::unindent
_TEXT	ENDS
PUBLIC	?indent@StyledStreamWriter@Json@@AAEXXZ		; Json::StyledStreamWriter::indent
; Function compile flags: /Odtp
;	COMDAT ?indent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?indent@StyledStreamWriter@Json@@AAEXXZ PROC		; Json::StyledStreamWriter::indent, COMDAT
; _this$ = ecx

; 749  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 750  :    indentString_ += indentation_;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 751  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?indent@StyledStreamWriter@Json@@AAEXXZ ENDP		; Json::StyledStreamWriter::indent
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0
__ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
$T75157 = -64						; size = 4
_c$56579 = -57						; size = 1
_normalized$ = -56					; size = 28
__$ArrayPad$ = -28					; size = 4
_end$ = -24						; size = 4
_begin$ = -20						; size = 4
_current$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_text$ = 12						; size = 4
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC ; Json::StyledWriter::normalizeEOL, COMDAT

; 517  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T75157[ebp], 0

; 518  :    std::string normalized;

	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 519  :    normalized.reserve( text.length() );

	mov	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	push	eax
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 520  :    const char *begin = text.c_str();

	mov	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	mov	DWORD PTR _begin$[ebp], eax

; 521  :    const char *end = begin + text.length();

	mov	ecx, DWORD PTR _text$[ebp]
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	add	eax, DWORD PTR _begin$[ebp]
	mov	DWORD PTR _end$[ebp], eax

; 522  :    const char *current = begin;

	mov	eax, DWORD PTR _begin$[ebp]
	mov	DWORD PTR _current$[ebp], eax
$LN5@normalizeE@2:

; 523  :    while ( current != end )

	mov	ecx, DWORD PTR _current$[ebp]
	cmp	ecx, DWORD PTR _end$[ebp]
	je	SHORT $LN4@normalizeE@2

; 524  :    {
; 525  :       char c = *current++;

	mov	edx, DWORD PTR _current$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR _c$56579[ebp], al
	mov	ecx, DWORD PTR _current$[ebp]
	add	ecx, 1
	mov	DWORD PTR _current$[ebp], ecx

; 526  :       if ( c == '\r' ) // mac or dos EOL

	movsx	edx, BYTE PTR _c$56579[ebp]
	cmp	edx, 13					; 0000000dH
	jne	SHORT $LN3@normalizeE@2

; 527  :       {
; 528  :          if ( *current == '\n' ) // convert dos EOL

	mov	eax, DWORD PTR _current$[ebp]
	movsx	ecx, BYTE PTR [eax]
	cmp	ecx, 10					; 0000000aH
	jne	SHORT $LN2@normalizeE@2

; 529  :             ++current;

	mov	edx, DWORD PTR _current$[ebp]
	add	edx, 1
	mov	DWORD PTR _current$[ebp], edx
$LN2@normalizeE@2:

; 530  :          normalized += '\n';

	push	10					; 0000000aH
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z

; 531  :       }
; 532  :       else // handle unix EOL & other char

	jmp	SHORT $LN1@normalizeE@2
$LN3@normalizeE@2:

; 533  :          normalized += c;

	movzx	eax, BYTE PTR _c$56579[ebp]
	push	eax
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
$LN1@normalizeE@2:

; 534  :    }

	jmp	SHORT $LN5@normalizeE@2
$LN4@normalizeE@2:

; 535  :    return normalized;

	lea	ecx, DWORD PTR _normalized$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T75157[ebp]
	or	edx, 1
	mov	DWORD PTR $T75157[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _normalized$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 536  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0:
	lea	ecx, DWORD PTR _normalized$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$1:
	mov	eax, DWORD PTR $T75157[ebp]
	and	eax, 1
	je	$LN10@normalizeE@2
	and	DWORD PTR $T75157[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN10@normalizeE@2:
	ret	0
__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledWriter::normalizeEOL
PUBLIC	?unindent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::unindent
; Function compile flags: /Odtp
;	COMDAT ?unindent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?unindent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::unindent, COMDAT
; _this$ = ecx

; 475  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 476  :    assert( int(indentString_.size()) >= indentSize_ );
; 477  :    indentString_.resize( indentString_.size() - indentSize_ );

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	DWORD PTR __imp_?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	mov	ecx, DWORD PTR _this$[ebp]
	sub	eax, DWORD PTR [ecx+88]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	DWORD PTR __imp_?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 478  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?unindent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::unindent
_TEXT	ENDS
PUBLIC	?indent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::indent
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?indent@StyledWriter@Json@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0
__ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?indent@StyledWriter@Json@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?indent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
tv75 = -52						; size = 4
tv76 = -48						; size = 4
_this$ = -44						; size = 4
$T75169 = -40						; size = 28
__$EHRec$ = -12						; size = 12
?indent@StyledWriter@Json@@AAEXXZ PROC			; Json::StyledWriter::indent, COMDAT
; _this$ = ecx

; 468  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?indent@StyledWriter@Json@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 469  :    indentString_ += std::string( indentSize_, ' ' );

	push	32					; 00000020H
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+88]
	push	ecx
	lea	ecx, DWORD PTR $T75169[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
	mov	DWORD PTR tv76[ebp], eax
	mov	edx, DWORD PTR tv76[ebp]
	mov	DWORD PTR tv75[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv75[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T75169[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 470  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0:
	lea	ecx, DWORD PTR $T75169[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?indent@StyledWriter@Json@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?indent@StyledWriter@Json@@AAEXXZ ENDP			; Json::StyledWriter::indent
PUBLIC	?writeIndent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::writeIndent
; Function compile flags: /Odtp
;	COMDAT ?writeIndent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
_last$56440 = -1					; size = 1
?writeIndent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::writeIndent, COMDAT
; _this$ = ecx

; 445  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 446  :    if ( !document_.empty() )

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@writeInden

; 447  :    {
; 448  :       char last = document_[document_.length()-1];

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	sub	eax, 1
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR _last$56440[ebp], cl

; 449  :       if ( last == ' ' )     // already indented

	movsx	edx, BYTE PTR _last$56440[ebp]
	cmp	edx, 32					; 00000020H
	jne	SHORT $LN2@writeInden

; 450  :          return;

	jmp	SHORT $LN4@writeInden
$LN2@writeInden:

; 451  :       if ( last != '\n' )    // Comments may add new-line

	movsx	eax, BYTE PTR _last$56440[ebp]
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN3@writeInden

; 452  :          document_ += '\n';

	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
$LN3@writeInden:

; 453  :    }
; 454  :    document_ += indentString_;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN4@writeInden:

; 455  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?writeIndent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::writeIndent
_TEXT	ENDS
PUBLIC	?dropNullPlaceholders@FastWriter@Json@@QAEXXZ	; Json::FastWriter::dropNullPlaceholders
; Function compile flags: /Odtp
;	COMDAT ?dropNullPlaceholders@FastWriter@Json@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?dropNullPlaceholders@FastWriter@Json@@QAEXXZ PROC	; Json::FastWriter::dropNullPlaceholders, COMDAT
; _this$ = ecx

; 189  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 190  :    dropNullPlaceholders_ = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+33], 1

; 191  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?dropNullPlaceholders@FastWriter@Json@@QAEXXZ ENDP	; Json::FastWriter::dropNullPlaceholders
_TEXT	ENDS
PUBLIC	?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ ; Json::FastWriter::enableYAMLCompatibility
; Function compile flags: /Odtp
;	COMDAT ?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ PROC	; Json::FastWriter::enableYAMLCompatibility, COMDAT
; _this$ = ecx

; 182  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 183  :    yamlCompatiblityEnabled_ = true;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+32], 1

; 184  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ ENDP	; Json::FastWriter::enableYAMLCompatibility
_TEXT	ENDS
PUBLIC	??1Writer@Json@@UAE@XZ				; Json::Writer::~Writer
; Function compile flags: /Odtp
;	COMDAT ??1Writer@Json@@UAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??1Writer@Json@@UAE@XZ PROC				; Json::Writer::~Writer, COMDAT
; _this$ = ecx

; 166  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7Writer@Json@@6B@

; 167  : }

	mov	esp, ebp
	pop	ebp
	ret	0
??1Writer@Json@@UAE@XZ ENDP				; Json::Writer::~Writer
_TEXT	ENDS
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
; Function compile flags: /Odtp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
tv68 = -8						; size = 4
$T75190 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 1
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; Json::valueToString, COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR $T75190[ebp], 0

; 95   :    return value ? "true" : "false";

	movzx	eax, BYTE PTR _value$[ebp]
	test	eax, eax
	je	SHORT $LN3@valueToStr
	mov	DWORD PTR tv68[ebp], OFFSET ??_C@_04LOAJBDKD@true?$AA@
	jmp	SHORT $LN4@valueToStr
$LN3@valueToStr:
	mov	DWORD PTR tv68[ebp], OFFSET ??_C@_05LAPONLG@false?$AA@
$LN4@valueToStr:
	mov	ecx, DWORD PTR tv68[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T75190[ebp]
	or	edx, 1
	mov	DWORD PTR $T75190[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 96   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; Json::valueToString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
EXTRN	__fltused:DWORD
; Function compile flags: /Odtp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z
_TEXT	SEGMENT
$T75196 = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 8
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z PROC ; Json::valueToString, COMDAT

; 75   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR $T75196[ebp], 0

; 76   :    // Allocate a buffer that is more than large enough to store the 16 digits of
; 77   :    // precision requested below.
; 78   :    char buffer[32];
; 79   : 
; 80   :    // Print into the buffer. We need not request the alternative representation
; 81   :    // that always has a decimal point because JSON doesn't distingish the
; 82   :    // concepts of reals and integers.
; 83   : #if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__) // Use secure version with visual studio 2005 to avoid warning. 
; 84   :    sprintf_s(buffer, sizeof(buffer), "%.16g", value); 

	sub	esp, 8
	fld	QWORD PTR _value$[ebp]
	fstp	QWORD PTR [esp]
	push	OFFSET ??_C@_05CFGAKADK@?$CF?416g?$AA@
	push	32					; 00000020H
	lea	eax, DWORD PTR _buffer$[ebp]
	push	eax
	call	DWORD PTR __imp__sprintf_s
	add	esp, 20					; 00000014H

; 85   : #else
; 86   :    snprintf(buffer, sizeof(buffer), "%.16g", value);
; 87   : #endif
; 88   : 
; 89   :    return buffer;

	lea	ecx, DWORD PTR _buffer$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T75196[ebp]
	or	edx, 1
	mov	DWORD PTR $T75196[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 90   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ENDP ; Json::valueToString
_TEXT	ENDS
EXTRN	__aulldiv:PROC
EXTRN	__aullrem:PROC
; Function compile flags: /Odtp
; File e:\newggdevelop\client\ggjsoncpp\json_tool.h
;	COMDAT ?uintToString@Json@@YAX_KAAPAD@Z
_TEXT	SEGMENT
_value$ = 8						; size = 8
_current$ = 16						; size = 4
?uintToString@Json@@YAX_KAAPAD@Z PROC			; Json::uintToString, COMDAT

; 81   : {

	push	ebp
	mov	ebp, esp
	push	esi

; 82   :    *--current = 0;

	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	sub	ecx, 1
	mov	edx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [edx], ecx
	mov	eax, DWORD PTR _current$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	BYTE PTR [ecx], 0
$LN3@uintToStri:

; 83   :    do
; 84   :    {
; 85   :       *--current = char(value % 10) + '0';

	mov	edx, DWORD PTR _current$[ebp]
	mov	eax, DWORD PTR [edx]
	sub	eax, 1
	mov	ecx, DWORD PTR _current$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	edx, DWORD PTR _current$[ebp]
	mov	esi, DWORD PTR [edx]
	push	0
	push	10					; 0000000aH
	mov	eax, DWORD PTR _value$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	__aullrem
	movsx	edx, al
	add	edx, 48					; 00000030H
	mov	BYTE PTR [esi], dl

; 86   :       value /= 10;

	push	0
	push	10					; 0000000aH
	mov	eax, DWORD PTR _value$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	__aulldiv
	mov	DWORD PTR _value$[ebp], eax
	mov	DWORD PTR _value$[ebp+4], edx

; 87   :    }
; 88   :    while ( value != 0 );

	mov	edx, DWORD PTR _value$[ebp]
	or	edx, DWORD PTR _value$[ebp+4]
	jne	SHORT $LN3@uintToStri

; 89   : }

	pop	esi
	pop	ebp
	ret	0
?uintToString@Json@@YAX_KAAPAD@Z ENDP			; Json::uintToString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?isControlCharacter@Json@@YA_ND@Z
_TEXT	SEGMENT
tv68 = -4						; size = 4
_ch$ = 8						; size = 1
?isControlCharacter@Json@@YA_ND@Z PROC			; Json::isControlCharacter, COMDAT

; 59   : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 60   :    return ch > 0 && ch <= 0x1F;

	movsx	eax, BYTE PTR _ch$[ebp]
	test	eax, eax
	jle	SHORT $LN3@isControlC
	movsx	ecx, BYTE PTR _ch$[ebp]
	cmp	ecx, 31					; 0000001fH
	jg	SHORT $LN3@isControlC
	mov	DWORD PTR tv68[ebp], 1
	jmp	SHORT $LN4@isControlC
$LN3@isControlC:
	mov	DWORD PTR tv68[ebp], 0
$LN4@isControlC:
	mov	al, BYTE PTR tv68[ebp]

; 61   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?isControlCharacter@Json@@YA_ND@Z ENDP			; Json::isControlCharacter
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ios
_TEXT	ENDS
;	COMDAT ?uppercase@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?uppercase@std@@YAAAVios_base@1@AAV21@@Z PROC		; std::uppercase, COMDAT

; 307  : 	{	// set uppercase

	push	ebp
	mov	ebp, esp

; 308  : 	_Iosbase.setf(ios_base::uppercase);

	push	4
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	DWORD PTR __imp_?setf@ios_base@std@@QAEHH@Z

; 309  : 	return (_Iosbase);

	mov	eax, DWORD PTR __Iosbase$[ebp]

; 310  : 	}

	pop	ebp
	ret	0
?uppercase@std@@YAAAVios_base@1@AAV21@@Z ENDP		; std::uppercase
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?hex@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?hex@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::hex, COMDAT

; 190  : 	{	// set basefield to hex

	push	ebp
	mov	ebp, esp

; 191  : 	_Iosbase.setf(ios_base::hex, ios_base::basefield);

	push	3584					; 00000e00H
	push	2048					; 00000800H
	mov	ecx, DWORD PTR __Iosbase$[ebp]
	call	DWORD PTR __imp_?setf@ios_base@std@@QAEHHH@Z

; 192  : 	return (_Iosbase);

	mov	eax, DWORD PTR __Iosbase$[ebp]

; 193  : 	}

	pop	ebp
	ret	0
?hex@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::hex
;	COMDAT xdata$x
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\ostream
xdata$x	SEGMENT
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
tv285 = -117						; size = 1
tv284 = -116						; size = 4
tv283 = -112						; size = 4
tv282 = -108						; size = 4
tv281 = -102						; size = 1
tv280 = -101						; size = 1
tv279 = -100						; size = 4
tv278 = -96						; size = 4
tv277 = -92						; size = 4
tv276 = -85						; size = 1
tv275 = -84						; size = 4
tv274 = -80						; size = 4
tv273 = -76						; size = 4
tv272 = -69						; size = 1
tv65 = -68						; size = 4
tv128 = -64						; size = 4
$T75840 = -60						; size = 4
$T75839 = -56						; size = 4
$T75838 = -52						; size = 4
$T75837 = -48						; size = 4
$T75836 = -44						; size = 4
$T75835 = -40						; size = 4
$T75834 = -36						; size = 4
__Pad$60487 = -32					; size = 4
__Ok$ = -28						; size = 8
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Ch$ = 12						; size = 1
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 787  : 	{	// insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 104				; 00000068H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 788  : 	typedef char _Elem;
; 789  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 790  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 791  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 792  : 
; 793  : 	if (_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@operator@4

; 794  : 		{	// state okay, insert
; 795  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	eax, 1
	jg	SHORT $LN15@operator@4
	mov	DWORD PTR tv128[ebp], 0
	jmp	SHORT $LN16@operator@4
$LN15@operator@4:
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	sub	eax, 1
	mov	DWORD PTR tv128[ebp], eax
$LN16@operator@4:
	mov	eax, DWORD PTR tv128[ebp]
	mov	DWORD PTR __Pad$60487[ebp], eax

; 796  : 
; 797  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 798  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	mov	DWORD PTR tv65[ebp], eax
	mov	eax, DWORD PTR tv65[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN10@operator@4

; 799  : 			for (; _State == ios_base::goodbit && 0 < _Pad;
; 800  : 				--_Pad)	// pad on left

	jmp	SHORT $LN9@operator@4
$LN8@operator@4:
	mov	ecx, DWORD PTR __Pad$60487[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$60487[ebp], ecx
$LN9@operator@4:
	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN10@operator@4
	cmp	DWORD PTR __Pad$60487[ebp], 0
	jle	SHORT $LN10@operator@4

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 802  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	mov	BYTE PTR tv272[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	DWORD PTR tv273[ebp], eax
	movzx	eax, BYTE PTR tv272[ebp]
	push	eax
	mov	ecx, DWORD PTR tv273[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	DWORD PTR tv274[ebp], eax
	mov	ecx, DWORD PTR tv274[ebp]
	mov	DWORD PTR $T75834[ebp], ecx
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	mov	DWORD PTR tv275[ebp], eax
	mov	edx, DWORD PTR tv275[ebp]
	mov	DWORD PTR $T75835[ebp], edx
	lea	eax, DWORD PTR $T75834[ebp]
	push	eax
	lea	ecx, DWORD PTR $T75835[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	mov	BYTE PTR tv276[ebp], al
	movzx	edx, BYTE PTR tv276[ebp]
	test	edx, edx
	je	SHORT $LN6@operator@4

; 803  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN6@operator@4:

; 804  : 
; 805  : 		if (_State == ios_base::goodbit

	jmp	$LN8@operator@4
$LN10@operator@4:

; 806  : 			&& _Traits::eq_int_type(_Traits::eof(),
; 807  : 				_Ostr.rdbuf()->sputc(_Ch)))

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN5@operator@4
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	DWORD PTR tv277[ebp], eax
	movzx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	mov	ecx, DWORD PTR tv277[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	DWORD PTR tv278[ebp], eax
	mov	ecx, DWORD PTR tv278[ebp]
	mov	DWORD PTR $T75836[ebp], ecx
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	mov	DWORD PTR tv279[ebp], eax
	mov	edx, DWORD PTR tv279[ebp]
	mov	DWORD PTR $T75837[ebp], edx
	lea	eax, DWORD PTR $T75836[ebp]
	push	eax
	lea	ecx, DWORD PTR $T75837[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	mov	BYTE PTR tv280[ebp], al
	movzx	edx, BYTE PTR tv280[ebp]
	test	edx, edx
	je	SHORT $LN5@operator@4

; 808  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN5@operator@4:

; 809  : 
; 810  : 		for (; _State == ios_base::goodbit && 0 < _Pad;
; 811  : 			--_Pad)	// pad on right

	jmp	SHORT $LN4@operator@4
$LN3@operator@4:
	mov	ecx, DWORD PTR __Pad$60487[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$60487[ebp], ecx
$LN4@operator@4:
	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN2@operator@4
	cmp	DWORD PTR __Pad$60487[ebp], 0
	jle	SHORT $LN2@operator@4

; 812  : 			if (_Traits::eq_int_type(_Traits::eof(),
; 813  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	mov	BYTE PTR tv281[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	DWORD PTR tv282[ebp], eax
	movzx	eax, BYTE PTR tv281[ebp]
	push	eax
	mov	ecx, DWORD PTR tv282[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	DWORD PTR tv283[ebp], eax
	mov	ecx, DWORD PTR tv283[ebp]
	mov	DWORD PTR $T75838[ebp], ecx
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	mov	DWORD PTR tv284[ebp], eax
	mov	edx, DWORD PTR tv284[ebp]
	mov	DWORD PTR $T75839[ebp], edx
	lea	eax, DWORD PTR $T75838[ebp]
	push	eax
	lea	ecx, DWORD PTR $T75839[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	mov	BYTE PTR tv285[ebp], al
	movzx	edx, BYTE PTR tv285[ebp]
	test	edx, edx
	je	SHORT $LN1@operator@4

; 814  : 				_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN1@operator@4:

; 815  : 		_CATCH_IO_(_Ostr)

	jmp	$LN3@operator@4
$LN2@operator@4:
	jmp	SHORT $LN17@operator@4
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:
	push	1
	push	4
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN12@operator@4
	ret	0
$LN17@operator@4:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN12@operator@4:

; 816  : 		}
; 817  : 
; 818  : 	_Ostr.width(0);

	push	0
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z

; 819  : 	_Ostr.setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 820  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T75840[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T75840[ebp]

; 821  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv293 = -109						; size = 1
tv292 = -108						; size = 4
tv291 = -104						; size = 4
tv290 = -100						; size = 4
tv289 = -93						; size = 1
tv288 = -92						; size = 4
tv287 = -88						; size = 4
tv286 = -81						; size = 1
tv285 = -80						; size = 4
tv284 = -76						; size = 4
tv283 = -72						; size = 4
tv282 = -65						; size = 1
tv136 = -64						; size = 4
tv134 = -60						; size = 4
$T75863 = -56						; size = 4
$T75862 = -52						; size = 4
$T75861 = -48						; size = 4
$T75860 = -44						; size = 4
$T75859 = -40						; size = 4
__Ok$ = -36						; size = 8
__Pad$ = -28						; size = 4
__Count$ = -24						; size = 4
__State$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 741  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 96					; 00000060H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 742  : 	typedef char _Elem;
; 743  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 744  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0

; 745  : 	streamsize _Count = (streamsize)_Traits::length(_Val);	// may overflow

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	DWORD PTR __imp_?length@?$char_traits@D@std@@SAIPBD@Z
	add	esp, 4
	mov	DWORD PTR __Count$[ebp], eax

; 746  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
; 747  : 		? 0 : _Ostr.width() - _Count;

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	test	eax, eax
	jle	SHORT $LN17@operator@5
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	cmp	eax, DWORD PTR __Count$[ebp]
	jle	SHORT $LN17@operator@5
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?width@ios_base@std@@QBEHXZ
	sub	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR tv134[ebp], eax
	jmp	SHORT $LN18@operator@5
$LN17@operator@5:
	mov	DWORD PTR tv134[ebp], 0
$LN18@operator@5:
	mov	eax, DWORD PTR tv134[ebp]
	mov	DWORD PTR __Pad$[ebp], eax

; 748  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	push	ecx
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 749  : 
; 750  : 	if (!_Ok)

	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN14@operator@5

; 751  : 		_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 752  : 	else

	jmp	$LN13@operator@5
$LN14@operator@5:

; 753  : 		{	// state okay, insert
; 754  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 755  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
	mov	DWORD PTR tv136[ebp], eax
	mov	eax, DWORD PTR tv136[ebp]
	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	$LN11@operator@5

; 756  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	jmp	SHORT $LN10@operator@5
$LN9@operator@5:
	mov	ecx, DWORD PTR __Pad$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$[ebp], ecx
$LN10@operator@5:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	SHORT $LN11@operator@5

; 757  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 758  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	mov	BYTE PTR tv282[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	DWORD PTR tv283[ebp], eax
	movzx	eax, BYTE PTR tv282[ebp]
	push	eax
	mov	ecx, DWORD PTR tv283[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	DWORD PTR tv284[ebp], eax
	mov	ecx, DWORD PTR tv284[ebp]
	mov	DWORD PTR $T75859[ebp], ecx
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	mov	DWORD PTR tv285[ebp], eax
	mov	edx, DWORD PTR tv285[ebp]
	mov	DWORD PTR $T75860[ebp], edx
	lea	eax, DWORD PTR $T75859[ebp]
	push	eax
	lea	ecx, DWORD PTR $T75860[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	mov	BYTE PTR tv286[ebp], al
	movzx	edx, BYTE PTR tv286[ebp]
	test	edx, edx
	je	SHORT $LN7@operator@5

; 759  : 					{	// insertion failed, quit
; 760  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 761  : 					break;

	jmp	SHORT $LN11@operator@5
$LN7@operator@5:

; 762  : 					}
; 763  : 
; 764  : 		if (_State == ios_base::goodbit

	jmp	$LN9@operator@5
$LN11@operator@5:

; 765  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	cmp	DWORD PTR __State$[ebp], 0
	jne	SHORT $LN6@operator@5
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	DWORD PTR tv287[ebp], eax
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	ecx, DWORD PTR tv287[ebp]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHPBDH@Z
	mov	DWORD PTR tv288[ebp], eax
	mov	edx, DWORD PTR tv288[ebp]
	cmp	edx, DWORD PTR __Count$[ebp]
	je	SHORT $LN6@operator@5

; 766  : 			_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax
$LN6@operator@5:

; 767  : 
; 768  : 		if (_State == ios_base::goodbit)

	cmp	DWORD PTR __State$[ebp], 0
	jne	$LN5@operator@5

; 769  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	jmp	SHORT $LN4@operator@5
$LN3@operator@5:
	mov	ecx, DWORD PTR __Pad$[ebp]
	sub	ecx, 1
	mov	DWORD PTR __Pad$[ebp], ecx
$LN4@operator@5:
	cmp	DWORD PTR __Pad$[ebp], 0
	jle	SHORT $LN5@operator@5

; 770  : 				if (_Traits::eq_int_type(_Traits::eof(),
; 771  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))

	mov	edx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [eax+4]
	call	DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
	mov	BYTE PTR tv289[ebp], al
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
	mov	DWORD PTR tv290[ebp], eax
	movzx	eax, BYTE PTR tv289[ebp]
	push	eax
	mov	ecx, DWORD PTR tv290[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	DWORD PTR tv291[ebp], eax
	mov	ecx, DWORD PTR tv291[ebp]
	mov	DWORD PTR $T75861[ebp], ecx
	call	DWORD PTR __imp_?eof@?$char_traits@D@std@@SAHXZ
	mov	DWORD PTR tv292[ebp], eax
	mov	edx, DWORD PTR tv292[ebp]
	mov	DWORD PTR $T75862[ebp], edx
	lea	eax, DWORD PTR $T75861[ebp]
	push	eax
	lea	ecx, DWORD PTR $T75862[ebp]
	push	ecx
	call	DWORD PTR __imp_?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
	add	esp, 8
	mov	BYTE PTR tv293[ebp], al
	movzx	edx, BYTE PTR tv293[ebp]
	test	edx, edx
	je	SHORT $LN1@operator@5

; 772  : 					{	// insertion failed, quit
; 773  : 					_State |= ios_base::badbit;

	mov	eax, DWORD PTR __State$[ebp]
	or	eax, 4
	mov	DWORD PTR __State$[ebp], eax

; 774  : 					break;

	jmp	SHORT $LN5@operator@5
$LN1@operator@5:

; 775  : 					}

	jmp	$LN3@operator@5
$LN5@operator@5:

; 776  : 		_Ostr.width(0);

	push	0
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?width@ios_base@std@@QAEHH@Z
	jmp	SHORT $LN19@operator@5
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 777  : 		_CATCH_IO_(_Ostr)

	push	1
	push	4
	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Ostr$[ebp]
	add	edx, DWORD PTR [ecx+4]
	mov	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, $LN13@operator@5
	ret	0
$LN19@operator@5:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN13@operator@5:

; 778  : 		}
; 779  : 
; 780  : 	_Ostr.setstate(_State);

	push	0
	mov	eax, DWORD PTR __State$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Ostr$[ebp]
	add	ecx, DWORD PTR [edx+4]
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 781  : 	return (_Ostr);

	mov	eax, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR $T75863[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	lea	ecx, DWORD PTR __Ok$[ebp]
	call	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
	mov	eax, DWORD PTR $T75863[ebp]

; 782  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 774  : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 775  : 
; 776  :  #if _HAS_ITERATOR_DEBUGGING
; 777  : 		if (size() <= _Pos)
; 778  : 			{
; 779  : 			_DEBUG_ERROR("vector subscript out of range");
; 780  : 			_SCL_SECURE_OUT_OF_RANGE;
; 781  : 			}
; 782  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 783  : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	cmp	DWORD PTR __Pos$[ebp], eax
	jb	SHORT $LN1@operator@6
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@6:

; 784  : 
; 785  : 		return (*(_Myfirst + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	imul	eax, 28					; 0000001cH
	mov	ecx, DWORD PTR _this$[ebp]
	add	eax, DWORD PTR [ecx+12]

; 786  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty, COMDAT
; _this$ = ecx

; 735  : 		{	// test if sequence is empty

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 736  : 		return (size() == 0);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEIXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::size
	neg	eax
	sbb	eax, eax
	add	eax, 1

; 737  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
_TEXT	ENDS
PUBLIC	?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::hasCommentForValue
; Function compile flags: /Odtp
; File e:\newggdevelop\client\ggjsoncpp\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledStreamWriter::hasCommentForValue, COMDAT
; _this$ = ecx

; 789  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 790  :    return value.hasComment( commentBefore )
; 791  :           ||  value.hasComment( commentAfterOnSameLine )
; 792  :           ||  value.hasComment( commentAfter );

	push	0
	mov	ecx, DWORD PTR _value$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@hasComment@2
	push	1
	mov	ecx, DWORD PTR _value$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@hasComment@2
	push	2
	mov	ecx, DWORD PTR _value$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@hasComment@2
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN4@hasComment@2
$LN3@hasComment@2:
	mov	DWORD PTR tv79[ebp], 1
$LN4@hasComment@2:
	mov	al, BYTE PTR tv79[ebp]

; 793  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledStreamWriter::hasCommentForValue
_TEXT	ENDS
PUBLIC	?writeIndent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::writeIndent
; Function compile flags: /Odtp
;	COMDAT ?writeIndent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
?writeIndent@StyledStreamWriter@Json@@AAEXXZ PROC	; Json::StyledStreamWriter::writeIndent, COMDAT
; _this$ = ecx

; 722  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 723  :   /*
; 724  :     Some comments in this method would have been nice. ;-)
; 725  : 
; 726  :    if ( !document_.empty() )
; 727  :    {
; 728  :       char last = document_[document_.length()-1];
; 729  :       if ( last == ' ' )     // already indented
; 730  :          return;
; 731  :       if ( last != '\n' )    // Comments may add new-line
; 732  :          *document_ << '\n';
; 733  :    }
; 734  :   */
; 735  :    *document_ << '\n' << indentString_;

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 28					; 0000001cH
	push	eax
	push	10					; 0000000aH
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	push	eax
	call	DWORD PTR __imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8

; 736  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?writeIndent@StyledStreamWriter@Json@@AAEXXZ ENDP	; Json::StyledStreamWriter::writeIndent
_TEXT	ENDS
PUBLIC	?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::hasCommentForValue
; Function compile flags: /Odtp
;	COMDAT ?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
tv79 = -8						; size = 4
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::hasCommentForValue, COMDAT
; _this$ = ecx

; 508  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx

; 509  :    return value.hasComment( commentBefore )
; 510  :           ||  value.hasComment( commentAfterOnSameLine )
; 511  :           ||  value.hasComment( commentAfter );

	push	0
	mov	ecx, DWORD PTR _value$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN3@hasComment@3
	push	1
	mov	ecx, DWORD PTR _value$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@hasComment@3
	push	2
	mov	ecx, DWORD PTR _value$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN3@hasComment@3
	mov	DWORD PTR tv79[ebp], 0
	jmp	SHORT $LN4@hasComment@3
$LN3@hasComment@3:
	mov	DWORD PTR tv79[ebp], 1
$LN4@hasComment@3:
	mov	al, BYTE PTR tv79[ebp]

; 512  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::hasCommentForValue
_TEXT	ENDS
PUBLIC	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
; Function compile flags: /Odtp
;	COMDAT ?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::writeWithIndent, COMDAT
; _this$ = ecx

; 460  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 461  :    writeIndent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent

; 462  :    document_ += value;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 463  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::writeWithIndent
_TEXT	ENDS
PUBLIC	??0FastWriter@Json@@QAE@XZ			; Json::FastWriter::FastWriter
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0FastWriter@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0FastWriter@Json@@QAE@XZ$0
__ehfuncinfo$??0FastWriter@Json@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0FastWriter@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0FastWriter@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0FastWriter@Json@@QAE@XZ PROC				; Json::FastWriter::FastWriter, COMDAT
; _this$ = ecx

; 176  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0FastWriter@Json@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Writer@Json@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7FastWriter@Json@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+32], 0
	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+33], 0

; 177  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0FastWriter@Json@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Writer@Json@@UAE@XZ			; Json::Writer::~Writer
__ehhandler$??0FastWriter@Json@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0FastWriter@Json@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0FastWriter@Json@@QAE@XZ ENDP				; Json::FastWriter::FastWriter
PUBLIC	__$ArrayPad$
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
; Function compile flags: /Odtp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z
_TEXT	SEGMENT
$T75908 = -40						; size = 4
_buffer$ = -36						; size = 25
__$ArrayPad$ = -8					; size = 4
_current$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 8
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z PROC ; Json::valueToString, COMDAT

; 50   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR $T75908[ebp], 0

; 51   :    UIntToStringBuffer buffer;
; 52   :    char *current = buffer + sizeof(buffer);

	lea	eax, DWORD PTR _buffer$[ebp+25]
	mov	DWORD PTR _current$[ebp], eax

; 53   :    uintToString( value, current );

	lea	ecx, DWORD PTR _current$[ebp]
	push	ecx
	mov	edx, DWORD PTR _value$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	call	?uintToString@Json@@YAX_KAAPAD@Z	; Json::uintToString
	add	esp, 12					; 0000000cH

; 54   :    assert( current >= buffer );
; 55   :    return current;

	mov	ecx, DWORD PTR _current$[ebp]
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	edx, DWORD PTR $T75908[ebp]
	or	edx, 1
	mov	DWORD PTR $T75908[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 56   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ENDP ; Json::valueToString
_TEXT	ENDS
PUBLIC	__$ArrayPad$
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
; Function compile flags: /Odtp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z
_TEXT	SEGMENT
tv66 = -48						; size = 4
$T75916 = -44						; size = 4
_buffer$ = -40						; size = 25
__$ArrayPad$ = -12					; size = 4
_isNegative$ = -5					; size = 1
_current$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 8
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z PROC ; Json::valueToString, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR $T75916[ebp], 0

; 36   :    UIntToStringBuffer buffer;
; 37   :    char *current = buffer + sizeof(buffer);

	lea	eax, DWORD PTR _buffer$[ebp+25]
	mov	DWORD PTR _current$[ebp], eax

; 38   :    bool isNegative = value < 0;

	cmp	DWORD PTR _value$[ebp+4], 0
	jg	SHORT $LN5@valueToStr@2
	jl	SHORT $LN9@valueToStr@2
	cmp	DWORD PTR _value$[ebp], 0
	jae	SHORT $LN5@valueToStr@2
$LN9@valueToStr@2:
	mov	DWORD PTR tv66[ebp], 1
	jmp	SHORT $LN6@valueToStr@2
$LN5@valueToStr@2:
	mov	DWORD PTR tv66[ebp], 0
$LN6@valueToStr@2:
	mov	cl, BYTE PTR tv66[ebp]
	mov	BYTE PTR _isNegative$[ebp], cl

; 39   :    if ( isNegative )

	movzx	edx, BYTE PTR _isNegative$[ebp]
	test	edx, edx
	je	SHORT $LN2@valueToStr@2

; 40   :       value = -value;

	mov	eax, DWORD PTR _value$[ebp]
	neg	eax
	mov	ecx, DWORD PTR _value$[ebp+4]
	adc	ecx, 0
	neg	ecx
	mov	DWORD PTR _value$[ebp], eax
	mov	DWORD PTR _value$[ebp+4], ecx
$LN2@valueToStr@2:

; 41   :    uintToString( LargestUInt(value), current );

	lea	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	eax, DWORD PTR _value$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	?uintToString@Json@@YAX_KAAPAD@Z	; Json::uintToString
	add	esp, 12					; 0000000cH

; 42   :    if ( isNegative )

	movzx	edx, BYTE PTR _isNegative$[ebp]
	test	edx, edx
	je	SHORT $LN1@valueToStr@2

; 43   :       *--current = '-';

	mov	eax, DWORD PTR _current$[ebp]
	sub	eax, 1
	mov	DWORD PTR _current$[ebp], eax
	mov	ecx, DWORD PTR _current$[ebp]
	mov	BYTE PTR [ecx], 45			; 0000002dH
$LN1@valueToStr@2:

; 44   :    assert( current >= buffer );
; 45   :    return current;

	mov	edx, DWORD PTR _current$[ebp]
	push	edx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	eax, DWORD PTR $T75916[ebp]
	or	eax, 1
	mov	DWORD PTR $T75916[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 46   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ENDP ; Json::valueToString
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ?containsControlCharacter@Json@@YA_NPBD@Z
_TEXT	SEGMENT
tv68 = -1						; size = 1
_str$ = 8						; size = 4
?containsControlCharacter@Json@@YA_NPBD@Z PROC		; Json::containsControlCharacter, COMDAT

; 24   : {

	push	ebp
	mov	ebp, esp
	push	ecx
$LN3@containsCo:

; 25   :    while ( *str ) 

	mov	eax, DWORD PTR _str$[ebp]
	movsx	ecx, BYTE PTR [eax]
	test	ecx, ecx
	je	SHORT $LN2@containsCo

; 26   :    {
; 27   :       if ( isControlCharacter( *(str++) ) )

	mov	edx, DWORD PTR _str$[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv68[ebp], al
	movzx	ecx, BYTE PTR tv68[ebp]
	push	ecx
	call	?isControlCharacter@Json@@YA_ND@Z	; Json::isControlCharacter
	add	esp, 4
	movzx	edx, al
	mov	eax, DWORD PTR _str$[ebp]
	add	eax, 1
	mov	DWORD PTR _str$[ebp], eax
	test	edx, edx
	je	SHORT $LN1@containsCo

; 28   :          return true;

	mov	al, 1
	jmp	SHORT $LN4@containsCo
$LN1@containsCo:

; 29   :    }

	jmp	SHORT $LN3@containsCo
$LN2@containsCo:

; 30   :    return false;

	xor	al, al
$LN4@containsCo:

; 31   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?containsControlCharacter@Json@@YA_NPBD@Z ENDP		; Json::containsControlCharacter
; Function compile flags: /Odtp
; File c:\program files (x86)\microsoft visual studio 9.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++, COMDAT
; _this$ = ecx

; 115  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 116  : 		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@22
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@22:

; 117  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@22
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@22:

; 118  : 
; 119  :  #if _HAS_ITERATOR_DEBUGGING
; 120  : 		if (this->_Mycont == 0
; 121  : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 122  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 123  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 124  : 
; 125  : 		++_Myptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, 28					; 0000001cH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+4], ecx

; 126  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 127  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*, COMDAT
; _this$ = ecx

; 91   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 92   : 
; 93   :  #if _HAS_ITERATOR_DEBUGGING
; 94   : 		if (this->_Mycont == 0
; 95   : 			|| _Myptr < ((_Myvec *)this->_Mycont)->_Myfirst
; 96   : 			|| ((_Myvec *)this->_Mycont)->_Mylast <= _Myptr)
; 97   : 			{
; 98   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 99   : 			_SCL_SECURE_OUT_OF_RANGE;
; 100  : 			}
; 101  :  #else
; 102  :  		_SCL_SECURE_VALIDATE(this->_Has_container());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Has_container@_Iterator_base_aux@std@@QBE_NXZ ; std::_Iterator_base_aux::_Has_container
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN2@operator@23
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN2@operator@23:

; 103  : 		_SCL_SECURE_VALIDATE_RANGE(_Myptr < ((_Myvec *)(this->_Getmycont()))->_Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getmycont@_Iterator_base_aux@std@@QBEPBV_Container_base_aux@2@XZ ; std::_Iterator_base_aux::_Getmycont
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	cmp	edx, DWORD PTR [eax+16]
	jb	SHORT $LN1@operator@23
	call	DWORD PTR __imp___invalid_parameter_noinfo
$LN1@operator@23:

; 104  :  #endif /* _HAS_ITERATOR_DEBUGGING */
; 105  : 
; 106  : 		return (*_Myptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+4]

; 107  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++, COMDAT
; _this$ = ecx

; 348  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 349  : 		++(*(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++

; 350  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 351  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT ??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*, COMDAT
; _this$ = ecx

; 338  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 339  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*

; 340  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
_TEXT	ENDS
PUBLIC	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
;	COMDAT xdata$x
; File e:\newggdevelop\client\ggjsoncpp\json_writer.cpp
xdata$x	SEGMENT
__unwindtable$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4
__ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv155 = -196						; size = 4
tv160 = -192						; size = 4
tv153 = -188						; size = 4
tv159 = -184						; size = 4
tv151 = -180						; size = 4
tv158 = -176						; size = 4
tv149 = -172						; size = 4
tv157 = -168						; size = 4
tv147 = -164						; size = 4
tv156 = -160						; size = 4
_this$ = -156						; size = 4
$T76765 = -152						; size = 28
$T76764 = -124						; size = 28
$T76763 = -96						; size = 28
$T76762 = -68						; size = 28
$T76761 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine, COMDAT
; _this$ = ecx

; 774  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 775  :    if ( root.hasComment( commentAfterOnSameLine ) )

	push	1
	mov	ecx, DWORD PTR _root$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	eax, al
	test	eax, eax
	je	$LN2@writeComme

; 776  :       *document_ << " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	push	1
	lea	ecx, DWORD PTR $T76761[ebp]
	push	ecx
	mov	ecx, DWORD PTR _root$[ebp]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	DWORD PTR tv156[ebp], eax
	mov	edx, DWORD PTR tv156[ebp]
	mov	DWORD PTR tv147[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv147[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76762[ebp]
	push	ecx
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	add	esp, 8
	mov	DWORD PTR tv157[ebp], eax
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv149[ebp]
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	lea	ecx, DWORD PTR $T76763[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv158[ebp], eax
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR tv151[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv151[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR __imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T76763[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T76762[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76761[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@writeComme:

; 777  : 
; 778  :    if ( root.hasComment( commentAfter ) )

	push	2
	mov	ecx, DWORD PTR _root$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	eax, al
	test	eax, eax
	je	$LN3@writeComme

; 779  :    {
; 780  :       *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 781  :       *document_ << normalizeEOL( root.getComment( commentAfter ) );

	push	2
	lea	eax, DWORD PTR $T76764[ebp]
	push	eax
	mov	ecx, DWORD PTR _root$[ebp]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	DWORD PTR tv159[ebp], eax
	mov	ecx, DWORD PTR tv159[ebp]
	mov	DWORD PTR tv153[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR tv153[ebp]
	push	edx
	lea	eax, DWORD PTR $T76765[ebp]
	push	eax
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	add	esp, 8
	mov	DWORD PTR tv160[ebp], eax
	mov	ecx, DWORD PTR tv160[ebp]
	mov	DWORD PTR tv155[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR tv155[ebp]
	push	edx
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR __imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T76765[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76764[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 782  :       *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN3@writeComme:

; 783  :    }
; 784  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T76761[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T76762[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T76763[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T76764[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T76765[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
__ehfuncinfo$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv89 = -88						; size = 4
tv91 = -84						; size = 4
tv87 = -80						; size = 4
tv90 = -76						; size = 4
_this$ = -72						; size = 4
$T76780 = -68						; size = 28
$T76779 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeCommentBeforeValue, COMDAT
; _this$ = ecx

; 764  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 765  :    if ( !root.hasComment( commentBefore ) )

	push	0
	mov	ecx, DWORD PTR _root$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@writeComme@2

; 766  :       return;

	jmp	$LN2@writeComme@2
$LN1@writeComme@2:

; 767  :    *document_ << normalizeEOL( root.getComment( commentBefore ) );

	push	0
	lea	ecx, DWORD PTR $T76779[ebp]
	push	ecx
	mov	ecx, DWORD PTR _root$[ebp]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	DWORD PTR tv90[ebp], eax
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv87[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv87[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76780[ebp]
	push	ecx
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	add	esp, 8
	mov	DWORD PTR tv91[ebp], eax
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv89[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR __imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T76780[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76779[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 768  :    *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN2@writeComme@2:

; 769  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T76779[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T76780[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeCommentBeforeValue
PUBLIC	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
; Function compile flags: /Odtp
;	COMDAT ?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::writeWithIndent, COMDAT
; _this$ = ecx

; 741  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 742  :    writeIndent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 743  :    *document_ << value;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR __imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8

; 744  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::writeWithIndent
_TEXT	ENDS
PUBLIC	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4
__ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv155 = -196						; size = 4
tv160 = -192						; size = 4
tv153 = -188						; size = 4
tv159 = -184						; size = 4
tv151 = -180						; size = 4
tv158 = -176						; size = 4
tv149 = -172						; size = 4
tv157 = -168						; size = 4
tv147 = -164						; size = 4
tv156 = -160						; size = 4
_this$ = -156						; size = 4
$T76797 = -152						; size = 28
$T76796 = -124						; size = 28
$T76795 = -96						; size = 28
$T76794 = -68						; size = 28
$T76793 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentAfterValueOnSameLine, COMDAT
; _this$ = ecx

; 493  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 184				; 000000b8H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 494  :    if ( root.hasComment( commentAfterOnSameLine ) )

	push	1
	mov	ecx, DWORD PTR _root$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	eax, al
	test	eax, eax
	je	$LN2@writeComme@3

; 495  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	push	1
	lea	ecx, DWORD PTR $T76793[ebp]
	push	ecx
	mov	ecx, DWORD PTR _root$[ebp]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	DWORD PTR tv156[ebp], eax
	mov	edx, DWORD PTR tv156[ebp]
	mov	DWORD PTR tv147[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv147[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76794[ebp]
	push	ecx
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 8
	mov	DWORD PTR tv157[ebp], eax
	mov	edx, DWORD PTR tv157[ebp]
	mov	DWORD PTR tv149[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv149[ebp]
	push	eax
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	lea	ecx, DWORD PTR $T76795[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv158[ebp], eax
	mov	edx, DWORD PTR tv158[ebp]
	mov	DWORD PTR tv151[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR tv151[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T76795[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T76794[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76793[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN2@writeComme@3:

; 496  : 
; 497  :    if ( root.hasComment( commentAfter ) )

	push	2
	mov	ecx, DWORD PTR _root$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@writeComme@3

; 498  :    {
; 499  :       document_ += "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 500  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	push	2
	lea	edx, DWORD PTR $T76796[ebp]
	push	edx
	mov	ecx, DWORD PTR _root$[ebp]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	DWORD PTR tv159[ebp], eax
	mov	eax, DWORD PTR tv159[ebp]
	mov	DWORD PTR tv153[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv153[ebp]
	push	ecx
	lea	edx, DWORD PTR $T76797[ebp]
	push	edx
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 8
	mov	DWORD PTR tv160[ebp], eax
	mov	eax, DWORD PTR tv160[ebp]
	mov	DWORD PTR tv155[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv155[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR $T76797[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76796[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 501  :       document_ += "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN3@writeComme@3:

; 502  :    }
; 503  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T76793[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T76794[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T76795[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T76796[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T76797[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-188]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
__ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv89 = -88						; size = 4
tv91 = -84						; size = 4
tv87 = -80						; size = 4
tv90 = -76						; size = 4
_this$ = -72						; size = 4
$T76812 = -68						; size = 28
$T76811 = -40						; size = 28
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentBeforeValue, COMDAT
; _this$ = ecx

; 483  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 484  :    if ( !root.hasComment( commentBefore ) )

	push	0
	mov	ecx, DWORD PTR _root$[ebp]
	call	?hasComment@Value@Json@@QBE_NW4CommentPlacement@2@@Z ; Json::Value::hasComment
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN1@writeComme@4

; 485  :       return;

	jmp	SHORT $LN2@writeComme@4
$LN1@writeComme@4:

; 486  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	push	0
	lea	ecx, DWORD PTR $T76811[ebp]
	push	ecx
	mov	ecx, DWORD PTR _root$[ebp]
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	mov	DWORD PTR tv90[ebp], eax
	mov	edx, DWORD PTR tv90[ebp]
	mov	DWORD PTR tv87[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR tv87[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76812[ebp]
	push	ecx
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 8
	mov	DWORD PTR tv91[ebp], eax
	mov	edx, DWORD PTR tv91[ebp]
	mov	DWORD PTR tv89[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR tv89[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T76812[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T76811[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 487  :    document_ += "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN2@writeComme@4:

; 488  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T76811[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T76812[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentBeforeValue
PUBLIC	__$ArrayPad$
PUBLIC	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4
	DD	04H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5
__ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
tv222 = -324						; size = 4
tv161 = -320						; size = 4
tv141 = -316						; size = 4
tv95 = -312						; size = 4
tv250 = -305						; size = 1
tv247 = -304						; size = 4
tv244 = -300						; size = 4
tv217 = -296						; size = 4
tv226 = -292						; size = 4
tv215 = -288						; size = 4
tv225 = -284						; size = 4
$T76830 = -280						; size = 4
$T76828 = -276						; size = 28
$T76827 = -245						; size = 1
$T76826 = -244						; size = 8
$T76825 = -236						; size = 28
$T76824 = -208						; size = 28
_oss$55959 = -180					; size = 128
_c$55935 = -52						; size = 4
_result$ = -48						; size = 28
__$ArrayPad$ = -20					; size = 4
_maxsize$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::valueToQuotedString, COMDAT

; 99   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 312				; 00000138H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T76830[ebp], 0

; 100  :    if (value == NULL)

	cmp	DWORD PTR _value$[ebp], 0
	jne	SHORT $LN17@valueToQuo

; 101  :       return "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T76830[ebp]
	or	eax, 1
	mov	DWORD PTR $T76830[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN18@valueToQuo
$LN17@valueToQuo:

; 102  :    // Not sure how to handle unicode...
; 103  :    if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL && !containsControlCharacter( value ))

	push	OFFSET ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	call	DWORD PTR __imp__strpbrk
	add	esp, 8
	test	eax, eax
	jne	$LN16@valueToQuo
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	call	?containsControlCharacter@Json@@YA_NPBD@Z ; Json::containsControlCharacter
	add	esp, 4
	movzx	eax, al
	test	eax, eax
	jne	$LN16@valueToQuo

; 104  :       return std::string("\"") + value + "\"";

	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR $T76824[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR tv225[ebp], eax
	mov	ecx, DWORD PTR tv225[ebp]
	mov	DWORD PTR tv215[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	eax, DWORD PTR tv215[ebp]
	push	eax
	lea	ecx, DWORD PTR $T76825[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv226[ebp], eax
	mov	edx, DWORD PTR tv226[ebp]
	mov	DWORD PTR tv217[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	eax, DWORD PTR tv217[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	call	DWORD PTR __imp_??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@PBD@Z
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR $T76830[ebp]
	or	edx, 1
	mov	DWORD PTR $T76830[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T76825[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T76824[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	$LN18@valueToQuo
$LN16@valueToQuo:

; 105  :    // We have to walk value and escape any special characters.
; 106  :    // Appending to std::string is not efficient, but this should be rare.
; 107  :    // (Note: forward slashes are *not* rare, but I am not escaping them.)
; 108  :    std::string::size_type maxsize = strlen(value)*2 + 3; // allescaped+quotes+NULL

	mov	eax, DWORD PTR _value$[ebp]
	mov	DWORD PTR tv244[ebp], eax
	mov	ecx, DWORD PTR tv244[ebp]
	add	ecx, 1
	mov	DWORD PTR tv247[ebp], ecx
$LL27@valueToQuo:
	mov	edx, DWORD PTR tv244[ebp]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv250[ebp], al
	add	DWORD PTR tv244[ebp], 1
	cmp	BYTE PTR tv250[ebp], 0
	jne	SHORT $LL27@valueToQuo
	mov	ecx, DWORD PTR tv244[ebp]
	sub	ecx, DWORD PTR tv247[ebp]
	mov	DWORD PTR tv95[ebp], ecx
	mov	edx, DWORD PTR tv95[ebp]
	lea	eax, DWORD PTR [edx+edx+3]
	mov	DWORD PTR _maxsize$[ebp], eax

; 109  :    std::string result;

	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 110  :    result.reserve(maxsize); // to avoid lots of mallocs

	mov	ecx, DWORD PTR _maxsize$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z

; 111  :    result += "\"";

	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 112  :    for (const char* c=value; *c != 0; ++c)

	mov	edx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _c$55935[ebp], edx
	jmp	SHORT $LN15@valueToQuo
$LN14@valueToQuo:
	mov	eax, DWORD PTR _c$55935[ebp]
	add	eax, 1
	mov	DWORD PTR _c$55935[ebp], eax
$LN15@valueToQuo:
	mov	ecx, DWORD PTR _c$55935[ebp]
	movsx	edx, BYTE PTR [ecx]
	test	edx, edx
	je	$LN13@valueToQuo

; 113  :    {
; 114  :       switch(*c)

	mov	eax, DWORD PTR _c$55935[ebp]
	movsx	ecx, BYTE PTR [eax]
	mov	DWORD PTR tv141[ebp], ecx
	mov	edx, DWORD PTR tv141[ebp]
	sub	edx, 8
	mov	DWORD PTR tv141[ebp], edx
	cmp	DWORD PTR tv141[ebp], 84		; 00000054H
	ja	$LN3@valueToQuo
	mov	eax, DWORD PTR tv141[ebp]
	movzx	ecx, BYTE PTR $LN28@valueToQuo[eax]
	jmp	DWORD PTR $LN30@valueToQuo[ecx*4]
$LN10@valueToQuo:

; 115  :       {
; 116  :          case '\"':
; 117  :             result += "\\\"";

	push	OFFSET ??_C@_02MCKKLHBJ@?2?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 118  :             break;

	jmp	$LN11@valueToQuo
$LN9@valueToQuo:

; 119  :          case '\\':
; 120  :             result += "\\\\";

	push	OFFSET ??_C@_02HDBGODGB@?2?2?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 121  :             break;

	jmp	$LN11@valueToQuo
$LN8@valueToQuo:

; 122  :          case '\b':
; 123  :             result += "\\b";

	push	OFFSET ??_C@_02DCNDPIBM@?2b?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 124  :             break;

	jmp	$LN11@valueToQuo
$LN7@valueToQuo:

; 125  :          case '\f':
; 126  :             result += "\\f";

	push	OFFSET ??_C@_02FGLPDNBI@?2f?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 127  :             break;

	jmp	$LN11@valueToQuo
$LN6@valueToQuo:

; 128  :          case '\n':
; 129  :             result += "\\n";

	push	OFFSET ??_C@_02JOGGLHBA@?2n?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 130  :             break;

	jmp	$LN11@valueToQuo
$LN5@valueToQuo:

; 131  :          case '\r':
; 132  :             result += "\\r";

	push	OFFSET ??_C@_02HIBBOKEN@?2r?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 133  :             break;

	jmp	$LN11@valueToQuo
$LN4@valueToQuo:

; 134  :          case '\t':
; 135  :             result += "\\t";

	push	OFFSET ??_C@_02COELENML@?2t?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 136  :             break;

	jmp	$LN11@valueToQuo
$LN3@valueToQuo:

; 137  :          //case '/':
; 138  :             // Even though \/ is considered a legal escape in JSON, a bare
; 139  :             // slash is also legal, so I see no reason to escape it.
; 140  :             // (I hope I am not misunderstanding something.
; 141  :             // blep notes: actually escaping \/ may be useful in javascript to avoid </ 
; 142  :             // sequence.
; 143  :             // Should add a flag to allow this compatibility mode and prevent this 
; 144  :             // sequence from occurring.
; 145  :          default:
; 146  :             if ( isControlCharacter( *c ) )

	mov	edx, DWORD PTR _c$55935[ebp]
	movzx	eax, BYTE PTR [edx]
	push	eax
	call	?isControlCharacter@Json@@YA_ND@Z	; Json::isControlCharacter
	add	esp, 4
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@valueToQuo

; 147  :             {
; 148  :                std::ostringstream oss;

	push	1
	push	2
	lea	ecx, DWORD PTR _oss$55959[ebp]
	call	DWORD PTR __imp_??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 149  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	mov	edx, DWORD PTR _c$55935[ebp]
	movsx	eax, BYTE PTR [edx]
	push	eax
	push	4
	lea	ecx, DWORD PTR $T76826[ebp]
	push	ecx
	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@H@1@H@Z
	add	esp, 8
	push	eax
	push	48					; 00000030H
	lea	edx, DWORD PTR $T76827[ebp]
	push	edx
	call	??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ; std::setfill<char>
	add	esp, 8
	push	eax
	push	OFFSET ?uppercase@std@@YAAAVios_base@1@AAV21@@Z ; std::uppercase
	push	OFFSET ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex
	push	OFFSET ??_C@_02DHFAHMIK@?2u?$AA@
	lea	eax, DWORD PTR _oss$55959[ebp]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	push	eax
	call	??$?6DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ; std::operator<<<char,std::char_traits<char> >
	add	esp, 8
	push	eax
	call	??$?6DU?$char_traits@D@std@@H@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@H@0@@Z ; std::operator<<<char,std::char_traits<char>,int>
	add	esp, 8
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 150  :                result += oss.str();

	lea	ecx, DWORD PTR $T76828[ebp]
	push	ecx
	lea	ecx, DWORD PTR _oss$55959[ebp]
	call	DWORD PTR __imp_?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
	mov	DWORD PTR tv161[ebp], eax
	mov	edx, DWORD PTR tv161[ebp]
	mov	DWORD PTR tv222[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR tv222[ebp]
	push	eax
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T76828[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 151  :             }

	mov	BYTE PTR __$EHRec$[ebp+8], 3
	lea	ecx, DWORD PTR _oss$55959[ebp]
	call	DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ

; 152  :             else

	jmp	SHORT $LN11@valueToQuo
$LN2@valueToQuo:

; 153  :             {
; 154  :                result += *c;

	mov	ecx, DWORD PTR _c$55935[ebp]
	movzx	edx, BYTE PTR [ecx]
	push	edx
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
$LN11@valueToQuo:

; 155  :             }
; 156  :             break;
; 157  :       }
; 158  :    }

	jmp	$LN14@valueToQuo
$LN13@valueToQuo:

; 159  :    result += "\"";

	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 160  :    return result;

	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	ecx, DWORD PTR $T76830[ebp]
	or	ecx, 1
	mov	DWORD PTR $T76830[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _result$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN18@valueToQuo:

; 161  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN30@valueToQuo:
	DD	$LN8@valueToQuo
	DD	$LN4@valueToQuo
	DD	$LN6@valueToQuo
	DD	$LN7@valueToQuo
	DD	$LN5@valueToQuo
	DD	$LN10@valueToQuo
	DD	$LN9@valueToQuo
	DD	$LN3@valueToQuo
$LN28@valueToQuo:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0:
	mov	eax, DWORD PTR $T76830[ebp]
	and	eax, 1
	je	$LN21@valueToQuo
	and	DWORD PTR $T76830[ebp], -2		; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN21@valueToQuo:
	ret	0
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1:
	lea	ecx, DWORD PTR $T76824[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$2:
	lea	ecx, DWORD PTR $T76825[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4:
	lea	ecx, DWORD PTR _oss$55959[ebp]
	jmp	DWORD PTR __imp_??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5:
	lea	ecx, DWORD PTR $T76828[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-316]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::valueToQuotedString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
; Function compile flags: /Odtp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T76849 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::valueToString, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR $T76849[ebp], 0

; 68   :    return valueToString( LargestUInt(value) );

	mov	eax, DWORD PTR _value$[ebp]
	xor	ecx, ecx
	push	ecx
	push	eax
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	edx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR $T76849[ebp]
	or	eax, 1
	mov	DWORD PTR $T76849[ebp], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 69   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::valueToString
_TEXT	ENDS
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
; Function compile flags: /Odtp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
$T76854 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Json::valueToString, COMDAT

; 61   : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR $T76854[ebp], 0

; 62   :    return valueToString( LargestInt(value) );

	mov	eax, DWORD PTR _value$[ebp]
	cdq
	push	edx
	push	eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR $T76854[ebp]
	or	ecx, 1
	mov	DWORD PTR $T76854[ebp], ecx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 63   : }

	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Json::valueToString
PUBLIC	??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::StyledStreamWriter
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
__ehfuncinfo$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_indentation$ = 8					; size = 28
??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::StyledStreamWriter, COMDAT
; _this$ = ecx

; 547  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+24], 0
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+56], 74			; 0000004aH
	lea	edx, DWORD PTR _indentation$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 60					; 0000003cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+88], 0

; 548  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _indentation$[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _indentation$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::StyledStreamWriter
PUBLIC	??0StyledWriter@Json@@QAE@XZ			; Json::StyledWriter::StyledWriter
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0StyledWriter@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StyledWriter@Json@@QAE@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StyledWriter@Json@@QAE@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0StyledWriter@Json@@QAE@XZ$2
__ehfuncinfo$??0StyledWriter@Json@@QAE@XZ DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0StyledWriter@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??0StyledWriter@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0StyledWriter@Json@@QAE@XZ PROC			; Json::StyledWriter::StyledWriter, COMDAT
; _this$ = ecx

; 270  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0StyledWriter@Json@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Writer@Json@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], OFFSET ??_7StyledWriter@Json@@6B@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??0?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [ecx+84], 74			; 0000004aH
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+88], 3
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+92], 0

; 271  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StyledWriter@Json@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1Writer@Json@@UAE@XZ			; Json::Writer::~Writer
__unwindfunclet$??0StyledWriter@Json@@QAE@XZ$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0StyledWriter@Json@@QAE@XZ$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$??0StyledWriter@Json@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0StyledWriter@Json@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0StyledWriter@Json@@QAE@XZ ENDP			; Json::StyledWriter::StyledWriter
PUBLIC	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
; Function compile flags: /Odtp
;	COMDAT ?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::pushValue, COMDAT
; _this$ = ecx

; 712  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 713  :    if ( addChildValues_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+88]
	test	ecx, ecx
	je	SHORT $LN2@pushValue

; 714  :       childValues_.push_back( value );

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 715  :    else

	jmp	SHORT $LN3@pushValue
$LN2@pushValue:

; 716  :       *document_ << value;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	DWORD PTR __imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8
$LN3@pushValue:

; 717  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::pushValue
_TEXT	ENDS
PUBLIC	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
; Function compile flags: /Odtp
;	COMDAT ?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_value$ = 8						; size = 4
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::pushValue, COMDAT
; _this$ = ecx

; 435  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 436  :    if ( addChildValues_ )

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+92]
	test	ecx, ecx
	je	SHORT $LN2@pushValue@2

; 437  :       childValues_.push_back( value );

	mov	edx, DWORD PTR _value$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 438  :    else

	jmp	SHORT $LN3@pushValue@2
$LN2@pushValue@2:

; 439  :       document_ += value;

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
$LN3@pushValue@2:

; 440  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::pushValue
_TEXT	ENDS
PUBLIC	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
PUBLIC	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray
PUBLIC	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
__ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T78156 = -116						; size = 28
$T78155 = -88						; size = 28
$T78154 = -60						; size = 28
_index$56406 = -32					; size = 4
_childValue$56398 = -28					; size = 4
_index$56394 = -24					; size = 4
_hasChildValue$56393 = -18				; size = 1
_isArrayMultiLine$56390 = -17				; size = 1
_size$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 351  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 352  :    unsigned size = value.size();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	DWORD PTR _size$[ebp], eax

; 353  :    if ( size == 0 )

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN13@writeArray

; 354  :       pushValue( "[]" );

	push	OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	ecx, DWORD PTR $T78154[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T78154[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78154[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 355  :    else

	jmp	$LN14@writeArray
$LN13@writeArray:

; 356  :    {
; 357  :       bool isArrayMultiLine = isMultineArray( value );

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray
	mov	BYTE PTR _isArrayMultiLine$56390[ebp], al

; 358  :       if ( isArrayMultiLine )

	movzx	edx, BYTE PTR _isArrayMultiLine$56390[ebp]
	test	edx, edx
	je	$LN11@writeArray

; 359  :       {
; 360  :          writeWithIndent( "[" );

	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR $T78155[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR $T78155[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78155[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 361  :          indent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent

; 362  :          bool hasChildValue = !childValues_.empty();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	mov	BYTE PTR _hasChildValue$56393[ebp], cl

; 363  :          unsigned index =0;

	mov	DWORD PTR _index$56394[ebp], 0
$LN10@writeArray:

; 364  :          for (;;)
; 365  :          {
; 366  :             const Value &childValue = value[index];

	mov	edx, DWORD PTR _index$56394[ebp]
	push	edx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _childValue$56398[ebp], eax

; 367  :             writeCommentBeforeValue( childValue );

	mov	eax, DWORD PTR _childValue$56398[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 368  :             if ( hasChildValue )

	movzx	ecx, BYTE PTR _hasChildValue$56393[ebp]
	test	ecx, ecx
	je	SHORT $LN8@writeArray

; 369  :                writeWithIndent( childValues_[index] );

	mov	edx, DWORD PTR _index$56394[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent

; 370  :             else

	jmp	SHORT $LN7@writeArray
$LN8@writeArray:

; 371  :             {
; 372  :                writeIndent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeIndent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::writeIndent

; 373  :                writeValue( childValue );

	mov	eax, DWORD PTR _childValue$56398[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
$LN7@writeArray:

; 374  :             }
; 375  :             if ( ++index == size )

	mov	ecx, DWORD PTR _index$56394[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$56394[ebp], ecx
	mov	edx, DWORD PTR _index$56394[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jne	SHORT $LN6@writeArray

; 376  :             {
; 377  :                writeCommentAfterValueOnSameLine( childValue );

	mov	eax, DWORD PTR _childValue$56398[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 378  :                break;

	jmp	SHORT $LN9@writeArray
$LN6@writeArray:

; 379  :             }
; 380  :             document_ += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 381  :             writeCommentAfterValueOnSameLine( childValue );

	mov	ecx, DWORD PTR _childValue$56398[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 382  :          }

	jmp	$LN10@writeArray
$LN9@writeArray:

; 383  :          unindent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?unindent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::unindent

; 384  :          writeWithIndent( "]" );

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR $T78156[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	edx, DWORD PTR $T78156[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78156[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 385  :       }
; 386  :       else // output on a single line

	jmp	SHORT $LN14@writeArray
$LN11@writeArray:

; 387  :       {
; 388  :          assert( childValues_.size() == size );
; 389  :          document_ += "[ ";

	push	OFFSET ??_C@_02PFNDMDBO@?$FL?5?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 390  :          for ( unsigned index =0; index < size; ++index )

	mov	DWORD PTR _index$56406[ebp], 0
	jmp	SHORT $LN4@writeArray
$LN3@writeArray:
	mov	eax, DWORD PTR _index$56406[ebp]
	add	eax, 1
	mov	DWORD PTR _index$56406[ebp], eax
$LN4@writeArray:
	mov	ecx, DWORD PTR _index$56406[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jae	SHORT $LN2@writeArray

; 391  :          {
; 392  :             if ( index > 0 )

	cmp	DWORD PTR _index$56406[ebp], 0
	jbe	SHORT $LN1@writeArray

; 393  :                document_ += ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@writeArray:

; 394  :             document_ += childValues_[index];

	mov	edx, DWORD PTR _index$56406[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z

; 395  :          }

	jmp	SHORT $LN3@writeArray
$LN2@writeArray:

; 396  :          document_ += " ]";

	push	OFFSET ??_C@_02DHOGEDBE@?5?$FN?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN14@writeArray:

; 397  :       }
; 398  :    }
; 399  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T78154[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T78155[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T78156[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeArrayValue
PUBLIC	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
PUBLIC	?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::isMultineArray
; Function compile flags: /Odtp
;	COMDAT ?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
tv166 = -40						; size = 4
tv159 = -36						; size = 4
tv92 = -32						; size = 4
_this$ = -28						; size = 4
_index$56672 = -24					; size = 4
_lineLength$56671 = -20					; size = 4
_childValue$56669 = -16					; size = 4
_index$56665 = -12					; size = 4
_size$ = -8						; size = 4
_isMultiLine$ = -1					; size = 1
_value$ = 8						; size = 4
?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledStreamWriter::isMultineArray, COMDAT
; _this$ = ecx

; 681  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 682  :    int size = value.size();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	DWORD PTR _size$[ebp], eax

; 683  :    bool isMultiLine = size*3 >= rightMargin_ ;

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	eax, DWORD PTR [ecx+56]
	setge	dl
	mov	BYTE PTR _isMultiLine$[ebp], dl

; 684  :    childValues_.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear

; 685  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	mov	DWORD PTR _index$56665[ebp], 0
	jmp	SHORT $LN7@isMultineA
$LN6@isMultineA:
	mov	eax, DWORD PTR _index$56665[ebp]
	add	eax, 1
	mov	DWORD PTR _index$56665[ebp], eax
$LN7@isMultineA:
	mov	ecx, DWORD PTR _index$56665[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jge	SHORT $LN5@isMultineA
	movzx	edx, BYTE PTR _isMultiLine$[ebp]
	test	edx, edx
	jne	SHORT $LN5@isMultineA

; 686  :    {
; 687  :       const Value &childValue = value[index];

	mov	eax, DWORD PTR _index$56665[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@H@Z		; Json::Value::operator[]
	mov	DWORD PTR _childValue$56669[ebp], eax

; 688  :       isMultiLine = isMultiLine  ||
; 689  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 690  :                         childValue.size() > 0 );

	movzx	ecx, BYTE PTR _isMultiLine$[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@isMultineA
	mov	ecx, DWORD PTR _childValue$56669[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@isMultineA
	mov	ecx, DWORD PTR _childValue$56669[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@isMultineA
$LN10@isMultineA:
	mov	ecx, DWORD PTR _childValue$56669[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	ja	SHORT $LN12@isMultineA
$LN11@isMultineA:
	mov	DWORD PTR tv92[ebp], 0
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	mov	DWORD PTR tv92[ebp], 1
$LN13@isMultineA:
	mov	cl, BYTE PTR tv92[ebp]
	mov	BYTE PTR _isMultiLine$[ebp], cl

; 691  :    }

	jmp	SHORT $LN6@isMultineA
$LN5@isMultineA:

; 692  :    if ( !isMultiLine ) // check if line length > max line length

	movzx	edx, BYTE PTR _isMultiLine$[ebp]
	test	edx, edx
	jne	$LN4@isMultineA

; 693  :    {
; 694  :       childValues_.reserve( size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve

; 695  :       addChildValues_ = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+88], 1

; 696  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'

	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edx+edx+2]
	mov	DWORD PTR _lineLength$56671[ebp], eax

; 697  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	mov	DWORD PTR _index$56672[ebp], 0
	jmp	SHORT $LN3@isMultineA
$LN2@isMultineA:
	mov	ecx, DWORD PTR _index$56672[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$56672[ebp], ecx
$LN3@isMultineA:
	mov	edx, DWORD PTR _index$56672[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jge	SHORT $LN1@isMultineA
	movzx	eax, BYTE PTR _isMultiLine$[ebp]
	test	eax, eax
	jne	SHORT $LN1@isMultineA

; 698  :       {
; 699  :          writeValue( value[index] );

	mov	ecx, DWORD PTR _index$56672[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@H@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue

; 700  :          lineLength += int( childValues_[index].length() );

	mov	edx, DWORD PTR _index$56672[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	add	eax, DWORD PTR _lineLength$56671[ebp]
	mov	DWORD PTR _lineLength$56671[ebp], eax

; 701  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );

	movzx	eax, BYTE PTR _isMultiLine$[ebp]
	test	eax, eax
	je	SHORT $LN14@isMultineA
	mov	ecx, DWORD PTR _index$56672[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@H@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::hasCommentForValue
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@isMultineA
	mov	DWORD PTR tv159[ebp], 1
	jmp	SHORT $LN15@isMultineA
$LN14@isMultineA:
	mov	DWORD PTR tv159[ebp], 0
$LN15@isMultineA:
	mov	al, BYTE PTR tv159[ebp]
	mov	BYTE PTR _isMultiLine$[ebp], al

; 702  :       }

	jmp	$LN2@isMultineA
$LN1@isMultineA:

; 703  :       addChildValues_ = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+88], 0

; 704  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;

	movzx	edx, BYTE PTR _isMultiLine$[ebp]
	test	edx, edx
	jne	SHORT $LN16@isMultineA
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lineLength$56671[ebp]
	cmp	ecx, DWORD PTR [eax+56]
	jge	SHORT $LN16@isMultineA
	mov	DWORD PTR tv166[ebp], 0
	jmp	SHORT $LN17@isMultineA
$LN16@isMultineA:
	mov	DWORD PTR tv166[ebp], 1
$LN17@isMultineA:
	mov	dl, BYTE PTR tv166[ebp]
	mov	BYTE PTR _isMultiLine$[ebp], dl
$LN4@isMultineA:

; 705  :    }
; 706  :    return isMultiLine;

	mov	al, BYTE PTR _isMultiLine$[ebp]

; 707  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledStreamWriter::isMultineArray
_TEXT	ENDS
PUBLIC	?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeArrayValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
__ehfuncinfo$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_this$ = -120						; size = 4
$T78477 = -116						; size = 28
$T78476 = -88						; size = 28
$T78475 = -60						; size = 28
_index$56654 = -32					; size = 4
_childValue$56647 = -28					; size = 4
_index$56643 = -24					; size = 4
_hasChildValue$56642 = -18				; size = 1
_isArrayMultiLine$56639 = -17				; size = 1
_size$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 628  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 108				; 0000006cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 629  :    unsigned size = value.size();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	DWORD PTR _size$[ebp], eax

; 630  :    if ( size == 0 )

	cmp	DWORD PTR _size$[ebp], 0
	jne	SHORT $LN13@writeArray@2

; 631  :       pushValue( "[]" );

	push	OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	ecx, DWORD PTR $T78475[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR $T78475[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78475[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 632  :    else

	jmp	$LN14@writeArray@2
$LN13@writeArray@2:

; 633  :    {
; 634  :       bool isArrayMultiLine = isMultineArray( value );

	mov	ecx, DWORD PTR _value$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::isMultineArray
	mov	BYTE PTR _isArrayMultiLine$56639[ebp], al

; 635  :       if ( isArrayMultiLine )

	movzx	edx, BYTE PTR _isArrayMultiLine$56639[ebp]
	test	edx, edx
	je	$LN11@writeArray@2

; 636  :       {
; 637  :          writeWithIndent( "[" );

	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR $T78476[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	eax, DWORD PTR $T78476[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78476[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 638  :          indent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?indent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::indent

; 639  :          bool hasChildValue = !childValues_.empty();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
	movzx	ecx, al
	neg	ecx
	sbb	ecx, ecx
	add	ecx, 1
	mov	BYTE PTR _hasChildValue$56642[ebp], cl

; 640  :          unsigned index =0;

	mov	DWORD PTR _index$56643[ebp], 0
$LN10@writeArray@2:

; 641  :          for (;;)
; 642  :          {
; 643  :             const Value &childValue = value[index];

	mov	edx, DWORD PTR _index$56643[ebp]
	push	edx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	mov	DWORD PTR _childValue$56647[ebp], eax

; 644  :             writeCommentBeforeValue( childValue );

	mov	eax, DWORD PTR _childValue$56647[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue

; 645  :             if ( hasChildValue )

	movzx	ecx, BYTE PTR _hasChildValue$56642[ebp]
	test	ecx, ecx
	je	SHORT $LN8@writeArray@2

; 646  :                writeWithIndent( childValues_[index] );

	mov	edx, DWORD PTR _index$56643[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent

; 647  :             else

	jmp	SHORT $LN7@writeArray@2
$LN8@writeArray@2:

; 648  :             {
; 649  :                writeIndent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 650  :                writeValue( childValue );

	mov	eax, DWORD PTR _childValue$56647[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
$LN7@writeArray@2:

; 651  :             }
; 652  :             if ( ++index == size )

	mov	ecx, DWORD PTR _index$56643[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$56643[ebp], ecx
	mov	edx, DWORD PTR _index$56643[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jne	SHORT $LN6@writeArray@2

; 653  :             {
; 654  :                writeCommentAfterValueOnSameLine( childValue );

	mov	eax, DWORD PTR _childValue$56647[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 655  :                break;

	jmp	SHORT $LN9@writeArray@2
$LN6@writeArray@2:

; 656  :             }
; 657  :             *document_ << ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	push	edx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 658  :             writeCommentAfterValueOnSameLine( childValue );

	mov	eax, DWORD PTR _childValue$56647[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 659  :          }

	jmp	$LN10@writeArray@2
$LN9@writeArray@2:

; 660  :          unindent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?unindent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::unindent

; 661  :          writeWithIndent( "]" );

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR $T78477[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T78477[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78477[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 662  :       }
; 663  :       else // output on a single line

	jmp	SHORT $LN14@writeArray@2
$LN11@writeArray@2:

; 664  :       {
; 665  :          assert( childValues_.size() == size );
; 666  :          *document_ << "[ ";

	push	OFFSET ??_C@_02PFNDMDBO@?$FL?5?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 667  :          for ( unsigned index =0; index < size; ++index )

	mov	DWORD PTR _index$56654[ebp], 0
	jmp	SHORT $LN4@writeArray@2
$LN3@writeArray@2:
	mov	ecx, DWORD PTR _index$56654[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$56654[ebp], ecx
$LN4@writeArray@2:
	mov	edx, DWORD PTR _index$56654[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jae	SHORT $LN2@writeArray@2

; 668  :          {
; 669  :             if ( index > 0 )

	cmp	DWORD PTR _index$56654[ebp], 0
	jbe	SHORT $LN1@writeArray@2

; 670  :                *document_ << ", ";

	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN1@writeArray@2:

; 671  :             *document_ << childValues_[index];

	mov	edx, DWORD PTR _index$56654[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
	push	eax
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	DWORD PTR __imp_??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	add	esp, 8

; 672  :          }

	jmp	SHORT $LN3@writeArray@2
$LN2@writeArray@2:

; 673  :          *document_ << " ]";

	push	OFFSET ??_C@_02DHOGEDBE@?5?$FN?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8
$LN14@writeArray@2:

; 674  :       }
; 675  :    }
; 676  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T78475[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T78476[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T78477[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeArrayValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$10
__ehfuncinfo$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv244 = -396						; size = 4
tv168 = -392						; size = 4
tv239 = -388						; size = 4
tv249 = -384						; size = 4
tv237 = -380						; size = 4
tv248 = -376						; size = 4
tv235 = -372						; size = 4
tv247 = -368						; size = 4
tv233 = -364						; size = 4
tv246 = -360						; size = 4
tv231 = -356						; size = 4
tv69 = -352						; size = 4
tv66 = -348						; size = 4
_this$ = -344						; size = 4
$T78499 = -340						; size = 28
$T78498 = -312						; size = 8
$T78497 = -304						; size = 28
$T78496 = -276						; size = 28
$T78495 = -248						; size = 28
$T78494 = -220						; size = 28
$T78493 = -192						; size = 28
$T78492 = -164						; size = 28
$T78491 = -136						; size = 28
$T78490 = -108						; size = 28
$T78489 = -80						; size = 28
_name$56625 = -52					; size = 4
_childValue$56626 = -48					; size = 4
_it$56620 = -44						; size = 8
_members$56615 = -36					; size = 24
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeValue, COMDAT
; _this$ = ecx

; 567  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 568  :    switch ( value.type() )

	mov	ecx, DWORD PTR _value$[ebp]
	call	?type@Value@Json@@QBE?AW4ValueType@2@XZ	; Json::Value::type
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 7
	ja	$LN14@writeValue
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN30@writeValue[eax*4]
$LN13@writeValue:

; 569  :    {
; 570  :    case nullValue:
; 571  :       pushValue( "null" );

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR $T78489[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T78489[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78489[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 572  :       break;

	jmp	$LN14@writeValue
$LN12@writeValue:

; 573  :    case intValue:
; 574  :       pushValue( valueToString( value.asLargestInt() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asLargestInt@Value@Json@@QBE_JXZ	; Json::Value::asLargestInt
	push	edx
	push	eax
	lea	edx, DWORD PTR $T78490[ebp]
	push	edx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv231[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv231[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78490[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 575  :       break;

	jmp	$LN14@writeValue
$LN11@writeValue:

; 576  :    case uintValue:
; 577  :       pushValue( valueToString( value.asLargestUInt() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asLargestUInt@Value@Json@@QBE_KXZ	; Json::Value::asLargestUInt
	push	edx
	push	eax
	lea	edx, DWORD PTR $T78491[ebp]
	push	edx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv246[ebp], eax
	mov	eax, DWORD PTR tv246[ebp]
	mov	DWORD PTR tv233[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv233[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78491[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 578  :       break;

	jmp	$LN14@writeValue
$LN10@writeValue:

; 579  :    case realValue:
; 580  :       pushValue( valueToString( value.asDouble() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	edx, DWORD PTR $T78492[ebp]
	push	edx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv247[ebp], eax
	mov	eax, DWORD PTR tv247[ebp]
	mov	DWORD PTR tv235[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv235[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78492[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 581  :       break;

	jmp	$LN14@writeValue
$LN9@writeValue:

; 582  :    case stringValue:
; 583  :       pushValue( valueToQuotedString( value.asCString() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asCString@Value@Json@@QBEPBDXZ		; Json::Value::asCString
	push	eax
	lea	edx, DWORD PTR $T78493[ebp]
	push	edx
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR tv248[ebp], eax
	mov	eax, DWORD PTR tv248[ebp]
	mov	DWORD PTR tv237[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv237[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78493[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 584  :       break;

	jmp	$LN14@writeValue
$LN8@writeValue:

; 585  :    case booleanValue:
; 586  :       pushValue( valueToString( value.asBool() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	edx, al
	push	edx
	lea	eax, DWORD PTR $T78494[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR tv249[ebp], eax
	mov	ecx, DWORD PTR tv249[ebp]
	mov	DWORD PTR tv239[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv239[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78494[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 587  :       break;

	jmp	$LN14@writeValue
$LN7@writeValue:

; 588  :    case arrayValue:
; 589  :       writeArrayValue( value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeArrayValue

; 590  :       break;

	jmp	$LN14@writeValue
$LN6@writeValue:

; 591  :    case objectValue:
; 592  :       {
; 593  :          Value::Members members( value.getMemberNames() );

	lea	ecx, DWORD PTR _members$56615[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 594  :          if ( members.empty() )

	lea	ecx, DWORD PTR _members$56615[ebp]
	call	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@writeValue

; 595  :             pushValue( "{}" );

	push	OFFSET ??_C@_02MCILKGOH@?$HL?$HN?$AA@
	lea	ecx, DWORD PTR $T78495[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	eax, DWORD PTR $T78495[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78495[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 596  :          else

	jmp	$LN4@writeValue
$LN5@writeValue:

; 597  :          {
; 598  :             writeWithIndent( "{" );

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	lea	ecx, DWORD PTR $T78496[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T78496[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78496[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 599  :             indent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?indent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::indent

; 600  :             Value::Members::iterator it = members.begin();

	lea	edx, DWORD PTR _it$56620[ebp]
	push	edx
	lea	ecx, DWORD PTR _members$56615[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
$LN3@writeValue:

; 601  :             for (;;)
; 602  :             {
; 603  :                const std::string &name = *it;

	lea	ecx, DWORD PTR _it$56620[ebp]
	call	??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
	mov	DWORD PTR _name$56625[ebp], eax

; 604  :                const Value &childValue = value[name];

	mov	eax, DWORD PTR _name$56625[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _childValue$56626[ebp], eax

; 605  :                writeCommentBeforeValue( childValue );

	mov	ecx, DWORD PTR _childValue$56626[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue

; 606  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	ecx, DWORD PTR _name$56625[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR $T78497[ebp]
	push	edx
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR tv168[ebp], eax
	mov	eax, DWORD PTR tv168[ebp]
	mov	DWORD PTR tv244[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR tv244[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78497[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 607  :                *document_ << " : ";

	push	OFFSET ??_C@_03MCPBMLDJ@?5?3?5?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 608  :                writeValue( childValue );

	mov	ecx, DWORD PTR _childValue$56626[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue

; 609  :                if ( ++it == members.end() )

	lea	edx, DWORD PTR $T78498[ebp]
	push	edx
	lea	ecx, DWORD PTR _members$56615[ebp]
	call	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
	push	eax
	lea	ecx, DWORD PTR _it$56620[ebp]
	call	??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
	mov	ecx, eax
	call	??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@writeValue

; 610  :                {
; 611  :                   writeCommentAfterValueOnSameLine( childValue );

	mov	ecx, DWORD PTR _childValue$56626[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 612  :                   break;

	jmp	SHORT $LN2@writeValue
$LN1@writeValue:

; 613  :                }
; 614  :                *document_ << ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [edx+24]
	push	eax
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 615  :                writeCommentAfterValueOnSameLine( childValue );

	mov	ecx, DWORD PTR _childValue$56626[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 616  :             }

	jmp	$LN3@writeValue
$LN2@writeValue:

; 617  :             unindent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?unindent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::unindent

; 618  :             writeWithIndent( "}" );

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	lea	ecx, DWORD PTR $T78499[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	edx, DWORD PTR $T78499[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78499[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@writeValue:

; 619  :          }
; 620  :       }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _members$56615[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN14@writeValue:

; 621  :       break;
; 622  :    }
; 623  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN30@writeValue:
	DD	$LN13@writeValue
	DD	$LN12@writeValue
	DD	$LN11@writeValue
	DD	$LN10@writeValue
	DD	$LN9@writeValue
	DD	$LN8@writeValue
	DD	$LN7@writeValue
	DD	$LN6@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T78489[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T78490[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T78491[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T78492[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T78493[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR $T78494[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR _members$56615[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$7:
	lea	ecx, DWORD PTR $T78495[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$8:
	lea	ecx, DWORD PTR $T78496[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$9:
	lea	ecx, DWORD PTR $T78497[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$10:
	lea	ecx, DWORD PTR $T78499[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-388]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeValue
PUBLIC	?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z ; Json::StyledStreamWriter::write
; Function compile flags: /Odtp
;	COMDAT ?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_out$ = 8						; size = 4
_root$ = 12						; size = 4
?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z PROC ; Json::StyledStreamWriter::write, COMDAT
; _this$ = ecx

; 553  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 554  :    document_ = &out;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _out$[ebp]
	mov	DWORD PTR [eax+24], ecx

; 555  :    addChildValues_ = false;

	mov	edx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [edx+88], 0

; 556  :    indentString_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 557  :    writeCommentBeforeValue( root );

	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue

; 558  :    writeValue( root );

	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue

; 559  :    writeCommentAfterValueOnSameLine( root );

	mov	edx, DWORD PTR _root$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 560  :    *document_ << "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+24]
	push	ecx
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	add	esp, 8

; 561  :    document_ = NULL; // Forget the stream, for safety.

	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+24], 0

; 562  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z ENDP ; Json::StyledStreamWriter::write
_TEXT	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10
__ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv244 = -396						; size = 4
tv168 = -392						; size = 4
tv239 = -388						; size = 4
tv249 = -384						; size = 4
tv237 = -380						; size = 4
tv248 = -376						; size = 4
tv235 = -372						; size = 4
tv247 = -368						; size = 4
tv233 = -364						; size = 4
tv246 = -360						; size = 4
tv231 = -356						; size = 4
tv69 = -352						; size = 4
tv66 = -348						; size = 4
_this$ = -344						; size = 4
$T78532 = -340						; size = 28
$T78531 = -312						; size = 8
$T78530 = -304						; size = 28
$T78529 = -276						; size = 28
$T78528 = -248						; size = 28
$T78527 = -220						; size = 28
$T78526 = -192						; size = 28
$T78525 = -164						; size = 28
$T78524 = -136						; size = 28
$T78523 = -108						; size = 28
$T78522 = -80						; size = 28
_name$56374 = -52					; size = 4
_childValue$56375 = -48					; size = 4
_it$56369 = -44						; size = 8
_members$56363 = -36					; size = 24
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::StyledWriter::writeValue, COMDAT
; _this$ = ecx

; 290  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 384				; 00000180H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 291  :    switch ( value.type() )

	mov	ecx, DWORD PTR _value$[ebp]
	call	?type@Value@Json@@QBE?AW4ValueType@2@XZ	; Json::Value::type
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 7
	ja	$LN14@writeValue@2
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN30@writeValue@2[eax*4]
$LN13@writeValue@2:

; 292  :    {
; 293  :    case nullValue:
; 294  :       pushValue( "null" );

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR $T78522[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T78522[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78522[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 295  :       break;

	jmp	$LN14@writeValue@2
$LN12@writeValue@2:

; 296  :    case intValue:
; 297  :       pushValue( valueToString( value.asLargestInt() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asLargestInt@Value@Json@@QBE_JXZ	; Json::Value::asLargestInt
	push	edx
	push	eax
	lea	edx, DWORD PTR $T78523[ebp]
	push	edx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv69[ebp], eax
	mov	eax, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv231[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv231[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78523[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 298  :       break;

	jmp	$LN14@writeValue@2
$LN11@writeValue@2:

; 299  :    case uintValue:
; 300  :       pushValue( valueToString( value.asLargestUInt() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asLargestUInt@Value@Json@@QBE_KXZ	; Json::Value::asLargestUInt
	push	edx
	push	eax
	lea	edx, DWORD PTR $T78524[ebp]
	push	edx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv246[ebp], eax
	mov	eax, DWORD PTR tv246[ebp]
	mov	DWORD PTR tv233[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR tv233[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78524[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 301  :       break;

	jmp	$LN14@writeValue@2
$LN10@writeValue@2:

; 302  :    case realValue:
; 303  :       pushValue( valueToString( value.asDouble() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	edx, DWORD PTR $T78525[ebp]
	push	edx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv247[ebp], eax
	mov	eax, DWORD PTR tv247[ebp]
	mov	DWORD PTR tv235[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv235[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78525[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 304  :       break;

	jmp	$LN14@writeValue@2
$LN9@writeValue@2:

; 305  :    case stringValue:
; 306  :       pushValue( valueToQuotedString( value.asCString() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asCString@Value@Json@@QBEPBDXZ		; Json::Value::asCString
	push	eax
	lea	edx, DWORD PTR $T78526[ebp]
	push	edx
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR tv248[ebp], eax
	mov	eax, DWORD PTR tv248[ebp]
	mov	DWORD PTR tv237[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR tv237[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78526[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 307  :       break;

	jmp	$LN14@writeValue@2
$LN8@writeValue@2:

; 308  :    case booleanValue:
; 309  :       pushValue( valueToString( value.asBool() ) );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	edx, al
	push	edx
	lea	eax, DWORD PTR $T78527[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR tv249[ebp], eax
	mov	ecx, DWORD PTR tv249[ebp]
	mov	DWORD PTR tv239[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	edx, DWORD PTR tv239[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78527[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 310  :       break;

	jmp	$LN14@writeValue@2
$LN7@writeValue@2:

; 311  :    case arrayValue:
; 312  :       writeArrayValue( value);

	mov	eax, DWORD PTR _value$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue

; 313  :       break;

	jmp	$LN14@writeValue@2
$LN6@writeValue@2:

; 314  :    case objectValue:
; 315  :       {
; 316  :          Value::Members members( value.getMemberNames() );

	lea	ecx, DWORD PTR _members$56363[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 317  :          if ( members.empty() )

	lea	ecx, DWORD PTR _members$56363[ebp]
	call	?empty@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::empty
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN5@writeValue@2

; 318  :             pushValue( "{}" );

	push	OFFSET ??_C@_02MCILKGOH@?$HL?$HN?$AA@
	lea	ecx, DWORD PTR $T78528[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	eax, DWORD PTR $T78528[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78528[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 319  :          else

	jmp	$LN4@writeValue@2
$LN5@writeValue@2:

; 320  :          {
; 321  :             writeWithIndent( "{" );

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	lea	ecx, DWORD PTR $T78529[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	lea	ecx, DWORD PTR $T78529[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78529[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 322  :             indent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent

; 323  :             Value::Members::iterator it = members.begin();

	lea	edx, DWORD PTR _it$56369[ebp]
	push	edx
	lea	ecx, DWORD PTR _members$56363[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
$LN3@writeValue@2:

; 324  :             for (;;)
; 325  :             {
; 326  :                const std::string &name = *it;

	lea	ecx, DWORD PTR _it$56369[ebp]
	call	??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
	mov	DWORD PTR _name$56374[ebp], eax

; 327  :                const Value &childValue = value[name];

	mov	eax, DWORD PTR _name$56374[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	DWORD PTR _childValue$56375[ebp], eax

; 328  :                writeCommentBeforeValue( childValue );

	mov	ecx, DWORD PTR _childValue$56375[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 329  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	ecx, DWORD PTR _name$56374[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	edx, DWORD PTR $T78530[ebp]
	push	edx
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR tv168[ebp], eax
	mov	eax, DWORD PTR tv168[ebp]
	mov	DWORD PTR tv244[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	mov	ecx, DWORD PTR tv244[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78530[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 330  :                document_ += " : ";

	push	OFFSET ??_C@_03MCPBMLDJ@?5?3?5?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 331  :                writeValue( childValue );

	mov	edx, DWORD PTR _childValue$56375[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 332  :                if ( ++it == members.end() )

	lea	eax, DWORD PTR $T78531[ebp]
	push	eax
	lea	ecx, DWORD PTR _members$56363[ebp]
	call	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
	push	eax
	lea	ecx, DWORD PTR _it$56369[ebp]
	call	??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
	mov	ecx, eax
	call	??8?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN1@writeValue@2

; 333  :                {
; 334  :                   writeCommentAfterValueOnSameLine( childValue );

	mov	edx, DWORD PTR _childValue$56375[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 335  :                   break;

	jmp	SHORT $LN2@writeValue@2
$LN1@writeValue@2:

; 336  :                }
; 337  :                document_ += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 338  :                writeCommentAfterValueOnSameLine( childValue );

	mov	eax, DWORD PTR _childValue$56375[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 339  :             }

	jmp	$LN3@writeValue@2
$LN2@writeValue@2:

; 340  :             unindent();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?unindent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::unindent

; 341  :             writeWithIndent( "}" );

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	lea	ecx, DWORD PTR $T78532[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	lea	ecx, DWORD PTR $T78532[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T78532[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
$LN4@writeValue@2:

; 342  :          }
; 343  :       }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _members$56363[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN14@writeValue@2:

; 344  :       break;
; 345  :    }
; 346  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN30@writeValue@2:
	DD	$LN13@writeValue@2
	DD	$LN12@writeValue@2
	DD	$LN11@writeValue@2
	DD	$LN10@writeValue@2
	DD	$LN9@writeValue@2
	DD	$LN8@writeValue@2
	DD	$LN7@writeValue@2
	DD	$LN6@writeValue@2
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T78522[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T78523[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T78524[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T78525[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T78526[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR $T78527[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR _members$56363[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7:
	lea	ecx, DWORD PTR $T78528[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8:
	lea	ecx, DWORD PTR $T78529[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9:
	lea	ecx, DWORD PTR $T78530[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10:
	lea	ecx, DWORD PTR $T78532[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-388]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::StyledWriter::writeValue
; Function compile flags: /Odtp
;	COMDAT ?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T78554 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::StyledWriter::write, COMDAT
; _this$ = ecx

; 276  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T78554[ebp], 0

; 277  :    document_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 278  :    addChildValues_ = false;

	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+92], 0

; 279  :    indentString_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 56					; 00000038H
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 280  :    writeCommentBeforeValue( root );

	mov	ecx, DWORD PTR _root$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 281  :    writeValue( root );

	mov	edx, DWORD PTR _root$[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 282  :    writeCommentAfterValueOnSameLine( root );

	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 283  :    document_ += "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 284  :    return document_;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 28					; 0000001cH
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T78554[ebp]
	or	edx, 1
	mov	DWORD PTR $T78554[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 285  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::StyledWriter::write
_TEXT	ENDS
PUBLIC	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z	; Json::FastWriter::writeValue
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6
__ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv237 = -300						; size = 4
tv259 = -296						; size = 4
tv175 = -292						; size = 4
tv256 = -288						; size = 4
tv264 = -284						; size = 4
tv254 = -280						; size = 4
tv263 = -276						; size = 4
tv252 = -272						; size = 4
tv262 = -268						; size = 4
tv250 = -264						; size = 4
tv261 = -260						; size = 4
tv248 = -256						; size = 4
tv260 = -252						; size = 4
tv66 = -248						; size = 4
_this$ = -244						; size = 4
$T78565 = -240						; size = 28
$T78564 = -212						; size = 8
$T78563 = -204						; size = 8
$T78562 = -196						; size = 28
$T78561 = -168						; size = 28
$T78560 = -140						; size = 28
$T78559 = -112						; size = 28
$T78558 = -84						; size = 28
_name$56325 = -56					; size = 4
_it$56319 = -52						; size = 8
_members$56159 = -44					; size = 24
_index$56150 = -20					; size = 4
_size$56149 = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::FastWriter::writeValue, COMDAT
; _this$ = ecx

; 206  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 288				; 00000120H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 207  :    switch ( value.type() )

	mov	ecx, DWORD PTR _value$[ebp]
	call	?type@Value@Json@@QBE?AW4ValueType@2@XZ	; Json::Value::type
	mov	DWORD PTR tv66[ebp], eax
	cmp	DWORD PTR tv66[ebp], 7
	ja	$LN18@writeValue@3
	mov	eax, DWORD PTR tv66[ebp]
	jmp	DWORD PTR $LN32@writeValue@3[eax*4]
$LN17@writeValue@3:

; 208  :    {
; 209  :    case nullValue:
; 210  :       if (!dropNullPlaceholders_) document_ += "null";

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+33]
	test	edx, edx
	jne	SHORT $LN16@writeValue@3
	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN16@writeValue@3:

; 211  :       break;

	jmp	$LN18@writeValue@3
$LN15@writeValue@3:

; 212  :    case intValue:
; 213  :       document_ += valueToString( value.asLargestInt() );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asLargestInt@Value@Json@@QBE_JXZ	; Json::Value::asLargestInt
	push	edx
	push	eax
	lea	eax, DWORD PTR $T78558[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_J@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv260[ebp], eax
	mov	ecx, DWORD PTR tv260[ebp]
	mov	DWORD PTR tv248[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv248[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78558[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 214  :       break;

	jmp	$LN18@writeValue@3
$LN14@writeValue@3:

; 215  :    case uintValue:
; 216  :       document_ += valueToString( value.asLargestUInt() );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asLargestUInt@Value@Json@@QBE_KXZ	; Json::Value::asLargestUInt
	push	edx
	push	eax
	lea	eax, DWORD PTR $T78559[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_K@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv261[ebp], eax
	mov	ecx, DWORD PTR tv261[ebp]
	mov	DWORD PTR tv250[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	edx, DWORD PTR tv250[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78559[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 217  :       break;

	jmp	$LN18@writeValue@3
$LN13@writeValue@3:

; 218  :    case realValue:
; 219  :       document_ += valueToString( value.asDouble() );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	fstp	QWORD PTR [esp]
	lea	eax, DWORD PTR $T78560[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv262[ebp], eax
	mov	ecx, DWORD PTR tv262[ebp]
	mov	DWORD PTR tv252[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv252[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78560[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 220  :       break;

	jmp	$LN18@writeValue@3
$LN12@writeValue@3:

; 221  :    case stringValue:
; 222  :       document_ += valueToQuotedString( value.asCString() );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asCString@Value@Json@@QBEPBDXZ		; Json::Value::asCString
	push	eax
	lea	eax, DWORD PTR $T78561[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR tv263[ebp], eax
	mov	ecx, DWORD PTR tv263[ebp]
	mov	DWORD PTR tv254[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR tv254[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78561[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 223  :       break;

	jmp	$LN18@writeValue@3
$LN11@writeValue@3:

; 224  :    case booleanValue:
; 225  :       document_ += valueToString( value.asBool() );

	mov	ecx, DWORD PTR _value$[ebp]
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	eax, al
	push	eax
	lea	ecx, DWORD PTR $T78562[ebp]
	push	ecx
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR tv264[ebp], eax
	mov	edx, DWORD PTR tv264[ebp]
	mov	DWORD PTR tv256[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	eax, DWORD PTR tv256[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T78562[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 226  :       break;

	jmp	$LN18@writeValue@3
$LN10@writeValue@3:

; 227  :    case arrayValue:
; 228  :       {
; 229  :          document_ += "[";

	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 230  :          int size = value.size();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	DWORD PTR _size$56149[ebp], eax

; 231  :          for ( int index =0; index < size; ++index )

	mov	DWORD PTR _index$56150[ebp], 0
	jmp	SHORT $LN9@writeValue@3
$LN8@writeValue@3:
	mov	ecx, DWORD PTR _index$56150[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$56150[ebp], ecx
$LN9@writeValue@3:
	mov	edx, DWORD PTR _index$56150[ebp]
	cmp	edx, DWORD PTR _size$56149[ebp]
	jge	SHORT $LN7@writeValue@3

; 232  :          {
; 233  :             if ( index > 0 )

	cmp	DWORD PTR _index$56150[ebp], 0
	jle	SHORT $LN6@writeValue@3

; 234  :                document_ += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN6@writeValue@3:

; 235  :             writeValue( value[index] );

	mov	eax, DWORD PTR _index$56150[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@H@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue

; 236  :          }

	jmp	SHORT $LN8@writeValue@3
$LN7@writeValue@3:

; 237  :          document_ += "]";

	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 238  :       }
; 239  :       break;

	jmp	$LN18@writeValue@3
$LN5@writeValue@3:

; 240  :    case objectValue:
; 241  :       {
; 242  :          Value::Members members( value.getMemberNames() );

	lea	ecx, DWORD PTR _members$56159[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 243  :          document_ += "{";

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 244  :          for ( Value::Members::iterator it = members.begin(); 

	lea	edx, DWORD PTR _it$56319[ebp]
	push	edx
	lea	ecx, DWORD PTR _members$56159[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin

; 245  :                it != members.end(); 
; 246  :                ++it )

	jmp	SHORT $LN4@writeValue@3
$LN3@writeValue@3:
	lea	ecx, DWORD PTR _it$56319[ebp]
	call	??E?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator++
$LN4@writeValue@3:
	lea	eax, DWORD PTR $T78563[ebp]
	push	eax
	lea	ecx, DWORD PTR _members$56159[ebp]
	call	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
	push	eax
	lea	ecx, DWORD PTR _it$56319[ebp]
	call	??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@writeValue@3

; 247  :          {
; 248  :             const std::string &name = *it;

	lea	ecx, DWORD PTR _it$56319[ebp]
	call	??D?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator*
	mov	DWORD PTR _name$56325[ebp], eax

; 249  :             if ( it != members.begin() )

	lea	edx, DWORD PTR $T78564[ebp]
	push	edx
	lea	ecx, DWORD PTR _members$56159[ebp]
	call	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
	push	eax
	lea	ecx, DWORD PTR _it$56319[ebp]
	call	??9?$_Vector_const_iterator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator!=
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN1@writeValue@3

; 250  :                document_ += ",";

	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
$LN1@writeValue@3:

; 251  :             document_ += valueToQuotedString( name.c_str() );

	mov	ecx, DWORD PTR _name$56325[ebp]
	call	DWORD PTR __imp_?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
	push	eax
	lea	ecx, DWORD PTR $T78565[ebp]
	push	ecx
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR tv175[ebp], eax
	mov	edx, DWORD PTR tv175[ebp]
	mov	DWORD PTR tv259[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	mov	eax, DWORD PTR tv259[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	lea	ecx, DWORD PTR $T78565[ebp]
	call	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ

; 252  :             document_ += yamlCompatiblityEnabled_ ? ": " 
; 253  :                                                   : ":";

	mov	ecx, DWORD PTR _this$[ebp]
	movzx	edx, BYTE PTR [ecx+32]
	test	edx, edx
	je	SHORT $LN22@writeValue@3
	mov	DWORD PTR tv237[ebp], OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	jmp	SHORT $LN23@writeValue@3
$LN22@writeValue@3:
	mov	DWORD PTR tv237[ebp], OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
$LN23@writeValue@3:
	mov	eax, DWORD PTR tv237[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 254  :             writeValue( value[name] );

	mov	ecx, DWORD PTR _name$56325[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue

; 255  :          }

	jmp	$LN3@writeValue@3
$LN2@writeValue@3:

; 256  :          document_ += "}";

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 257  :       }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _members$56159[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN18@writeValue@3:

; 258  :       break;
; 259  :    }
; 260  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN32@writeValue@3:
	DD	$LN17@writeValue@3
	DD	$LN15@writeValue@3
	DD	$LN14@writeValue@3
	DD	$LN13@writeValue@3
	DD	$LN12@writeValue@3
	DD	$LN11@writeValue@3
	DD	$LN10@writeValue@3
	DD	$LN5@writeValue@3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T78558[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T78559[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T78560[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T78561[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T78562[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR _members$56159[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR $T78565[ebp]
	jmp	DWORD PTR __imp_??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-292]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::FastWriter::writeValue
; Function compile flags: /Odtp
;	COMDAT ?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
$T78585 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::FastWriter::write, COMDAT
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T78585[ebp], 0

; 197  :    document_ = "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 198  :    writeValue( root );

	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue

; 199  :    document_ += "\n";

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	DWORD PTR __imp_??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z

; 200  :    return document_;

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	push	ecx
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
	mov	edx, DWORD PTR $T78585[ebp]
	or	edx, 1
	mov	DWORD PTR $T78585[ebp], edx
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 201  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::FastWriter::write
PUBLIC	__$ArrayPad$
PUBLIC	??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z ; Json::operator<<
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z$1
__ehfuncinfo$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
; Function compile flags: /Odtp
xdata$x	ENDS
;	COMDAT ??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
_TEXT	SEGMENT
tv86 = -132						; size = 4
tv85 = -128						; size = 4
$T78840 = -124						; size = 4
$T78839 = -120						; size = 4
_writer$ = -116						; size = 92
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sout$ = 8						; size = 4
_root$ = 12						; size = 4
??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z PROC ; Json::operator<<, COMDAT

; 821  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 822  :    Json::StyledStreamWriter writer;

	sub	esp, 28					; 0000001cH
	mov	ecx, esp
	mov	DWORD PTR $T78839[ebp], esp
	push	OFFSET ??_C@_01GPOEFGEJ@?7?$AA@
	call	DWORD PTR __imp_??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
	mov	DWORD PTR tv85[ebp], eax
	lea	ecx, DWORD PTR _writer$[ebp]
	call	??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::StyledStreamWriter
	mov	DWORD PTR tv86[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 823  :    writer.write(sout, root);

	mov	eax, DWORD PTR _root$[ebp]
	push	eax
	mov	ecx, DWORD PTR _sout$[ebp]
	push	ecx
	lea	ecx, DWORD PTR _writer$[ebp]
	call	?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z ; Json::StyledStreamWriter::write

; 824  :    return sout;

	mov	edx, DWORD PTR _sout$[ebp]
	mov	DWORD PTR $T78840[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _writer$[ebp]
	call	??1StyledStreamWriter@Json@@QAE@XZ	; Json::StyledStreamWriter::~StyledStreamWriter
	mov	eax, DWORD PTR $T78840[ebp]

; 825  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z$1:
	lea	ecx, DWORD PTR _writer$[ebp]
	jmp	??1StyledStreamWriter@Json@@QAE@XZ	; Json::StyledStreamWriter::~StyledStreamWriter
__ehhandler$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-124]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??6Json@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@AAV12@ABVValue@0@@Z ENDP ; Json::operator<<
; Function compile flags: /Odtp
;	COMDAT ?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
tv169 = -40						; size = 4
tv162 = -36						; size = 4
tv93 = -32						; size = 4
_this$ = -28						; size = 4
_index$56426 = -24					; size = 4
_lineLength$56425 = -20					; size = 4
_childValue$56423 = -16					; size = 4
_index$56419 = -12					; size = 4
_size$ = -8						; size = 4
_isMultiLine$ = -1					; size = 1
_value$ = 8						; size = 4
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::isMultineArray, COMDAT
; _this$ = ecx

; 404  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	DWORD PTR _this$[ebp], ecx

; 405  :    int size = value.size();

	mov	ecx, DWORD PTR _value$[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	DWORD PTR _size$[ebp], eax

; 406  :    bool isMultiLine = size*3 >= rightMargin_ ;

	mov	eax, DWORD PTR _size$[ebp]
	imul	eax, 3
	mov	ecx, DWORD PTR _this$[ebp]
	xor	edx, edx
	cmp	eax, DWORD PTR [ecx+84]
	setge	dl
	mov	BYTE PTR _isMultiLine$[ebp], dl

; 407  :    childValues_.clear();

	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?clear@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXXZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::clear

; 408  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	mov	DWORD PTR _index$56419[ebp], 0
	jmp	SHORT $LN7@isMultineA@2
$LN6@isMultineA@2:
	mov	eax, DWORD PTR _index$56419[ebp]
	add	eax, 1
	mov	DWORD PTR _index$56419[ebp], eax
$LN7@isMultineA@2:
	mov	ecx, DWORD PTR _index$56419[ebp]
	cmp	ecx, DWORD PTR _size$[ebp]
	jge	SHORT $LN5@isMultineA@2
	movzx	edx, BYTE PTR _isMultiLine$[ebp]
	test	edx, edx
	jne	SHORT $LN5@isMultineA@2

; 409  :    {
; 410  :       const Value &childValue = value[index];

	mov	eax, DWORD PTR _index$56419[ebp]
	push	eax
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@H@Z		; Json::Value::operator[]
	mov	DWORD PTR _childValue$56423[ebp], eax

; 411  :       isMultiLine = isMultiLine  ||
; 412  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 413  :                         childValue.size() > 0 );

	movzx	ecx, BYTE PTR _isMultiLine$[ebp]
	test	ecx, ecx
	jne	SHORT $LN12@isMultineA@2
	mov	ecx, DWORD PTR _childValue$56423[ebp]
	call	?isArray@Value@Json@@QBE_NXZ		; Json::Value::isArray
	movzx	edx, al
	test	edx, edx
	jne	SHORT $LN10@isMultineA@2
	mov	ecx, DWORD PTR _childValue$56423[ebp]
	call	?isObject@Value@Json@@QBE_NXZ		; Json::Value::isObject
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN11@isMultineA@2
$LN10@isMultineA@2:
	mov	ecx, DWORD PTR _childValue$56423[ebp]
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	ja	SHORT $LN12@isMultineA@2
$LN11@isMultineA@2:
	mov	DWORD PTR tv93[ebp], 0
	jmp	SHORT $LN13@isMultineA@2
$LN12@isMultineA@2:
	mov	DWORD PTR tv93[ebp], 1
$LN13@isMultineA@2:
	mov	cl, BYTE PTR tv93[ebp]
	mov	BYTE PTR _isMultiLine$[ebp], cl

; 414  :    }

	jmp	SHORT $LN6@isMultineA@2
$LN5@isMultineA@2:

; 415  :    if ( !isMultiLine ) // check if line length > max line length

	movzx	edx, BYTE PTR _isMultiLine$[ebp]
	test	edx, edx
	jne	$LN4@isMultineA@2

; 416  :    {
; 417  :       childValues_.reserve( size );

	mov	eax, DWORD PTR _size$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	?reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::reserve

; 418  :       addChildValues_ = true;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+92], 1

; 419  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'

	mov	edx, DWORD PTR _size$[ebp]
	lea	eax, DWORD PTR [edx+edx+2]
	mov	DWORD PTR _lineLength$56425[ebp], eax

; 420  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	mov	DWORD PTR _index$56426[ebp], 0
	jmp	SHORT $LN3@isMultineA@2
$LN2@isMultineA@2:
	mov	ecx, DWORD PTR _index$56426[ebp]
	add	ecx, 1
	mov	DWORD PTR _index$56426[ebp], ecx
$LN3@isMultineA@2:
	mov	edx, DWORD PTR _index$56426[ebp]
	cmp	edx, DWORD PTR _size$[ebp]
	jge	SHORT $LN1@isMultineA@2
	movzx	eax, BYTE PTR _isMultiLine$[ebp]
	test	eax, eax
	jne	SHORT $LN1@isMultineA@2

; 421  :       {
; 422  :          writeValue( value[index] );

	mov	ecx, DWORD PTR _index$56426[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@H@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 423  :          lineLength += int( childValues_[index].length() );

	mov	edx, DWORD PTR _index$56426[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 4
	call	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
	mov	ecx, eax
	call	DWORD PTR __imp_?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
	add	eax, DWORD PTR _lineLength$56425[ebp]
	mov	DWORD PTR _lineLength$56425[ebp], eax

; 424  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );

	movzx	eax, BYTE PTR _isMultiLine$[ebp]
	test	eax, eax
	je	SHORT $LN14@isMultineA@2
	mov	ecx, DWORD PTR _index$56426[ebp]
	push	ecx
	mov	ecx, DWORD PTR _value$[ebp]
	call	??AValue@Json@@QBEABV01@H@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::hasCommentForValue
	movzx	edx, al
	test	edx, edx
	je	SHORT $LN14@isMultineA@2
	mov	DWORD PTR tv162[ebp], 1
	jmp	SHORT $LN15@isMultineA@2
$LN14@isMultineA@2:
	mov	DWORD PTR tv162[ebp], 0
$LN15@isMultineA@2:
	mov	al, BYTE PTR tv162[ebp]
	mov	BYTE PTR _isMultiLine$[ebp], al

; 425  :       }

	jmp	$LN2@isMultineA@2
$LN1@isMultineA@2:

; 426  :       addChildValues_ = false;

	mov	ecx, DWORD PTR _this$[ebp]
	mov	BYTE PTR [ecx+92], 0

; 427  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;

	movzx	edx, BYTE PTR _isMultiLine$[ebp]
	test	edx, edx
	jne	SHORT $LN16@isMultineA@2
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _lineLength$56425[ebp]
	cmp	ecx, DWORD PTR [eax+84]
	jge	SHORT $LN16@isMultineA@2
	mov	DWORD PTR tv169[ebp], 0
	jmp	SHORT $LN17@isMultineA@2
$LN16@isMultineA@2:
	mov	DWORD PTR tv169[ebp], 1
$LN17@isMultineA@2:
	mov	dl, BYTE PTR tv169[ebp]
	mov	BYTE PTR _isMultiLine$[ebp], dl
$LN4@isMultineA@2:

; 428  :    }
; 429  :    return isMultiLine;

	mov	al, BYTE PTR _isMultiLine$[ebp]

; 430  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::isMultineArray
END
